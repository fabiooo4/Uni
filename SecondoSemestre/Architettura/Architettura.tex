\documentclass[a4paper]{article}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{textcomp}
\usepackage[italian]{babel}
\usepackage{amsmath, amssymb}
\usepackage{amsfonts}
\usepackage{mdframed}
\usepackage{float}
\usepackage{xcolor}
\usepackage{listings}
\usepackage{graphicx}
\usepackage{tikz}
\usetikzlibrary{shapes, arrows, automata, petri, positioning, calc}
\usepackage{circuitikz}
\usepackage[label=corner]{karnaugh-map}
\graphicspath{{./figures/}}

\usepackage{ntheorem}
\newtheorem{theorem}{Teorema}

\usepackage{import}
\usepackage{pdfpages}
\usepackage{transparent}
\usepackage{xcolor}

\usepackage{hyperref}
\hypersetup{
    colorlinks=false,
}

% Code blocks
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.95}

\lstdefinestyle{mystyle}{
	backgroundcolor=\color{backcolour},
	commentstyle=\color{codegreen},
	keywordstyle=\color{magenta},
	numberstyle=\tiny\color{codegray},
	stringstyle=\color{codepurple},
	basicstyle=\ttfamily\footnotesize,
	breakatwhitespace=false,
	breaklines=true,
	captionpos=b,
	keepspaces=true,
	numbers=left,
	numbersep=5pt,
	showspaces=false,
	showstringspaces=false,
	showtabs=false,
	tabsize=2
}

\lstset{style=mystyle}

\usepackage{color}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=tb,
	aboveskip=3mm,
	belowskip=3mm,
	showstringspaces=false,
	columns=flexible,
	basicstyle={\small\ttfamily},
	numbers=none,
	numberstyle=\tiny\color{gray},
	keywordstyle=\color{blue},
	commentstyle=\color{dkgreen},
	stringstyle=\color{mauve},
	breaklines=true,
	breakatwhitespace=true,
	tabsize=3
}

\usepackage{import}
\usepackage{pdfpages}
\usepackage{transparent}
\usepackage{xcolor}



% Useful definitions frame
\theoremstyle{break}
\theoremheaderfont{\bfseries}
\newmdtheoremenv[%
	linecolor=gray,leftmargin=0,%
	rightmargin=0,
	innertopmargin=8pt,%
	innerbottommargin=8pt,
	ntheorem]{define}{Definizioni utili}[section]

% Example frame
\theoremstyle{break}
\theoremheaderfont{\bfseries}
\newmdtheoremenv[%
	linecolor=gray,leftmargin=0,%
	rightmargin=0,
	innertopmargin=8pt,%
	innerbottommargin=8pt,
	ntheorem]{example}{Esempio}[section]

% Important definition frame
\theoremstyle{break}
\theoremheaderfont{\bfseries}
\newmdtheoremenv[%
	linecolor=gray,leftmargin=0,%
	rightmargin=0,
	backgroundcolor=gray!40,%
	innertopmargin=8pt,%
	innerbottommargin=8pt,
	ntheorem]{definition}{Definizione}[section]

% Exercise frame
\theoremstyle{break}
\theoremheaderfont{\bfseries}
\newmdtheoremenv[%
	linecolor=gray,leftmargin=0,%
	rightmargin=0,
	innertopmargin=8pt,%
	innerbottommargin=8pt,
	ntheorem]{exercise}{Esercizio}[section]

% figure support
\usepackage{import}
\usepackage{xifthen}
\pdfminorversion=7
\usepackage{pdfpages}
\usepackage{transparent}
\newcommand{\incfig}[1]{%
	\def\svgwidth{\columnwidth}
	\import{./figures/}{#1.pdf_tex}
}

% FSM tikz
\tikzset{
    place/.style={
        circle,
        thick,
        draw=black,
        minimum size=6mm,
    },
        state/.style={
        circle,
        thick,
        draw=blue!75,
        fill=blue!20,
        minimum size=6mm,
    },
}

\pdfsuppresswarningpagegroup=1

\begin{document}
\input{title.tex}

\tableofcontents
\pagebreak

\section{Architettura di Von Neumann}
L'esigenza era quella di avere un'architettura che permettesse di eseguire programmi
in modo automatico, senza dover cambiare il cablaggio del calcolatore, quindi il circuito
deve essere abbastanza generale per poter eseguire programmi diversi.

\subsection{Struttura}
L'architettura di Von Neumann è composta da 5 parti principali:
\begin{itemize}
	\item \textbf{Unità aritmetico-logica}: si occupa di eseguire le operazioni aritmetiche e logiche
	\item \textbf{Unità di controllo}: si occupa di controllare il flusso delle istruzioni
	\item \textbf{Memoria}: contiene i dati e le istruzioni
	\item \textbf{Input/Output}: permette di comunicare con l'esterno
	\item \textbf{Bus}: permette di trasferire i dati tra la memoria e l'unità aritmetico-logica (generalmente in oro)
\end{itemize}

\begin{figure}[H]
	\centering
	\begin{tikzpicture}
		% CPU
		\node[draw, rectangle, minimum width=2cm, minimum height=1.5cm] (cpu) at (0, 0) {\textbf{CPU}};
		% Memoria
		\node[draw, rectangle, align=center, minimum width=2cm, minimum height=1.5cm] (memory) at (4, 0) {\textbf{Memoria}\\\footnotesize Dati\\\footnotesize Istruzioni};

		% Bus
		\draw (-2,-2) -- (6.5,-2) node[right] {Bus};
		\draw[<->] (cpu) -- ++(0,-2);
		\draw[<->] (memory) -- ++(0,-2);

		% Input/Output below bus
		\node[draw, rectangle, minimum width=0.7cm, minimum height=0.7cm] (io) at (2, -3) {\textbf{I/O}};
		\draw[<->] (io) -- (2,-2);

		% Keyboard and mouse below I/O
		\node (keyboard) at (1, -4) {Tastiera};
		\node (mouse) at (3, -4) {Mouse};
		\draw[->] (keyboard) -- (io);
		\draw[->] (mouse) -- (io);


	\end{tikzpicture}
\end{figure}

\subsection{Caratteristiche}
Le istruzioni hanno bisogno di un'operazione che permetta di effettuare dei salti,
in modo da poter implementare i cicli e le strutture di controllo. Inoltre le istruzioni
devono essere eseugite in sequenza (un'istruzione alla volta).

\subsection{CPU}
Ogni processore ha un'set di istruzioni diverso in base all'architettura,
questo set di istruzioni è chiamato \textbf{ISA} (Instruction Set Architecture).
\textbf{Assembly} è un linguaggio di programmazione che permette di scrivere programmi
in base all'ISA del processore e questo linguaggio viene tradotto in linguaggio binario
attraverso un \textbf{assembler}. In questo corso viene usata l'architettura x86 (80x86).

\subsubsection{Modello semplificato}
Per rappresentare il funzionamento di un processore si può usare un modello semplificato
rappresentato ad alto livello. Questo modello è composto da:
\begin{itemize}
	\item \textbf{Central Processing Unit (CPU)}: esegue le istruzioni
	\item \textbf{Control Unit (CU)}: controlla il flusso delle istruzioni
	\item \textbf{Bus Dati (BD)}: trasferisce i dati alla CPU
	\item \textbf{Bus Istruzioni (BI)}: trasferisce le istruzioni alla CPU
	\item \textbf{Bus di Controllo (BC)}: trasferisce i segnali di controllo
	\item \textbf{Memory Address Register (MAR)}: contiene l'indirizzo di memoria da leggere
	\item \textbf{Memory Data Register (MDR)}: contiene i dati letti dalla memoria
	\item \textbf{Program Counter (PC)}: tiene conto dell'indirizzo dell'istruzione da eseguire
	\item \textbf{Instruction Register (IR)}: contiene l'istruzione corrente
	\item \textbf{Program Status Word (PSW)}: contiene i flag del processore (es. zero, carry, overflow).
	      È come se fosse un array in cui ad ogni indice corrisponde un flag per ogni operazione.
	\item \textbf{Register File}: contiene i registri del processore (es. EAX, EBX, ECX, EDX, ESI, EDI, ESP, EBP)
	\item \textbf{Arithmetic Logic Unit (ALU)}: esegue le operazioni aritmetiche e logiche
\end{itemize}
\begin{figure}[H]
	\centering
	\begin{tikzpicture}[scale=1.5]
		\draw (0,0) rectangle (4,4);
		\node[above left, scale=0.7] at (4,0) {CPU};

		\draw (2,2) rectangle (4,4);
		\node[above left, scale=0.7] at (3.4,2) {CU};

		\node[draw, rectangle, align=center, scale=0.8, minimum width=1cm, minimum height=0.8cm] (pc) at (2.4, 2.35) {PC};
		\node[draw, rectangle, align=center, scale=0.8, minimum width=1cm, minimum height=0.8cm] (ir) at (2.4, 2.95) {IR};
		\node[draw, rectangle, align=center, scale=0.8, minimum width=1cm, minimum height=0.5cm] (psw) at (3.4, 3.55) {PSW};

		% Bus Istruzioni
		\draw (-0.5,0) -- (-0.5,4) node[above, scale=0.7] {BI};

		% Bus Dati
		\draw (-1,0) -- (-1,4) node[above, scale=0.7] {BD};

		% Bus di controllo
		\draw (4.5,0) -- (4.5,4) node[above, scale=0.7] {BC};

		% MAR (Memory Address Register)
		\node[draw, rectangle, align=center, scale=0.8, minimum width=0.5cm, minimum height=0.5cm] (mar) at (0.5, 3) {M\\A\\R};
		\draw[latex-latex] (mar) -- (-0.5,3);

		% MDR (Memory Data Register)
		\node[draw, rectangle, align=center, scale=0.8, minimum width=0.5cm, minimum height=0.5cm] (mdr) at (0.5, 1) {M\\D\\R};
		\draw[latex-latex] (mdr) -- (-1,1);

		\draw[latex-latex] (4,3) -- (4.5,3);

		% Register file
		\draw (1,0.4) rectangle (2,1.6);
		\draw (1,0.6) -- (2,0.6);
		\draw (1,0.8) -- (2,0.8);
		\draw (1,1) -- (2,1);
		\draw (1,1.2) -- (2,1.2);
		\draw (1,1.4) -- (2,1.4);

		\node[below left, xshift=8, scale=0.7] at (1.82,0.4) {Register File};

		% ALU
		\draw (2.7,0.5) -- (3.3,0.5) -- (3.5,1.5) -- (3.2,1.5) -- (3,1.2) -- (2.8,1.5) -- (2.5,1.5) -- cycle;
		\node[above, scale=0.6] at (3,0.5) {ALU};

		% Collegamenti
		\draw[latex-] (2.6,1.5) -- ++(0,0.2) -- ++(-0.8,0) -- ++(0,-0.1);
		\draw[latex-] (3.4, 1.5) -- ++(0,0.4) -- ++(-2.2,0) -- ++(0,-0.3);
		\draw[-latex] (3.4,1) -- ++(0.4,0) -- ++(0,2) -- ++(-0.2,0) -| (psw);
		\draw[-latex] (3,0.5) -- ++(0,-0.3) -- ++(-0.5,0) -- ++(0,0.3) -- ++(-0.5,0);
		\draw[-latex] (2.3,2) -- ++(0,-1) -- ++(0.3,0);
	\end{tikzpicture}
	\caption{Struttura di un processore}
\end{figure}

\noindent Il flusso di esecuzione delle istruzioni è il seguente:
\begin{itemize}
	\item \textbf{Fetch}: CU legge l'istruzione dalla memoria
	\item \textbf{Decode}: CU decodifica l'istruzione
	\item \textbf{Execute}: ALU esegue l'istruzione
\end{itemize}

\begin{figure}[H]
	\centering
	\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=3cm,
			thick,main node/.style={circle,draw,font=\sffamily\Large\bfseries}]

		\node[main node] (1) {\footnotesize Fetch};
		\node[main node] (2) [right of=1] {\footnotesize Decode};
		\node[main node] (3) [right of=2] {\footnotesize Execute};

		\path[every node/.style={font=\sffamily\small}]
		(1) edge [bend left] node {} (2)
		(2) edge [bend left] node {} (3)
		(3) edge [bend left] node {} (1);
	\end{tikzpicture}
	\caption{Flusso di esecuzione delle istruzioni}
\end{figure}

\section{Assembly (Intel x86)}
\subsection{Codifica}
Ogni istruzione è codificata nel seguente modo:

\begin{figure}[H]
	\centering
	\begin{tikzpicture}
		% Opcode
		\draw (0,0) rectangle (1.5,1);
		\node at (0.75,0.5) {Opcode};

		% Metodi di indirizzamento
		\draw (1.8,0) -- (1.8,1);
		\node[align=center, scale=0.7] at (1.65,0.5) {M\\I};

		% Source
		\draw (1.5,0) rectangle (3.6,1);
		\node at (2.55,0.5) {Source};

		% Metodi di indirizzamento
		\draw (3.3,0) -- (3.3,1);
		\node[align=center, scale=0.7] at (3.45,0.5) {M\\I};

		% Destination
		\draw (3.6,0) rectangle (5.6,1);
		\node at (4.6,0.5) {Destination};

	\end{tikzpicture}
\end{figure}

\subsection{Istruzioni}
\subsubsection{Istruzioni di inizializzazione}
\begin{itemize}
	\item \textbf{\texttt{MOVL <source> <destination>}}: copia il contenuto di un registro (o costante) in un altro.
	      Questa istruzione di solito viene utilizzata per spostare i valori dalla memoria ai
	      registri e viceversa, in modo da poter effettuare operazioni solo su dati presenti
	      nei registri e non direttamente in memoria, questo rende l'esecuzione più efficiente.
	\item \textbf{\texttt{NOP}}: non fa nulla e occupa solo un byte. La sua utilità è quella
	      di "riempire i buchi", cioè delle zone di memoria non occupate da nessuna istruzione.
\end{itemize}

\subsubsection{Istruzioni aritmetiche}
\begin{itemize}
	\item \textbf{\texttt{ADDL <source> <destination>}}: somma il contenuto di due registri (o costante).
	      Siccome sono disponibili solo 2 parametri, il risultato viene salvato nel secondo parametro
	      perchè viene visto sia come sorgente che destinazione per evitare di aggiungerne un terzo.
	\item \textbf{\texttt{SUBL <source> <destination>}}: sottrae il contenuto di due registri (o costante)
	\item \textbf{\texttt{MULL <source> <destination>}}: moltiplica il contenuto di due registri (o costante)
	\item \textbf{\texttt{INC <source>}}: incrementa il contenuto di un registro (o costante) di 1
	\item \textbf{\texttt{DEC <source>}}: decrementa il contenuto di un registro (o costante) di 1
\end{itemize}

\subsubsection{Istruzioni logiche}

\begin{itemize}
	\item \textbf{\texttt{CMPL <source> <destination>}}: confronta il contenuto di due registri (o costanti) e
	      modifica il flag \textbf{\texttt{PSW}} in base al risultato del confronto.
\end{itemize}

\subsubsection{Istruzioni di salto}
Se il salto è \textbf{assoluto} l'indirizzo fa riferimento alla memoria diretta, mentre se il salto è
\textbf{relativo} l'indirizzo è relativo al Program Counter.
\begin{itemize}
	\item \textbf{\texttt{JMP <etichetta>}}: salta all'istruzione con etichetta
	\item \textbf{\texttt{JE <etichetta>}}: salta all'istruzione con etichetta se i flag sono settati in modo che i due operandi siano uguali
	\item \textbf{\texttt{JNE <etichetta>}}: salta all'istruzione con etichetta se i flag sono settati in modo che i due operandi siano diversi
	\item \textbf{\texttt{JG <etichetta>}}: salta all'istruzione con etichetta se i flag sono settati in modo che il primo operando sia maggiore del secondo
	\item \textbf{\texttt{JGE <etichetta>}}: salta all'istruzione con etichetta se i flag sono settati in modo che il primo operando sia maggiore o uguale del secondo
	\item \textbf{\texttt{JL <etichetta>}}: salta all'istruzione con etichetta se i flag sono settati in modo che il primo operando sia minore del secondo
	\item \textbf{\texttt{JLE <etichetta>}}: salta all'istruzione con etichetta se i flag sono settati in modo che il primo operando sia minore o uguale del secondo
\end{itemize}
Comparando e poi utilizzando i salti si possono implementare le strutture di controllo come i cicli e le condizioni.
Nell'etichetta si può inserire un'indirizzo di memoria assoluto che permette di saltare a quell'indirizzo,
questo però non è molto utile perchè il programma potrebbe essere caricato in un'area diversa della memoria.

\subsubsection{Istruzioni di gestione dello Stack}
\begin{itemize}
	\item \textbf{\texttt{PUSHL <source>}}: inserisce il contenuto di un registro (o costante) nello stack
	\item \textbf{\texttt{POPL <destination>}}: estrae il contenuto dello stack e lo mette in un registro (o costante)
	\item \textbf{\texttt{CALL <etichetta>}}: salva l'indirizzo successivo al Program Counter nello stack e salta all'istruzione con etichetta
\end{itemize}

\subsubsection{Metodi di indirizzamento}
I metodi di indirizzamento (MI) sono diversi modi per accedere ai dati in memoria, i
più comuni sono:
\begin{itemize}
	\item \textbf{Registro}: Un'istruzione può accedere direttamente ai registri
	      ad esempio: \texttt{MOVL \%EAX, \%EBX}
	\item \textbf{Immediato}: Un'istruzione può accedere direttamente ai dati
	      ad esempio: \texttt{MOVL \$10, \%EBX}
	\item \textbf{Assoluto}: Un'istruzione può accedere direttamente ai dati
	      ad esempio: \texttt{MOVL DATO, \%EBX}\\
	      dove \texttt{DATO} è un'etichetta che punta ad un'indirizzo di memoria
	\item \textbf{Indiretto Registro}: Un'istruzione può contenere un registro che punta ad un altro registro
	      ad esempio: \texttt{MOVL (\%EAX), \%EBX}
	\item \textbf{Indiretto Registro con Spiazzamento}: Un'istruzione può mettere un offset
	      rispetto al registro contenuto nell'istruzione
	      ad esempio: \texttt{MOVL \$8(\%EAX), \%EBX}
\end{itemize}

\noindent Non tutte le istruzioni ammettono tutti i metodi di indirizzamento e alcuni metodi di indirizzamento
possono essere usati solo con alcune istruzioni.

\subsection{Esempi}
Un esempio di codice in C è il seguente:
\begin{lstlisting}[language=C]
  ...
  int a; // INDA (etichetta che punta ad un indirizzo di memoria con valore intero)
  int b; // INDB
  int c; // INDB
  ...
  a = 5; // %EAX
  b = 10; // %EBX

  if (a > b) {
    c = a - b; // %ECX
  } else { // ELSE
    c = a + b;
  }
  \end{lstlisting}

La traduzione in assembly è la seguente:
\begin{lstlisting}[language={[x86masm]Assembler}]
  MOVL INDA, %EAX // Ridondante
  MOVL $5, %EAX
  MOVL INDB, %EBX // Ridondante
  MOVL $10, %EBX
  MOVL %EAX, %ECX
  COMPL %EAX, %EBX
  JLE ELSE
  SUBL %ECX, %EAX
  JMP ENDIF
  ELSE:
  ADDL %EBX, %ECX
  ENDIF:
\end{lstlisting}

\noindent Un altro esempio di un for loop in C:
\begin{lstlisting}[language=C]
  for (int i = 0; i < 10; i++) { // int i; %EDX
    ...
  }
\end{lstlisting}

\noindent La traduzione in assembly è la seguente:
\begin{lstlisting}[language={[x86masm]Assembler}]
  MOVL $0, %EDX
  FOR:
  COMPL $10, %EDX
  JE ENDFOR
  ...
  INC %EDX
  JMP FOR
  ENDFOR:
\end{lstlisting}

\subsection{File assembly}
Un file assembly ha estensione \texttt{.s} e può contenere diverse sezioni:
\begin{itemize}
	\item \textbf{.section .data}: contiene le variabili globali e le costanti
	      \begin{lstlisting}[language={[x86masm]Assembler}]
  .section .data
  hello:
    .ascii "Hello, world!\n" ; Dichiarazione di una stringa costante

  hello_len:
    .long . - hello ; Lunghezza della stringa (posizione corrente (.) - posizione iniziale)
  \end{lstlisting}

	\item \textbf{.section .text}: contiene il codice assembly composto da istruzioni, etichette
	      e sottoprogrammi
	      \begin{lstlisting}[language={[x86masm]Assembler}]
  .section .text
  .global _start ; Nome convenzionale del punto di inizio del programma
  _start:
    movl ...
    ...
  \end{lstlisting}

	\item \textbf{.section .bss}: contiene le variabili globali non inizializzate (spazio da riservare)
\end{itemize}

\subsection{Compilazione}
Per compilare un file assembly si compiono i seguenti passi:
\begin{enumerate}
	\item \textbf{Compilazione}: si compila il file assembly con il comando \texttt{as} che
	      crea un file binario (\texttt{.o}) contenente
	      l'implementazione di ogni singolo file.
	\item \textbf{Linking}: si uniscono i file binari con il comando \texttt{ld} che crea un file eseguibile
	      a partire dai file binari.
	\item \textbf{Esecuzione}: si rende eseguibile il file e si esegue con il comando \\\texttt{./<nomefile>}
\end{enumerate}


\section{Memoria}
La memoria è una lista indicizzata di celle, a cui ognuna è associata un indirizzo.
La memoria è composta da due parti principali:
\begin{itemize}
	\item \textbf{Codice}: contiene le istruzioni
	\item \textbf{Dati statici}: contiene i dati
\end{itemize}

\noindent Non si può sapere a priori dove verrà caricato il programma in memoria, quindi
è necessario utilizzare lo spostamento relativo per accedere ai dati e alle istruzioni.

\begin{figure}[H]
	\centering
	\begin{tikzpicture}
		\draw (0,0) rectangle (2,1);
		\node at (1,0.5) {Codice};

		\draw (0,0) rectangle (2,-2);
		\node at (1,-1) {Istruzioni};

		\draw (0,-2) rectangle (2,-4);
		\node[align=center] at (1,-3) {Dati\\statici};

		\draw[<-] (0,-0.2) -- ++(-0.5,0) node[left] {Program Counter};
	\end{tikzpicture}
	\caption{Struttura della memoria}
\end{figure}

\begin{figure}[H]
	\begin{define}
		\textbf{Footprint}: è l'area di memoria occupata da un programma:
		\begin{itemize}
			\item \textbf{L}: 32 bit
			\item \textbf{V}: 16 bit
			\item \textbf{B}: 8 bit
		\end{itemize}
	\end{define}
\end{figure}

\subsection{Memoria dinamica}
La memoria dinamica è composta da due parti principali:
\begin{itemize}
	\item \textbf{Heap}: contiene le variabili allocate dinamicamente e ha una dimensione variabile
	\item \textbf{Stack}: contiene le variabili locali e i parametri delle funzioni. Ha una dimensione fissa
	      e limitata. Lo stack cresce con la modalità \textbf{LIFO} (Last In First Out), cioè l'ultimo
	      elemento inserito è il primo ad essere estratto e nell'architettura x86 cresce verso l'alto.
	      Lo stack è composta anche da 2 puntatori:
	      \begin{itemize}
		      \item \textbf{ESP} (Extended Stack Pointer): punta all'ultimo elemento inserito nello stack
		      \item \textbf{EBP} (Extended Base Pointer): punta alla base dello stack
	      \end{itemize}
\end{itemize}

\begin{figure}[H]
	\centering
	\begin{tikzpicture}
		\draw (0,0) rectangle (2,1);
		\node[align=center] at (1,0.5) {Dati\\Statici};

		\draw (0,0) rectangle (2,-2);
		\node[align=center] at (1,-1) {Variabili\\dinamiche};

		\draw (0,-2) rectangle (2,-4.1);
		\node at (1,-2.3) {Stack};

		\draw (0,-2.6) -- (2,-2.6) node[midway, below, yshift=-1, scale=0.8] {...};
		\draw (0,-2.9) -- (2,-2.9) node[midway, below, yshift=1, scale=0.8] {b};
		\draw (0,-3.2) -- (2,-3.2) node[midway, below, yshift=1, scale=0.8] {a};
		\draw (0,-3.5) -- (2,-3.5) node[midway, below, yshift=1, scale=0.8] {y};
		\draw (0,-3.8) -- (2,-3.8) node[midway, below, yshift=1, scale=0.8] {x};


		\draw[<-] (0,-3.2) -- ++(-0.5,0) node[left] {ESP};
		\draw[<-] (0,-3.8) -- ++(-0.5,0) node[left] {EBP};
	\end{tikzpicture}
	\caption{Struttura della memoria}
\end{figure}

\noindent Per gestire i dati nello stack si utilizzano le seguenti istruzioni:
\begin{itemize}
	\item \textbf{\texttt{PUSHL <source>}}: inserisce il contenuto di un registro (o costante) nello stack
	\item \textbf{\texttt{POPL <destination>}}: estrae il contenuto dello stack e lo mette in un registro (o costante)
\end{itemize}

\subsection{Richiamare una funzione}
Per richiamare uan funzione bisogna far saltare il Program Counter all'indirizzo della funzione
e poi salvare l'indirizzo successivo nello stack. Per fare ciò si utilizza l'istruzione \texttt{CALL}.
\begin{itemize}
	\item \textbf{\texttt{CALL <etichetta>}}: salva l'indirizzo successivo al Program Counter nello stack e salta all'istruzione con etichetta.
	      Quando la funzione termina, per tornare al punto di chiamata si utilizza l'istruzione \texttt{RET}.
	\item \textbf{\texttt{RET}}: estrae l'indirizzo successivo al Program Counter dallo stack e salta a quell'indirizzo (torna al punto di chiamata).
\end{itemize}

Per recuperare i dati in memoria si utilizza l'istruzione \texttt{LEAL} (Load Effective Address):
\begin{itemize}
	\item \textbf{\texttt{LEAL <source>, <destination>}}: prende l'indirizzo di memoria in cui è stato salvato qualcosa
	      e lo mette in un registro
\end{itemize}

\subsection{Struttura dettagliata della CPU}
Di seguito è riportato uno schema più dettagliato dei componenti della CPU
in modo da capire come vengono eseguite le istruzioni.
\begin{figure}[H]
	\centering
	\begin{tikzpicture}[scale=1.5]
		\draw (-1,-3) rectangle (3.5,5.4);
		\node[above left] at (3.5,-3) {CPU};

		\draw (2,2) rectangle (3,3);
		\node[above left, scale=0.7] at (2.4,2) {CU};
		\draw[latex-latex] (3,2.5) -- (4,2.5);

		\draw[-latex, dashed] (2.2,3) -- ++(0,0.5) node[above, scale=0.7] {$PC_{in}$};
		\draw[-latex, dashed] (2.4,3) -- ++(0,0.5);
		\draw[-latex, dashed] (2.6,3) -- ++(0,0.5);
		\draw[-latex, dashed] (2.8,3) -- ++(0,0.5) node[above, scale=0.7, xshift=8] {$PC_{out}$};

		\node[draw, scale=0.7] at (2.7,2.8) {PSW};

		\node[draw, scale=1] at (2.5,1.5) (ir) {IR};
		\draw[-latex] (ir) -- ++(0,0.5);
		\draw[latex-] (ir) -- ++(-1,0);


		\node[draw, rectangle, align=center, scale=0.8, minimum width=1.3cm, minimum height=0.8cm]
		(pc) at (0.8, 3.85) {PC};
		\draw (pc.west) -- ++(0,0.15) -- ++(0.15, -0.15) -- ++(-0.15,-0.15);

		% Tri state buffer
		\draw (1.2,3.3) circle (0.1) node (tristate-buffer) {};
		\draw (1.2,3.3) circle (0.1) node[below, yshift=-15, align=center, scale=0.5] {Tri-state\\buffer};
		\draw (1.2,3.3) -- ++(0.07,0.07);
		\draw (1.2,3.3) -- ++(-0.07,-0.07);
		\draw (1.2,3.3) -- ++(0.07,-0.07);
		\draw (1.2,3.3) -- ++(-0.07,0.07);
		% ----------------

		\draw[latex-] (tristate-buffer) -- ++(0,-0.3) -- ++(-0.5,0) node[left, scale=0.7]
		{$PC_{out}$};

		% Multiplexer 2 to 1
		\begin{scope}[shift={(0.67,4.5)}, scale=0.5]
			\draw (0,0) node (mux1-0) {1};
			\draw (0.5,0) node (mux1-1) {0};
			\draw (0.0,0.2) node (mux1-i0) {};
			\draw (0.5,0.2) node (mux1-i1) {};
			\draw (-0.3,0) node (mux1-s) {};
			\draw (0.25,-0.18) node (mux1-o) {};
			\draw (-0.5,0.3) -- ++(1.5,0) -- ++(-0.25, -0.6) -- ++(-1,0) -- ++(-0.25,0.6) -- (-0.5,0.3);
		\end{scope}
		\draw[-latex] (mux1-o) -- (pc);

		\draw[-latex] (pc.south) -- ++(0,-0.3) |- (tristate-buffer);
		\draw[-latex] (tristate-buffer) -- ++(0.3,0);
		\draw[-latex] (0.8,3.5) -- ++(0.5,0) -- ++(0,1.4) -| (mux1-i1);
		\draw[latex-] (mux1-i0) -- ++(0,0.5) -- ++(0.83,0);
		\draw[latex-] (mux1-s) -- ++(-0.4,0) node[left, scale=0.7] {$PC_{in}$};

		% ALU
		\begin{scope}[shift={(-2.5,-0.5)}]
			\draw (2.7,0.5) -- (3.3,0.5) -- (3.5,1.5) -- (3.2,1.5) -- (3,1.2) -- (2.8,1.5) -- (2.5,1.5) -- cycle;
			\node[above, scale=0.6] at (3,0.5) {ALU};
		\end{scope}

		% Multiplexer 4 to 1
		\begin{scope}[shift={(0,4.5)}, scale=0.5]
			\draw (-0.7,-6) node (mux4-0) {00};
			\draw (0,-6) node (mux4-1) {01};
			\draw (0.7,-6) node (mux4-2) {10};
			\draw (1.4,-6) node[scale=0.8] () {$\ldots$};
			\draw (1.4,-5.87) node (mux4-3) {};
			\draw (-0.7,-5.8) node (mux4-i0) {};
			\draw (0,-5.8) node (mux4-i1) {};
			\draw (0.7,-5.8) node (mux4-i2) {};
			\draw (1.4,-5.8) node (mux4-i3) {};
			\draw (1.7,-6) node (mux4-s) {};
			\draw (0.25,-6.18) node (mux4-o) {};
			\draw (-1.3,-5.7) -- ++(3.3,0) -- ++(-0.25, -0.6) -- ++(-2.8,0) -- ++(-0.25,0.6) -- cycle;
		\end{scope}

		% Register y
		\begin{scope}[shift={(0.1,3.5)}]
			\draw (0.25,-1) node[rectangle ,draw, minimum width=2cm, minimum height=0.7cm, scale=0.7] (y) {y};
			\draw (y.west) -- ++(0,0.15) -- ++(0.15, -0.15) -- ++(-0.15,-0.15);
		\end{scope}

		\draw[-latex] (y.east) -- ++(0.7,0);

		% Mux to alu
		\draw[latex-] (mux4-0) -- ++(0,0.4) node[above, scale=0.7] {0};
		\draw[latex-] (mux4-1) -- ++(0,0.4) node[above, scale=0.7] {4};
		\draw[latex-] (mux4-2) -- (y);
		\draw[latex-] (mux4-3) -- ++(0,0.34) node[above, scale=0.7] {cost};
		\draw[latex-] (mux4-s) -- ++(0.4,0) node[above, scale=0.7] {select};

		\draw[latex-] (0.15,1) -- ++(0,0.35);
		\draw[latex-] (0.85,1) -- ++(0,0.2) -- ++(0.65,0);

		% Alu in out
		\draw[-latex] (0.5,0) -- ++(0,-0.33);

		\draw[latex-] (0.1,0.4) -- ++(-0.5,0) node[left, align=center, scale=0.5] {ADD\\SUB\\MUL\\CR\\$\ldots$};

		% Register z
		\begin{scope}[shift={(0.25,0.5)}]
			\draw (0.25,-1) node[rectangle ,draw, minimum width=2cm, minimum height=0.7cm, scale=0.7] (z) {z};
			\draw (z.west) -- ++(0,0.15) -- ++(0.15, -0.15) -- ++(-0.15,-0.15);
		\end{scope}

		\draw[-latex] (z.east) -- ++(0.51,0);


		% MAR (Memory Address Register)
		\node[draw, rectangle, align=center, scale=0.8, minimum width=0.5cm, minimum height=0.5cm]
		(mdr) at (0.5, -2) {MDR};
		\draw[latex-latex] (mdr) -- ++(-2.5,0);
		\draw[latex-latex] (mdr) -- ++(1,0);

		% MDR (Memory Data Register)
		\node[draw, rectangle, align=center, scale=0.8, minimum width=0.5cm, minimum height=0.5cm]
		(mar) at (0.5, -1.5) {MAR};
		\draw[latex-latex] (mar) -- ++(-2,0);
		\draw[latex-] (mar) -- ++(1,0);

		% Register file
		\node[draw, scale=1] at (2.5,1.5) (ir) {IR};
		\draw (2, 0.8) rectangle (3, 1);
		\node[scale=0.7] at (2.5,0.9) {EAX};
		\draw (2, 0.6) rectangle (3, 0.8);
		\node[scale=0.7] at (2.5,0.7) {EBX};
		\draw (2, 0.4) rectangle (3, 0.6);
		\node[scale=0.7] at (2.5,0.5) {ECX};
		\draw (2, 0.2) rectangle (3, 0.4);
		\node[scale=0.7] at (2.5,0.3) {EDX};
		\draw (2, 0) rectangle (3, 0.2);
		\node[scale=0.7] at (2.5,0.1) {ESP};
		\draw (2, -0.2) rectangle (3, 0);
		\node[scale=0.7] at (2.5,-0.105) {Reg File};

		\draw[latex-latex] (2,0.4) -- ++(-0.5,0);

		% Bus CPU
		\draw (1.5,-3) -- (1.5,5.4) node[below right, scale=0.7, align=center] {Bus\\CPU};

		% Bus Istruzioni
		\draw (-1.5,-3) -- (-1.5,5.4) node[above, scale=0.7, align=center] {BI};

		% Bus Dati
		\draw (-2,-3) -- (-2,5.4) node[above, scale=0.7, align=center] {BD};

		% Bus di controllo
		\draw (4,-3) -- (4,5.4) node[above, scale=0.7, align=center] {BC};
	\end{tikzpicture}
	\caption{Schema della CPU}
\end{figure}

\noindent Da questo schema si possono notare le seguenti caratteristiche:
\begin{itemize}
	\item Nella gestione del Program Counter il segnale passa attraverso un \textbf{Buffer
		      Tri-State} che permette di disabilitare il segnale.
	\item Per mandare 2 valori alla ALU si utilizza un registro collegato ad un multiplexer
	      che permette di selezionare quale valore mandare alla ALU. Nel multiplexer sono
	      cablate delle costanti utili da passare alla ALU.
	\item Ogni indirizzo di memoria è gestito in \textbf{byte} indipendentemente.
	      Quindi per accedere a parole da 32 bit bisogna andare avanti di 4 byte, mentre
	      per accedere a parole da 64 bit bisogna andare avanti di 8 byte.
\end{itemize}

\section{Micro operazioni}
Le micro operazioni sono le operazioni elementari che la CPU esegue per eseguire
un'istruzione.

\begin{figure}[H]
	\begin{define}
		\textbf{CPI} (Clock Per Instruction): è il numero di cicli di clock necessari per
		eseguire un'istruzione. L'obiettivo è avere un CPI il più basso possibile.
	\end{define}
\end{figure}

\begin{example}
	Andiamo ad analizzare la sequenza di micro operazioni (Fetch, Decode, Execute) per la
	seguente istruzione:
	\begin{center}
		\texttt{MOVL \%EAX, \%EBX}
	\end{center}

	\begin{enumerate}
		\item[F]
		      \begin{enumerate}
			      \item[1.] \( PC_{out},\; MAR_{in},\; READ ,\; SELECT_4,\; ADD,\; Z_{in}\) \\
			            Il Program Counter manda l'indirizzo di memoria in cui si trova l'istruzione da eseguire
			            al Memory Address Register e manda un segnale di lettura.

			            Il segnale di selezione 4 manda un segnale al multiplexer per selezionare il valore
			            da mandare alla ALU e il segnale di addizione manda un segnale alla ALU per sommare
			            4 all'indirizzo di memoria. Ciò vuol dire che l'indirizzo di memoria successivo è
			            l'indirizzo di memoria corrente + 1 word. Tutto ciò per incrementare il Program
			            Counter in modo da accedere all'istruzione successiva.

			      \item[2.] \( WMFC,\; Z_{out},\; PC_{in}\)  \\
			            \textbf{WMFC}(Wait for Memory Fetch Complete): è un segnale che blocca il clock
			            successivo della CPU finchè il dato viene messo nel bus dati.

			            Siccome in questo ciclo di clock il bus non viene utilizzato viene sfruttato per
			            mandare il segnale di incremento al Program Counter.

			            Il segnale di lettura manda un segnale di attesa finchè il dato non viene messo nel bus dati.
			      \item[3.] \( MDR_{out},\; IR_{in} \) \\
			            Il Memory Data Register manda il dato letto dall'indirizzo di memoria all'Instruction Register.
		      \end{enumerate}

		\item[DE]
		      \begin{enumerate}
			      \item[4.] \( EAX_{out},\; EBX_{in},\; END \) \\
			            Il contenuto del registro EAX viene mandato in uscita e viene messo in ingresso
			            al registro EBX. Successivamente viene messo a 1 il segnale di fine che fa
			            ripartire il ciclo di Fetch-Decode-Execute.
		      \end{enumerate}
	\end{enumerate}
\end{example}
\begin{figure}[H]

\end{figure}

\begin{example}
	Istruzione:
	\begin{center}
		\texttt{MOVL (\%EAX), \%EBX}
	\end{center}

	\begin{enumerate}
		\item[F]
		      \begin{enumerate}
			      \item[1.] \( PC_{out},\; MAR_{in},\; READ ,\; SELECT_4,\; ADD,\; Z_{in}\)
			      \item[2.] \( WMFC,\; Z_{out},\; PC_{in}\)
			      \item[3.] \( MDR_{out},\; IR_{in} \)
		      \end{enumerate}
		\item[D]
		      \begin{enumerate}
			      \item[4.] \( EAX_{out},\; MAR_{in},\; READ \)
			      \item[5.] \( WMFC \)
		      \end{enumerate}
		\item[E]
		      \begin{enumerate}
			      \item[6.] \( MDR_{out},\; EBX_{in},\; END \)
		      \end{enumerate}
	\end{enumerate}
\end{example}

\begin{example}
	Istruzione:
	\begin{center}
		\texttt{ADDL \$4, \%ECX}
	\end{center}

	\noindent La costante 4 è già presente nell'Instruction Register, quindi non c'è bisogno di
	andare a leggerla dalla memoria.
	\begin{enumerate}
		\item[F]
		      \begin{enumerate}
			      \item[1.] \( PC_{out},\; MAR_{in},\; READ ,\; SELECT_4,\; ADD,\; Z_{in}\)
			      \item[2.] \( WMFC,\; Z_{out},\; PC_{in}\)
			      \item[3.] \( MDR_{out},\; IR_{in} \)
		      \end{enumerate}
		\item[DE]
		      \begin{enumerate}
			      \item[4.] \( OFFSET_{IR_{out}},\; y_{in} \) \\
			            L'offset dell'Instruction Register serve per prendere il pezzo in cui è situata
			            la costante 4
			      \item[5.] \( ECX_{out},\; SELECT_{y},\;ADD,\; Z_{in} \)
			      \item[6.] \( Z_{out},\; ECX_{in},\; END \)
		      \end{enumerate}
	\end{enumerate}
\end{example}

\begin{example}
	\begin{center}
		\texttt{JZ END} \quad (salto relativo)
	\end{center}

	\noindent Il valore dell'etichetta \texttt{END} è già calcolato dall'assembler e viene memorizzato
	nell'Instruction Register
	\begin{enumerate}
		\item [F]
		      \begin{enumerate}
			      \item[1.] \( PC_{out},\; MAR_{in},\; READ ,\; SELECT_4,\; ADD,\; Z_{in}\)
			      \item[2.] \( WMFC,\; Z_{out},\; PC_{in}\)
			      \item[3.] \( MDR_{out},\; IR_{in} \)
		      \end{enumerate}
		\item[DE]
		      \begin{enumerate}
			      \item[4.] (if ZERO == 0 END) \(,\; OFFSET_{IR_{out}},\; y_{in} \)\\
			            L'if e il resto vengono eseguiti insieme, sempre
			      \item[5.] \( PC_{out},\; SELECT_{y},\; ADD,\; Z_{in} \)
			      \item[6.] \( Z_{out},\; PC_{in},\; END \)
		      \end{enumerate}
	\end{enumerate}
\end{example}

\subsection{Struttura della Control Unit}
\noindent Per rappresentare i cicli di clock delle micro istruzioni si utilizza un
registro chiamato \textbf{Micro Program Counter} che indica la prossima micro istruzione
da eseguire. È un contatore con un segnale di reset che permette di far ripartire
l'esecuzione delle micro istruzioni. Questo registro viene poi collegato ad un decoder con 16 uscite che indica il tempo
del ciclo di clock. Se il segnale \( T_2 = 1 \) allora il segnale \( PC_{in} = 1 \),
quindi \( PC_{in} = T_2 \). È presente poi un decoder che parte dall'Istruction Register e ha in uscita tutte le istruzioni
\( I_n \). Si possono così realizzare tutte le equazioni in logica combinatoria, ad esempio:
\[
	END = (I_1 + I_2 + I_3 + \ldots) \cdot T_6 + I_3 \cdot T_4 \cdot \overline{ZERO}
\]
\begin{figure}[H]
	\centering
	\begin{tikzpicture}
		\draw (0,0) rectangle (4,4);
		\node[align=center] (logica-combinatoria) at (2,2) {Logica\\combinatoria};
		\draw[-latex] (0.3,0) -- ++(0,-0.5) node[below, scale=0.7] {$PC_{in}$};
		\draw[-latex] (1.15,0) -- ++(0,-0.5) node[below, scale=0.7] {$PC_{out}$};
		\draw[-latex] (2,0) -- ++(0,-0.5) node[below, xshift=2, scale=0.7] {$MAR_{in}$};
		\draw[-latex] (2.85,0) -- ++(0,-0.5) node[below, yshift=-3, scale=0.7] {$\ldots$};
		\draw[-latex] (3.7,0) -- ++(0,-0.5) node[below, scale=0.7] {$END$} --
		++(2,0) -- ++(0,5) |- (3,5.75);


		\draw (-1,0) rectangle (-0.5,4);
		\node[label={[label distance=0cm,text depth=-1ex,rotate=-90]right:Decoder}]
		at (-0.85,2.6) {};
		\draw[-latex] (-0.5,3.6) -- (0,3.6) node[midway, above, scale=0.7] {$I_1$};
		\draw[-latex] (-0.5,3.2) -- (0,3.2) node[midway, above, scale=0.7] {$I_2$};
		\draw[-latex] (-0.5,2.8) -- (0,2.8) node[midway, above, scale=0.7] {$I_3$};
		\draw[-latex] (-0.5,2.4) -- (0,2.4);
		\draw[-latex] (-0.5,2) -- (0,2);
		\draw[-latex] (-0.5,1.6) -- (0,1.6);
		\draw[-latex] (-0.5,1.2) -- (0,1.2);
		\draw[-latex] (-0.5,0.8) -- (0,0.8);
		\draw[-latex] (-0.5,0.4) -- (0,0.4) node[midway, above, scale=0.7] {$I_{16}$};

		\draw (-2,0) rectangle (-1.5,4);
		\node[label={[label distance=0cm,text depth=-1ex,rotate=-90]right:IR}]
		at (-1.86,2.3) {};
		\draw[-latex] (-1.5,2) -- (-1,2);

		\draw (4.5,0) rectangle (5,4);
		\node[label={[label distance=0cm,text depth=-1ex,rotate=90]right:PSW}]
		at (4.65,1.5) {};
		\draw[latex-] (4,2) -- (4.5,2);

		\draw (0.5, 4.5) rectangle (3.5, 5);
		\node[align=center] at (2,4.75) {Decoder};
		\draw[latex-] (1,4) -- (1,4.5) node[midway, left, scale=0.7] {$T_1$};
		\draw[latex-] (1.5,4) -- (1.5,4.5) node[midway, left, scale=0.7] {$T_2$};
		\draw[latex-] (2,4) -- (2,4.5) node[midway, left, scale=0.7] {$T_3$};
		\node[align=center, scale=0.6] at (2.3,4.25) {$\ldots$};
		\draw[latex-] (3,4) -- (3,4.5) node[midway, left, scale=0.7] {$T_{16}$};

		\draw (1, 5.5) rectangle (3, 6);
		\node at (2,5.75) (mpc) {MPC};
		\draw (1,5.9) -- ++(0.15, -0.15) -- ++(-0.15,-0.15);
		\draw[latex-] (1,5.75) -- ++(-0.5,0) node[left, scale=0.7] {CLK};
		\draw[-latex] (2,5.5) -- (2,5);
		\draw (1.9,5.23) -- ++(0.2,0.2) node[right, yshift=-3, scale=0.7] {4};
	\end{tikzpicture}
\end{figure}

\noindent Esiste una memoria che contiene tutte le micro istruzioni chiamata \textbf{Firmware},
ma \textbf{CPU cablate} in questo modo non si realizzano più.

\section{Dispositivi di input e output}
\begin{figure}[H]
	\centering
	\begin{tikzpicture}
		% CPU
		\node[draw, rectangle, minimum width=2cm, minimum height=1.5cm] (cpu) at (0, 0) {\textbf{CPU}};
		% Memoria
		\node[draw, rectangle, align=center, minimum width=2cm, minimum height=1.5cm] (memory) at (4, 0) {\textbf{Memoria}\\\footnotesize Dati\\\footnotesize Istruzioni};

		% Bus
		\draw (-2,-2) -- (6.5,-2) node[right] {Bus};
		\draw[<->] (cpu) -- ++(0,-2);
		\draw[<->] (memory) -- ++(0,-2);

		% Input/Output below bus
		\node[draw, rectangle, minimum width=0.7cm, minimum height=0.7cm] (io) at (2, -3) {\textbf{I/O}};
		\draw[<->] (io) -- (2,-2);

		% Keyboard and mouse below I/O
		\node (keyboard) at (1, -4) {Tastiera};
		\node (mouse) at (3, -4) {Mouse};
		\draw[->] (keyboard) -- (io);
		\draw[->] (mouse) -- (io);
	\end{tikzpicture}
  \caption{Schema di un sistema con dispositivi di input e output}
\end{figure}

\noindent Per poter ottenere un'interazione con l'utente è necessario avere dei dispositivi
di input e output e a loro volta devono essere codificati per far corrispondere 
l'intenzione dell'utente con l'azione del computer. La strutture del microcontrollore
input/output è composto da:
\begin{itemize}
  \item \textbf{Dato}: contiene i dati da inviare o ricevere
  \item \textbf{Stato}: contiene lo stato del dispositivo
  \item \textbf{MC}: contiene il microcontrollore del dispositivo
  \item \textbf{IntA/D}: contiene l'interfaccia di analogico/digitale
\end{itemize}
\begin{figure}[H]
  \centering
  \begin{tikzpicture}
    \draw (0,0) rectangle (4,4);
    \draw (0.5,2.5) rectangle (1.8,3.5) node[midway] {Dato};
    \draw (2.2,2.5) rectangle (3.5,3.5) node[midway] {Stato};
    \draw (1.5,1) rectangle (2.5,2) node[midway] {MC};
    \draw (0,0) rectangle (1,1) node[midway, scale=0.7] {IntA/D};
    \node at (4,0) [above left, scale=0.7] {I/O};
  \end{tikzpicture}
  \caption{Struttura del microcontrollore input/output}
\end{figure}

\noindent La CPU accede ai valori dei registri di input/outpit tramite degli indirizzi
che vengono riservati in un intervallo di memoria. Gli indirizzi di \texttt{Dato} e
\texttt{Stato} sono:
\begin{itemize}
  \item \texttt{IND DATA KEY} (Dato)
  \item \texttt{IND STATUS KEY} (Stato)
\end{itemize}
Questi indirizzi sono assegnati in fase di progettazione del sistema e sono fissi,
ma si possono anche cambiare in certe architetture.

\vspace{1em}
\noindent Ogni bit nel registro \texttt{status} ha un preciso significato, ad esempio
se vale 0 significa che nessun tasto è stato premuto, se vale 1 significa che un tasto
è stato premuto.

\vspace{1em}
\noindent Un esempio in assembly è il seguente:
\begin{lstlisting}[language={[x86masm]Assembler}]
 TEST_KEY:
  MOVL IND_STATUS_KEY, %EAX ; Carica lo stato della tastiera nel registro EAX
  CMPL $0, %EAX ; Compara il valore di EAX con 0
  JE TEST_KEY ; Se EAX = 0 allora salta a TEST_KEY
  MOV IND_DATA_KEY, %EBX ; Carica il tasto premuto nel registro EBX
  MOV %EBX, INDC ; Carica il tasto premuto nel registro C
\end{lstlisting}
\noindent La verifica di un dispositivo di input/output è un'operazione che viene detta
\textbf{polling}.

\vspace{1em}
\noindent Ogni volta che si vuole leggere un dato da un dispositivo di input/output si deve
effettuare una \textbf{SVC} (Supervisor Call) che permette di richiamare del pezzo
di codice al livello del sistema operativo che permette di effettuare diverse operazioni.

\subsection{Ottimizzazione}
Ogni operazione di lettura effettuata con il bus richiede circa 10 cicli di clock.
\begin{lstlisting}[language={[x86masm]Assembler}]
 TEST_KEY:
  MOVL IND_STATUS_KEY, %EAX ; 1 Read 1 Read Bus
  CMPL $0, %EAX ; 1 Read
  JE TEST_KEY ; 1 Read
  MOV IND_DATA_KEY, %EBX 
  MOV %EBX, INDC 
\end{lstlisting}
\noindent In totale si avranno \( 10 + 3 \) cicli di clock \( \approx 10 \). Con una
frequenza di \( 10GHz \) si avranno \( 10^9 clock/sec \). Visto che un umano può premere
un tasto al massimo 10 volte al secondo, si può dire che la frequenza di lettura è
troppo alta, quindi si sprecano cicli di clock e non può essere gestito in polling.

\subsection{Interrupt}
Al posto di fare polling, cioè la CPU che controlla continuamente lo stato del dispositivo,
si può utilizzare un \textbf{interrupt} che è un segnale hardware che interrompe il normale
flusso di esecuzione del programma solo quando il dispositivo è pronto. La CPU
\textbf{prima di ogni fetch} controlla se c'è qualche richiesta di interrupt.
\begin{figure}[H]
  \centering
  \begin{tikzpicture}
    \draw (0,0) rectangle (2,2) node[midway] {CPU};
    \draw[latex-] (2,1.5) -- ++(4,0) node[right, scale=0.7] {BC};
    \draw[-latex] (2,1) -- ++(4,0) node[right, scale=0.7] {BD};
    \draw[-latex] (2,0.5) -- ++(4,0) node[right, scale=0.7] {BI};

    \node[draw, rectangle, minimum width=0.5cm, minimum height=0.5cm] 
      (io1) at (2.8,-1) {I/O};
    \node[draw, rectangle, minimum width=0.5cm, minimum height=0.5cm]
      (io2) at (4.5,-1) {I/O};
    \node at (5.5,-1) {$\ldots$};

    \draw[-latex] (io1) -- (2.8,1.5);
    \draw[-latex] (io2) -- (4.5,1.5);
    \draw[-latex] (io1) -- (io2);

    \draw[-latex] (1,0) -- ++(0,-1) node[below, scale=0.7] {INTACK} |- (io1);
  \end{tikzpicture}
\end{figure}

\noindent Esiste un bit \( \overline{INTERRUPT} \) che è sempre a 1 (negato a 0) che
vale 1 solo quando c'è una \textbf{interrupt request}. Ogni interrupt ha un valore
che contiene un pezzo di codice chiamato \textbf{Interrupt Service Routine (ISR)} 
che viene passato alla CPU attraverso il \texttt{INTACK} (Interrupt Acknowledge). 
Le ISR sono gestite dal sistema operativo e tutto l'insieme viene chiamato \textbf{Device Driver}.
Ogni dispositivo input/output ha interrupt con valori diversi.

\vspace{1em}
\noindent Siccome l'esecuzione di un interrupt può modificare i registri della CPU può esserci
qualche conflitto con dei programmi già in esecuzione, quindi c'è bisogno di un meccanismo
per eseguire l'ISR senza che vengano modificati i registri della CPU. Questo viene
effettuato dal dispositivo input/output che salva il valore dei registri \texttt{PSW} e
\texttt{PC} ed eventuali altri registri salvaldoli nello stack prima di eseguire l'ISR.

% Laboratorio
\section{Laboratorio}
\subsection{Vantaggi e svantaggi di assembly}
\subsubsection{Vantaggi}
Siccome assembly è un linguaggio di basso livello, è molto vicino all'hardware e quindi è possibile:
\begin{itemize}
	\item accedere direttamente ai \textbf{registri} della CPU
	\item scrivere \textbf{codice ottimizzato} per una specifica architettura di CPU
	\item ottimizzare le \textbf{sezioni "critiche"} dei programmi
\end{itemize}

\subsubsection{Svantaggi}
I principali svantaggi sono:
\begin{itemize}
	\item possono essere richieste \textbf{molte più righe} di codice
	\item è facile introdurre dei \textbf{bug} perchè la programmazione è più complessa
	\item il \textbf{debugging} è complesso
	\item \textbf{non è garantita la compatibilità} del codice per altri hardware
\end{itemize}

\subsection{Utilità}
Assembly permette di gestire direttamente il funzionamento della CPU, di conseguenza,
i programmi Assembly, una volta compilati sono tipicamente più veloci e più piccoli dei
programmi scritti in linguaggi di alto livello. Per questo motivo, l'assembly è utilizzato
per scrivere codice che deve essere il più veloce possibile, come ad esempio i driver di
hardware specifici.

\subsection{Registri}
Tutti i processori della famiglia x86 hanno i seguenti registri:
AX, BX, CX, DX, CS, DS, ES, SS, SP, BP, SI, DI, IP, FLAGS.

\vspace{1em}
\noindent Originariamente i registri AX, BX, CX, DX, SP, BP, SI, DI, IP e FLAGS avevano una dimensione
di 16 bit. A partire dal 80386, la loro dimensione è stata estesa a 32 bit e al loro nome
è stato aggiunto il prefisso E (Extended). Per ragioni di retrocompatibilità, i registri
di 16 bit possono essere utilizzati anche nei processori a 32 bit utilizzando il loro
nome originale.

\subsubsection{Registri general purpose}
I seguenti registri sono generici, pertanto è possibile assegnargli qualunque valore. Tuttavia,
durante l'esecuzione di alcune istruzioni i registri generici vengono utilizzati per
memorizzare valori ben determinati:
\begin{itemize}
	\item \textbf{EAX} (Accumulator register): è usato come accumulatore per
	      operazioni aritmetiche e contiene il risultato dell'operazione
	\item \textbf{EBX} (Base register): è usato per operazioni di indirizzamento della
	      memoria
	\item \textbf{ECX} (Counter register):  è usato per "contare", ad esempio nelle
	      operazioni di loop
	\item \textbf{EDX} (Data register): è usato nelle operazioni di input/output, nelle
	      divisioni e nelle moltiplicazioni

\end{itemize}

\subsubsection{Registri di segmento}
CS, DS, ES e SS sono i \textbf{registri di segmento} (segment registers) e devono
essere utilizzati con cautela:
\begin{itemize}
	\item \textbf{CS} (Code Segment): punta alla zona di memoria che contiene il codice.
	      Durante l'esecuzione del programma, assieme al registro IP, serve per
	      accedere alla prossima istruzione da eseguire (attenzione: non può
	      essere modificato!)
	\item \textbf{DS} (Data Segment): punta alla zona di memoria che contiene i dati
	\item \textbf{ES} (Extra Segment):  può essere usato come registro di segmento
	      ausiliario
	\item \textbf{SS} (Stack Segment): punta alla zona di memoria in cui risiede lo stack
\end{itemize}

\subsubsection{Registri puntatore}
ESP, EBP, EIP sono i registri puntatore (pointer registers):
\begin{itemize}
	\item \textbf{ESP} (Stack Pointer):  punta alla cima dello stack. Viene modificato
	      dalle operazioni di PUSH (inserimento di un dato nello stack) e POP
	      (estrazioni di un dato dallo stack). Si ricordi che lo stack è una
	      struttura di tipo LIFO (Last In First Out - l'ultimo che entra è il primo
	      che esce). È possibile modificarlo manualmente ma occorre cautela!
	\item \textbf{EBP} (Base Pointer): punta alla base della porzione di stack gestita in
	      quel punto del codice. È possibile modificarlo manualmente ma
	      occorre cautela!
	\item \textbf{EIP} (Instruction Pointer): punta alla prossima istruzione da eseguire.
	      Non può essere modificato!
\end{itemize}

\subsubsection{Registri indice}
ESI e EDI sono i registri indice (index registers) e vengono utilizzati per
operazioni con stringhe e vettori:
\begin{itemize}
	\item \textbf{ESI} (Source Index):  punta alla stringa/vettore sorgente
	\item \textbf{EDI} (Destination Index): punta alla stringa/vettore destinazione
	\item \textbf{EFLAGS}: è utilizzato per memorizzare lo stato corrente del processore.
	      Ciascuna flag (bit) del registro fornisce una particolare informazione.
	      Ad esempio, la flag in prima posizione (carry flag) viene posta a 1
	      quando c;è stato un riporto o un prestito durante un'operazione
	      aritmetica; la flag in seconda posizione (parity flag) viene usata come
	      bit di parità e viene posta a 1 quando il risultato dell'ultima
	      operazione ha un numero pari di 1
\end{itemize}

\subsubsection{Composizione dei registri}
I registri sono composti da 32 bit e possono essere divisi in registri più piccoli:
\begin{itemize}
	\item \textbf{EAX}: AX, AH, AL
	\item \textbf{EBX}: BX, BH, BL
	\item \textbf{ECX}: CX, CH, CL
	\item \textbf{EDX}: DX, DH, DL
	\item \textbf{ESP}: SP
	\item \textbf{EBP}: BP
	\item \textbf{ESI}: SI
	\item \textbf{EDI}: DI
\end{itemize}

\subsubsection{Composizione del registro EFLAGS}
Il registro EFLAGS è composto da 32 bit e ogni bit corrisponde ad un flag:
\begin{itemize}
	\item \textbf{ZF} (Zero flag):  impostato a 1 se il risultato dell'operazione è 0
	\item \textbf{SF} (Sign flag): impostato a 1 se il risultato dell'operazione è un
	      numero negativo, a 0 se è positivo (rappresentazione in complemento
	      a 2)
	\item \textbf{OF} (Overflow flag): impostato a 1 nel caso di overflow di
	      un'operazione
	\item \textbf{TF} (Trap flag): impostato a 1 genera un'interruzione ad ogni
	      istruzione. Utilizzato per l'esecuzione passo-passo dei programmi
	\item \textbf{IF} (Interrupt flag): impostato a 1 abilita gli interrupt esterni, con 0 li
	      disabilita
	\item \textbf{DF} (Direction flag): impostato a 1 indica che nelle operazioni di
	      spostamento di stringhe i registri DI e SI si autodecrementano (con 0
	      tali registri si auto incrementano)
\end{itemize}

\subsection{Modalità di indirizzamento}
Si rifersce al modo in cui un'istruzione assembly accede ai dati in memoria e può essere:
\begin{itemize}
	\item \textbf{Indirizzamento a registro}: l'operando è contenuto in un registro ed
	      il nome del registro è specificato nell'istruzione. Ad esempio:
	      \begin{center}
		      \texttt{\%Ri}
	      \end{center}

	\item \textbf{Indirizzamento diretto} (o assoluto): l'operando è contenuto in una
	      locazione di memoria, e l'indirizzo della locazione viene specificato
	      nell'istruzione. Ad esempio:
	      \begin{center}
		      \texttt{(IND)}
	      \end{center}

	\item \textbf{Indirizzamento immediato} (o di costante): l'operando è un valore
	      costante ed è definito esplicitamente nell'istruzione. Ad esempio:
	      \begin{center}
		      \texttt{\$VAL}
	      \end{center}

	\item \textbf{Indirizzamento indiretto}: l'indirizzo di un operando è contenuto in
	      un registro o in una locazione di memoria. L'indirizzo della locazione o
	      il registro viene specificato nell'istruzione. Ad esempio:
	      \begin{center}
		      \texttt{(\%Ri)} \quad o \quad \texttt{(\$VAL)}
	      \end{center}

	\item \textbf{Indirizzamento indicizzato} (Base e spiazzamento): l'indirizzo
	      effettivo dell'operando è calcolato sommando un valore costante al
	      contenuto di un registro. Ad esempio:
	      \begin{center}
		      \texttt{SPI(\%Ri)}
	      \end{center}

	\item \textbf{Indirizzamento con autoincremento}: l'indirizzo effettivo
	      dell'operando è il contenuto di un registro specificato nell'istruzione.
	      Dopo l'accesso, il contenuto del registro viene incrementato per
	      puntare all'elemento successivo

	\item \textbf{Indirizzamento con autodecremento}: il contenuto di un registro
	      specificato nell'istruzione viene decrementato. Il nuovo contenuto
	      viene usato come indirizzo effettivo dell'operando

\end{itemize}

\subsection{Istruzioni}
\subsubsection{Istruzioni di inizializzazione}
\begin{itemize}
	\item \texttt{mov src, dst} \quad \textbf{Move}: consente l'inizializzazione di un registro o di
	      un'area di memoria. Accetta i modificatori \texttt{l}, \texttt{w} e \texttt{b} per
	      indicare la dimensione dell'operando \texttt{s rc}
	\item \texttt{lea src, dst} \quad \textbf{Load Effective Address}: trasferisce l'indirizzo
	      effettivo dell'operando \texttt{src} nel registro \texttt{dst}
\end{itemize}

\subsubsection{Istruzioni aritmetiche e logiche}
\begin{itemize}
	\item \texttt{sar op1, op2} \quad \textbf{Shift Arithmetic Right}: esegue lo shift a destra sul
	      registro \texttt{op2} di tanti bit quanti specificati in \texttt{op1}. Il bit
	      più significativo viene replicato (così da funzionare anche
	      con numeri negativi in complemento 2) e il bit scartato
	      viene messo nel \textbf{Carry Flag}. \texttt{op1} può essere un registro
	      o un valore immediato, \texttt{op2} deve essere un registro
	\item \texttt{sal op1, op2} \quad \textbf{Shift Arithmetic Left}: esegue lo shift a sinistra sul
	      registro \texttt{op2} di tanti bit quanti specificati in \texttt{op1}. Il bit
	      meno significativo viene messo a \( 0 \)  e il bit scartato viene
	      messo nel \textbf{Carry Flag}. \texttt{op1} può essere un registro o un
	      valore immediato, \texttt{op2} deve essere un registro
	\item \texttt{inc op} \quad \textbf{Increment}: incrementa di 1 il valore memorizzato in
	      \texttt{op}. \texttt{op} può essere un registro o una locazione di memoria
	\item \texttt{dec op} \quad \textbf{Decrement}: decrementa di 1 il valore memorizzato in
	      \texttt{op}. \texttt{op} può essere un registro o una locazione di
	      memoria
	\item \texttt{add src, dst} \quad \textbf{Add}: somma a \texttt{dst} il valore di \texttt{src}
	      e memorizza il risultato in \texttt{dst}
	\item \texttt{sub src, dst} \quad \textbf{Subtract}: sottrae da \texttt{dst} il valore di \texttt{src}
	      e memorizza il risultato in \texttt{dst}
	\item \texttt{mul moltipl} \quad \textbf{Unsigned Multiplication}: esegue la moltiplicazione
	      senza segno. \texttt{moltipl} deve essere un registro o una
	      variabile. Se \texttt{moltipl} è un byte il registro \texttt{AL} viene
	      moltiplicato per l'operando e il risultato viene
	      memorizzato in \texttt{AX}. Se \texttt{moltipl} è una word il
	      contenuto del registro \texttt{AX} viene moltiplicato per
	      l'operando e il risultato viene memorizzato nella coppia
	      di registri \texttt{DX}:\texttt{AX} (\texttt{DX} conterrà i 16 bit più significativi
	      del risultato). Se \texttt{moltipl} è un long il contenuto del
	      registro E\texttt{AX} viene moltiplicato per l'operando e il
	      risultato viene memorizzato nella coppia di registri
	      \texttt{EDX}:\texttt{EAX} (\texttt{EDX} conterrà i 32 bit più significativi del
	      risultato).
	\item \texttt{imul moltipl} \quad moltiplicazione con segno
	\item \texttt{div divisore} \quad \textbf{Unsigned Division}:
	      esegue la divisione senza segno.
	      \texttt{divisore} deve essere un registro o una variabile. Se
	      \texttt{divisore} è un byte il registro \texttt{AX} viene diviso per
	      l'operando, il quoziente viene memorizzato in \texttt{AL}, e il
	      resto in \texttt{AH}. Se \texttt{divisore} è una word, il valore ottenuto
	      concatenando il contenuto di \texttt{DX} e \texttt{AX} viene diviso per
	      l'operando (i 16 bit più significativi del dividendo
	      devono essere memorizzati nel registro \texttt{DX}), il quoziente
	      viene memorizzato nel registro \texttt{AX} e il resto in \texttt{DX}. Se
	      \texttt{divisore} è un long, il valore ottenuto concatenando il
	      contenuto di \texttt{EDX} e \texttt{EAX} viene diviso per l'operando (i
	      32 bit più significativi del dividendo sono nel registro
	      \texttt{EDX}), il quoziente viene memorizzato nel registro \texttt{EAX}
	      e il resto in \texttt{EDX}
	\item \texttt{xor src, dst} \quad \textbf{Logical Exclusive OR}: calcola l'OR esclusivo bit a bit
	      dei due operandi e lo memorizza nell'operando \texttt{dst}.
	      Spesso si utilizza per azzerare un registro, utilizzandolo
	      sia come \texttt{src} che come \texttt{dst})
	\item \texttt{or src, dst} \quad \textbf{Logical OR}: calcola l'OR logico bit a bit dei due
	      operandi e lo memorizza nell'operando \texttt{dst}
	\item \texttt{and src, dst} \quad \textbf{Logical AND}: calcola l'AND bit a bit dei due operandi
	      e lo memorizza nell'operando \texttt{dst}
	\item \texttt{not op} \quad \textbf{Logical NOT}: inverte ogni singolo bit dell'operando op
\end{itemize}

\subsection{AT\&T vs Intel}
Le principali differenze tra la sintassi AT\&T e Intel sono:
\begin{itemize}
	\item In AT\&T i nomi dei registri hanno il carattere \texttt{\%} come prefisso
	\item In AT\&T l'ordine degli operandi è \texttt{<sorgente>, <destinazione>}, opposto
	      rispetto alla sintassi Intel
	\item In AT\&T la lunghezza dell'operando è specificata tramite un suffisso al nome
	      dell'istruzione. \texttt{b} per \textbf{byte} (8 bit), \texttt{w} per \textbf{word} (16 bit),
	      \texttt{l} per \textbf{double word} (32 bit)
	\item Gli operandi immediati in AT\&T sono preceduti dal simbolo \texttt{\$}
	\item la presenza di prefisso in un operando indica che si tratta di un
	      indirizzo di memoria. Ad esempio:
	      \begin{center}
		      \texttt{movl \$pippo, \%eax} \quad è diverso da \quad \texttt{movl pippo, \%eax}
	      \end{center}
	\item l'indicizzazione o l'indirezione è ottenuta racchiudendo tra parentesi
	      l'indirizzo di base espresso tramite un registro o un valore immediato.
	      Ad esempio:
	      \begin{center}
		      \texttt{movl 5, 17(\%ebp)}
	      \end{center}
\end{itemize}

\subsection{Compilazione}
Prima di tutto bisogna creare un file con estensione \texttt{.s} e scrivere il codice assembly.
Dopo aver scritto il codice assembly, si compila il file con il comando \texttt{as} che crea un file binario
(\texttt{.o}) contenente l'implementazione di ogni singolo file. Infine si uniscono i file binari con il comando
\texttt{ld} che crea un file eseguibile a partire dai file binari.

\begin{lstlisting}[language=bash]
 $  as -o <nomefile>.o <nomefile>.s
 $  ld -o <nomefile> <nomefile>.o
 $  ./<nomefile>
  
\end{lstlisting}

% Fine laboratorio
\end{document}
