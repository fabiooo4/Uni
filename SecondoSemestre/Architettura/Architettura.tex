\documentclass[a4paper]{article}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{textcomp}
\usepackage[italian]{babel}
\usepackage{amsmath, amssymb}
\usepackage{amsfonts}
\usepackage{mdframed}
\usepackage{float}
\usepackage{xcolor}
\usepackage{listings}
\usepackage{graphicx}
\usepackage{tikz}
\usetikzlibrary{shapes, arrows, automata, petri, positioning, calc}
\usepackage{circuitikz}
\usepackage[label=corner]{karnaugh-map}
\graphicspath{{./figures/}}

\usepackage{ntheorem}
\newtheorem{theorem}{Teorema}

\usepackage{import}
\usepackage{pdfpages}
\usepackage{transparent}
\usepackage{xcolor}

\usepackage{hyperref}
\hypersetup{
    colorlinks=false,
}

% Code blocks
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.95}

\lstdefinestyle{mystyle}{
	backgroundcolor=\color{backcolour},
	commentstyle=\color{codegreen},
	keywordstyle=\color{magenta},
	numberstyle=\tiny\color{codegray},
	stringstyle=\color{codepurple},
	basicstyle=\ttfamily\footnotesize,
	breakatwhitespace=false,
	breaklines=true,
	captionpos=b,
	keepspaces=true,
	numbers=left,
	numbersep=5pt,
	showspaces=false,
	showstringspaces=false,
	showtabs=false,
	tabsize=2
}

\lstset{style=mystyle}

\usepackage{color}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=tb,
	aboveskip=3mm,
	belowskip=3mm,
	showstringspaces=false,
	columns=flexible,
	basicstyle={\small\ttfamily},
	numbers=none,
	numberstyle=\tiny\color{gray},
	keywordstyle=\color{blue},
	commentstyle=\color{dkgreen},
	stringstyle=\color{mauve},
	breaklines=true,
	breakatwhitespace=true,
	tabsize=3
}

\usepackage{import}
\usepackage{pdfpages}
\usepackage{transparent}
\usepackage{xcolor}



% Useful definitions frame
\theoremstyle{break}
\theoremheaderfont{\bfseries}
\newmdtheoremenv[%
	linecolor=gray,leftmargin=0,%
	rightmargin=0,
	innertopmargin=8pt,%
	innerbottommargin=8pt,
	ntheorem]{define}{Definizioni utili}[section]

% Example frame
\theoremstyle{break}
\theoremheaderfont{\bfseries}
\newmdtheoremenv[%
	linecolor=gray,leftmargin=0,%
	rightmargin=0,
	innertopmargin=8pt,%
	innerbottommargin=8pt,
	ntheorem]{example}{Esempio}[section]

% Important definition frame
\theoremstyle{break}
\theoremheaderfont{\bfseries}
\newmdtheoremenv[%
	linecolor=gray,leftmargin=0,%
	rightmargin=0,
	backgroundcolor=gray!40,%
	innertopmargin=8pt,%
	innerbottommargin=8pt,
	ntheorem]{definition}{Definizione}[section]

% Exercise frame
\theoremstyle{break}
\theoremheaderfont{\bfseries}
\newmdtheoremenv[%
	linecolor=gray,leftmargin=0,%
	rightmargin=0,
	innertopmargin=8pt,%
	innerbottommargin=8pt,
	ntheorem]{exercise}{Esercizio}[section]

% figure support
\usepackage{import}
\usepackage{xifthen}
\pdfminorversion=7
\usepackage{pdfpages}
\usepackage{transparent}
\newcommand{\incfig}[1]{%
	\def\svgwidth{\columnwidth}
	\import{./figures/}{#1.pdf_tex}
}

% FSM tikz
\tikzset{
    place/.style={
        circle,
        thick,
        draw=black,
        minimum size=6mm,
    },
        state/.style={
        circle,
        thick,
        draw=blue!75,
        fill=blue!20,
        minimum size=6mm,
    },
}

\pdfsuppresswarningpagegroup=1

\begin{document}
\input{title.tex}

\tableofcontents
\pagebreak

\section{Architettura di Von Neumann}
L'esigenza era quella di avere un'architettura che permettesse di eseguire programmi
in modo automatico, senza dover cambiare il cablaggio del calcolatore, quindi il circuito
deve essere abbastanza generale per poter eseguire programmi diversi.

\subsection{Struttura}
L'architettura di Von Neumann è composta da 5 parti principali:
\begin{itemize}
	\item \textbf{Unità aritmetico-logica}: si occupa di eseguire le operazioni aritmetiche e logiche
	\item \textbf{Unità di controllo}: si occupa di controllare il flusso delle istruzioni
	\item \textbf{Memoria}: contiene i dati e le istruzioni
	\item \textbf{Input/Output}: permette di comunicare con l'esterno
	\item \textbf{Bus}: permette di trasferire i dati tra la memoria e l'unità aritmetico-logica (generalmente in oro)
\end{itemize}

\begin{figure}[H]
	\centering
	\begin{tikzpicture}
		% CPU
		\node[draw, rectangle, minimum width=2cm, minimum height=1.5cm] (cpu) at (0, 0) {\textbf{CPU}};
		% Memoria
		\node[draw, rectangle, align=center, minimum width=2cm, minimum height=1.5cm] (memory) at (4, 0) {\textbf{Memoria}\\\footnotesize Dati\\\footnotesize Istruzioni};

		% Bus
		\draw (-2,-2) -- (6.5,-2) node[right] {Bus};
		\draw[<->] (cpu) -- ++(0,-2);
		\draw[<->] (memory) -- ++(0,-2);

		% Input/Output below bus
		\node[draw, rectangle, minimum width=0.7cm, minimum height=0.7cm] (io) at (2, -3) {\textbf{I/O}};
		\draw[<->] (io) -- (2,-2);

		% Keyboard and mouse below I/O
		\node (keyboard) at (1, -4) {Tastiera};
		\node (mouse) at (3, -4) {Mouse};
		\draw[->] (keyboard) -- (io);
		\draw[->] (mouse) -- (io);


	\end{tikzpicture}
\end{figure}

\subsection{Caratteristiche}
Le istruzioni hanno bisogno di un'operazione che permetta di effettuare dei salti,
in modo da poter implementare i cicli e le strutture di controllo. Inoltre le istruzioni
devono essere eseugite in sequenza (un'istruzione alla volta).

\subsection{CPU}
Ogni processore ha un'set di istruzioni diverso in base all'architettura,
questo set di istruzioni è chiamato \textbf{ISA} (Instruction Set Architecture).
\textbf{Assembly} è un linguaggio di programmazione che permette di scrivere programmi
in base all'ISA del processore e questo linguaggio viene tradotto in linguaggio binario
attraverso un \textbf{assembler}. In questo corso viene usata l'architettura x86 (80x86).

\subsubsection{Modello semplificato}
Per rappresentare il funzionamento di un processore si può usare un modello semplificato
rappresentato ad alto livello. Questo modello è composto da:
\begin{itemize}
	\item \textbf{Central Processing Unit (CPU)}: esegue le istruzioni
	\item \textbf{Control Unit (CU)}: controlla il flusso delle istruzioni
	\item \textbf{Bus Dati (BD)}: trasferisce i dati alla CPU
	\item \textbf{Bus Istruzioni (BI)}: trasferisce le istruzioni alla CPU
	\item \textbf{Bus di Controllo (BC)}: trasferisce i segnali di controllo
	\item \textbf{Memory Address Register (MAR)}: contiene l'indirizzo di memoria da leggere
	\item \textbf{Memory Data Register (MDR)}: contiene i dati letti dalla memoria
	\item \textbf{Program Counter (PC)}: tiene conto dell'indirizzo dell'istruzione da eseguire
	\item \textbf{Instruction Register (IR)}: contiene l'istruzione corrente
	\item \textbf{Program Status Word (PSW)}: contiene i flag del processore (es. zero, carry, overflow).
	      È come se fosse un array in cui ad ogni indice corrisponde un flag per ogni operazione.
	\item \textbf{Register File}: contiene i registri del processore (es. EAX, EBX, ECX, EDX, ESI, EDI, ESP, EBP)
	\item \textbf{Arithmetic Logic Unit (ALU)}: esegue le operazioni aritmetiche e logiche
\end{itemize}
\begin{figure}[H]
	\centering
	\begin{tikzpicture}[scale=1.5]
		\draw (0,0) rectangle (4,4);
		\node[above left, scale=0.7] at (4,0) {CPU};

		\draw (2,2) rectangle (4,4);
		\node[above left, scale=0.7] at (3.4,2) {CU};

		\node[draw, rectangle, align=center, scale=0.8, minimum width=1cm, minimum height=0.8cm] (pc) at (2.4, 2.35) {PC};
		\node[draw, rectangle, align=center, scale=0.8, minimum width=1cm, minimum height=0.8cm] (ir) at (2.4, 2.95) {IR};
		\node[draw, rectangle, align=center, scale=0.8, minimum width=1cm, minimum height=0.5cm] (psw) at (3.4, 3.55) {PSW};

		% Bus Istruzioni
		\draw (-0.5,0) -- (-0.5,4) node[above, scale=0.7] {BI};

		% Bus Dati
		\draw (-1,0) -- (-1,4) node[above, scale=0.7] {BD};

		% Bus di controllo
		\draw (4.5,0) -- (4.5,4) node[above, scale=0.7] {BC};

		% MAR (Memory Address Register)
		\node[draw, rectangle, align=center, scale=0.8, minimum width=0.5cm, minimum height=0.5cm] (mar) at (0.5, 3) {M\\A\\R};
		\draw[latex-latex] (mar) -- (-0.5,3);

		% MDR (Memory Data Register)
		\node[draw, rectangle, align=center, scale=0.8, minimum width=0.5cm, minimum height=0.5cm] (mdr) at (0.5, 1) {M\\D\\R};
		\draw[latex-latex] (mdr) -- (-1,1);

		\draw[latex-latex] (4,3) -- (4.5,3);

		% Register file
		\draw (1,0.4) rectangle (2,1.6);
		\draw (1,0.6) -- (2,0.6);
		\draw (1,0.8) -- (2,0.8);
		\draw (1,1) -- (2,1);
		\draw (1,1.2) -- (2,1.2);
		\draw (1,1.4) -- (2,1.4);

		\node[below left, xshift=8, scale=0.7] at (1.82,0.4) {Register File};

		% ALU
		\draw (2.7,0.5) -- (3.3,0.5) -- (3.5,1.5) -- (3.2,1.5) -- (3,1.2) -- (2.8,1.5) -- (2.5,1.5) -- cycle;
		\node[above, scale=0.6] at (3,0.5) {ALU};

		% Collegamenti
		\draw[latex-] (2.6,1.5) -- ++(0,0.2) -- ++(-0.8,0) -- ++(0,-0.1);
		\draw[latex-] (3.4, 1.5) -- ++(0,0.4) -- ++(-2.2,0) -- ++(0,-0.3);
		\draw[-latex] (3.4,1) -- ++(0.4,0) -- ++(0,2) -- ++(-0.2,0) -| (psw);
		\draw[-latex] (3,0.5) -- ++(0,-0.3) -- ++(-0.5,0) -- ++(0,0.3) -- ++(-0.5,0);
		\draw[-latex] (2.3,2) -- ++(0,-1) -- ++(0.3,0);
	\end{tikzpicture}
	\caption{Struttura di un processore}
\end{figure}

\noindent Il flusso di esecuzione delle istruzioni è il seguente:
\begin{itemize}
	\item \textbf{Fetch}: CU legge l'istruzione dalla memoria
	\item \textbf{Decode}: CU decodifica l'istruzione
	\item \textbf{Execute}: ALU esegue l'istruzione
\end{itemize}

\begin{figure}[H]
	\centering
	\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=3cm,
			thick,main node/.style={circle,draw,font=\sffamily\Large\bfseries}]

		\node[main node] (1) {\footnotesize Fetch};
		\node[main node] (2) [right of=1] {\footnotesize Decode};
		\node[main node] (3) [right of=2] {\footnotesize Execute};

		\path[every node/.style={font=\sffamily\small}]
		(1) edge [bend left] node {} (2)
		(2) edge [bend left] node {} (3)
		(3) edge [bend left] node {} (1);
	\end{tikzpicture}
	\caption{Flusso di esecuzione delle istruzioni}
\end{figure}

\section{Assembly (Intel x86)}
\subsection{Codifica}
Ogni istruzione è codificata nel seguente modo:

\begin{figure}[H]
	\centering
	\begin{tikzpicture}
		% Opcode
		\draw (0,0) rectangle (1.5,1);
		\node at (0.75,0.5) {Opcode};

		% Metodi di indirizzamento
		\draw (1.8,0) -- (1.8,1);
		\node[align=center, scale=0.7] at (1.65,0.5) {M\\I};

		% Source
		\draw (1.5,0) rectangle (3.6,1);
		\node at (2.55,0.5) {Source};

		% Metodi di indirizzamento
		\draw (3.3,0) -- (3.3,1);
		\node[align=center, scale=0.7] at (3.45,0.5) {M\\I};

		% Destination
		\draw (3.6,0) rectangle (5.6,1);
		\node at (4.6,0.5) {Destination};

	\end{tikzpicture}
\end{figure}

\subsection{Istruzioni}
\subsubsection{Istruzioni base}
\begin{itemize}
	\item \textbf{\texttt{MOVL <source> <destination>}}: copia il contenuto di un registro (o costante) in un altro.
	      Questa istruzione di solito viene utilizzata per spostare i valori dalla memoria ai
	      registri e viceversa, in modo da poter effettuare operazioni solo su dati presenti
	      nei registri e non direttamente in memoria, questo rende l'esecuzione più efficiente.
	\item \textbf{\texttt{NOP}}: non fa nulla e occupa solo un byte. La sua utilità è quella
	      di "riempire i buchi", cioè delle zone di memoria non occupate da nessuna istruzione.
\end{itemize}

\subsubsection{Istruzioni aritmetiche}
\begin{itemize}
	\item \textbf{\texttt{ADDL <source> <destination>}}: somma il contenuto di due registri (o costante).
	      Siccome sono disponibili solo 2 parametri, il risultato viene salvato nel secondo parametro
	      perchè viene visto sia come sorgente che destinazione per evitare di aggiungerne un terzo.
	\item \textbf{\texttt{SUBL <source> <destination>}}: sottrae il contenuto di due registri (o costante)
	\item \textbf{\texttt{MULL <source> <destination>}}: moltiplica il contenuto di due registri (o costante)
	\item \textbf{\texttt{INC <source>}}: incrementa il contenuto di un registro (o costante) di 1
	\item \textbf{\texttt{DEC <source>}}: decrementa il contenuto di un registro (o costante) di 1
\end{itemize}

\subsubsection{Istruzioni logiche}

\begin{itemize}
	\item \textbf{\texttt{CMPL <source> <destination>}}: confronta il contenuto di due registri (o costanti) e
	      modifica il flag \textbf{\texttt{PSW}} in base al risultato del confronto.
\end{itemize}

\subsubsection{Istruzioni di salto}
Se il salto è \textbf{assoluto} l'indirizzo fa riferimento alla memoria diretta, mentre se il salto è
\textbf{relativo} l'indirizzo è relativo al Program Counter.
\begin{itemize}
	\item \textbf{\texttt{JMP <etichetta>}}: salta all'istruzione con etichetta
	\item \textbf{\texttt{JE <etichetta>}}: salta all'istruzione con etichetta se i flag sono settati in modo che i due operandi siano uguali
	\item \textbf{\texttt{JNE <etichetta>}}: salta all'istruzione con etichetta se i flag sono settati in modo che i due operandi siano diversi
	\item \textbf{\texttt{JG <etichetta>}}: salta all'istruzione con etichetta se i flag sono settati in modo che il primo operando sia maggiore del secondo
	\item \textbf{\texttt{JGE <etichetta>}}: salta all'istruzione con etichetta se i flag sono settati in modo che il primo operando sia maggiore o uguale del secondo
	\item \textbf{\texttt{JL <etichetta>}}: salta all'istruzione con etichetta se i flag sono settati in modo che il primo operando sia minore del secondo
	\item \textbf{\texttt{JLE <etichetta>}}: salta all'istruzione con etichetta se i flag sono settati in modo che il primo operando sia minore o uguale del secondo
\end{itemize}
Comparando e poi utilizzando i salti si possono implementare le strutture di controllo come i cicli e le condizioni.
Nell'etichetta si può inserire un'indirizzo di memoria assoluto che permette di saltare a quell'indirizzo,
questo però non è molto utile perchè il programma potrebbe essere caricato in un'area diversa della memoria.

\subsubsection{Istruzioni di gestione dello Stack}
\begin{itemize}
	\item \textbf{\texttt{PUSHL <source>}}: inserisce il contenuto di un registro (o costante) nello stack
	\item \textbf{\texttt{POPL <destination>}}: estrae il contenuto dello stack e lo mette in un registro (o costante)
	\item \textbf{\texttt{CALL <etichetta>}}: salva l'indirizzo successivo al Program Counter nello stack e salta all'istruzione con etichetta
\end{itemize}

\subsubsection{Metodi di indirizzamento}
I metodi di indirizzamento (MI) sono diversi modi per accedere ai dati in memoria, i
più comuni sono:
\begin{itemize}
	\item \textbf{Registro}: Un'istruzione può accedere direttamente ai registri
	      ad esempio: \texttt{MOVL \%EAX, \%EBX}
	\item \textbf{Immediato}: Un'istruzione può accedere direttamente ai dati
	      ad esempio: \texttt{MOVL \$10, \%EBX}
	\item \textbf{Assoluto}: Un'istruzione può accedere direttamente ai dati
	      ad esempio: \texttt{MOVL DATO, \%EBX}\\
	      dove \texttt{DATO} è un'etichetta che punta ad un'indirizzo di memoria
	\item \textbf{Indiretto Registro}: Un'istruzione può contenere un registro che punta ad un altro registro
	      ad esempio: \texttt{MOVL (\%EAX), \%EBX}
	\item \textbf{Indiretto Registro con Spiazzamento}: Un'istruzione può mettere un offset
	      rispetto al registro contenuto nell'istruzione
	      ad esempio: \texttt{MOVL \$8(\%EAX), \%EBX}
\end{itemize}

\noindent Non tutte le istruzioni ammettono tutti i metodi di indirizzamento e alcuni metodi di indirizzamento
possono essere usati solo con alcune istruzioni.

\subsection{Esempi}
Un esempio di codice in C è il seguente:
\begin{lstlisting}[language=C]
  ...
  int a; // INDA (etichetta che punta ad un indirizzo di memoria con valore intero)
  int b; // INDB
  int c; // INDB
  ...
  a = 5; // %EAX
  b = 10; // %EBX

  if (a > b) {
    c = a - b; // %ECX
  } else { // ELSE
    c = a + b;
  }
  \end{lstlisting}

La traduzione in assembly è la seguente:
\begin{lstlisting}[language={[x86masm]Assembler}]
  MOVL INDA, %EAX // Ridondante
  MOVL $5, %EAX
  MOVL INDB, %EBX // Ridondante
  MOVL $10, %EBX
  MOVL %EAX, %ECX
  COMPL %EAX, %EBX
  JLE ELSE
  SUBL %ECX, %EAX
  JMP ENDIF
  ELSE:
  ADDL %EBX, %ECX
  ENDIF:
\end{lstlisting}

\noindent Un altro esempio di un for loop in C:
\begin{lstlisting}[language=C]
  for (int i = 0; i < 10; i++) { // int i; %EDX
    ...
  }
\end{lstlisting}

\noindent La traduzione in assembly è la seguente:
\begin{lstlisting}[language={[x86masm]Assembler}]
  MOVL $0, %EDX
  FOR:
  COMPL $10, %EDX
  JE ENDFOR
  ...
  INC %EDX
  JMP FOR
  ENDFOR:
\end{lstlisting}

\subsection{File assembly}
Un file assembly ha estensione \texttt{.s} e può contenere diverse sezioni:
\begin{itemize}
	\item \textbf{.section .data}: contiene le variabili globali e le costanti
	      \begin{lstlisting}[language={[x86masm]Assembler}]
  .section .data
  hello:
    .ascii "Hello, world!\n" ; Dichiarazione di una stringa costante

  hello_len:
    .long . - hello ; Lunghezza della stringa (posizione corrente (.) - posizione iniziale)
  \end{lstlisting}

	\item \textbf{.section .text}: contiene il codice assembly composto da istruzioni, etichette
	      e sottoprogrammi
	      \begin{lstlisting}[language={[x86masm]Assembler}]
  .section .text
  .global _start ; Nome convenzionale del punto di inizio del programma
  _start:
    movl ...
    ...
  \end{lstlisting}

	\item \textbf{.section .bss}: contiene le variabili globali non inizializzate (spazio da riservare)
\end{itemize}

\subsection{Compilazione}
Per compilare un file assembly si compiono i seguenti passi:
\begin{enumerate}
	\item \textbf{Compilazione}: si compila il file assembly con il comando \texttt{as} che
	      crea un file binario (\texttt{.o}) contenente
	      l'implementazione di ogni singolo file.
	\item \textbf{Linking}: si uniscono i file binari con il comando \texttt{ld} che crea un file eseguibile
	      a partire dai file binari.
	\item \textbf{Esecuzione}: si rende eseguibile il file e si esegue con il comando \\\texttt{./<nomefile>}
\end{enumerate}


\section{Memoria}
La memoria è una lista indicizzata di celle, a cui ognuna è associata un indirizzo.
La memoria è composta da due parti principali:
\begin{itemize}
	\item \textbf{Codice}: contiene le istruzioni
	\item \textbf{Dati statici}: contiene i dati
\end{itemize}

\noindent Non si può sapere a priori dove verrà caricato il programma in memoria, quindi
è necessario utilizzare lo spostamento relativo per accedere ai dati e alle istruzioni.

\begin{figure}[H]
	\centering
	\begin{tikzpicture}
		\draw (0,0) rectangle (2,1);
		\node at (1,0.5) {Codice};

		\draw (0,0) rectangle (2,-2);
		\node at (1,-1) {Istruzioni};

		\draw (0,-2) rectangle (2,-4);
		\node[align=center] at (1,-3) {Dati\\statici};

		\draw[<-] (0,-0.2) -- ++(-0.5,0) node[left] {Program Counter};
	\end{tikzpicture}
	\caption{Struttura della memoria}
\end{figure}

\begin{figure}[H]
	\begin{define}
		\textbf{Footprint}: è l'area di memoria occupata da un programma:
		\begin{itemize}
			\item \textbf{L}: 32 bit
			\item \textbf{V}: 16 bit
			\item \textbf{B}: 8 bit
		\end{itemize}
	\end{define}
\end{figure}

\subsection{Memoria dinamica}
La memoria dinamica è composta da due parti principali:
\begin{itemize}
	\item \textbf{Heap}: contiene le variabili allocate dinamicamente e ha una dimensione variabile
	\item \textbf{Stack}: contiene le variabili locali e i parametri delle funzioni. Ha una dimensione fissa
	      e limitata. Lo stack cresce con la modalità \textbf{LIFO} (Last In First Out), cioè l'ultimo
	      elemento inserito è il primo ad essere estratto e nell'architettura x86 cresce verso l'alto.
	      Lo stack è composta anche da 2 puntatori:
	      \begin{itemize}
		      \item \textbf{ESP} (Extended Stack Pointer): punta all'ultimo elemento inserito nello stack
		      \item \textbf{EBP} (Extended Base Pointer): punta alla base dello stack
	      \end{itemize}
\end{itemize}

\begin{figure}[H]
	\centering
	\begin{tikzpicture}
		\draw (0,0) rectangle (2,1);
		\node[align=center] at (1,0.5) {Dati\\Statici};

		\draw (0,0) rectangle (2,-2);
		\node[align=center] at (1,-1) {Variabili\\dinamiche};

		\draw (0,-2) rectangle (2,-4.1);
		\node at (1,-2.3) {Stack};

		\draw (0,-2.6) -- (2,-2.6) node[midway, below, yshift=-1, scale=0.8] {...};
		\draw (0,-2.9) -- (2,-2.9) node[midway, below, yshift=1, scale=0.8] {b};
		\draw (0,-3.2) -- (2,-3.2) node[midway, below, yshift=1, scale=0.8] {a};
		\draw (0,-3.5) -- (2,-3.5) node[midway, below, yshift=1, scale=0.8] {y};
		\draw (0,-3.8) -- (2,-3.8) node[midway, below, yshift=1, scale=0.8] {x};


		\draw[<-] (0,-3.2) -- ++(-0.5,0) node[left] {ESP};
		\draw[<-] (0,-3.8) -- ++(-0.5,0) node[left] {EBP};
	\end{tikzpicture}
\end{figure}

\noindent Per gestire i dati nello stack si utilizzano le seguenti istruzioni:
\begin{itemize}
	\item \textbf{\texttt{PUSHL <source>}}: inserisce il contenuto di un registro (o costante) nello stack
	\item \textbf{\texttt{POPL <destination>}}: estrae il contenuto dello stack e lo mette in un registro (o costante)
\end{itemize}

\subsection{Richiamare una funzione}
Per richiamare uan funzione bisogna far saltare il Program Counter all'indirizzo della funzione
e poi salvare l'indirizzo successivo nello stack. Per fare ciò si utilizza l'istruzione \texttt{CALL}.
\begin{itemize}
	\item \textbf{\texttt{CALL <etichetta>}}: salva l'indirizzo successivo al Program Counter nello stack e salta all'istruzione con etichetta.
	      Quando la funzione termina, per tornare al punto di chiamata si utilizza l'istruzione \texttt{RET}.
	\item \textbf{\texttt{RET}}: estrae l'indirizzo successivo al Program Counter dallo stack e salta a quell'indirizzo (torna al punto di chiamata).
\end{itemize}

Per recuperare i dati in memoria si utilizza l'istruzione \texttt{LEAL} (Load Effective Address):
\begin{itemize}
	\item \textbf{\texttt{LEAL <source>, <destination>}}: prende l'indirizzo di memoria in cui è stato salvato qualcosa
	      e lo mette in un registro
\end{itemize}



\end{document}
