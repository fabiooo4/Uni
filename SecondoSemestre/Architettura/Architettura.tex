\documentclass[a4paper]{article}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{textcomp}
\usepackage[italian]{babel}
\usepackage{amsmath, amssymb}
\usepackage{booktabs,xltabular}
\usepackage{amsfonts}
\usepackage{mdframed}
\usepackage{float}
\usepackage{xcolor}
\usepackage{listings}
\usepackage{graphicx}
\usepackage{tikz}
\usetikzlibrary{shapes, arrows, automata, petri, positioning, calc}
\usepackage{circuitikz}
\usepackage[label=corner]{karnaugh-map}
\graphicspath{{./figures/}}

\usepackage{ntheorem}
\newtheorem{theorem}{Teorema}

\usepackage{import}
\usepackage{pdfpages}
\usepackage{transparent}
\usepackage{xcolor}

\usepackage{hyperref}
\hypersetup{
    colorlinks=false,
}

% Code blocks
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.95}

\lstdefinestyle{mystyle}{
	backgroundcolor=\color{backcolour},
	commentstyle=\color{codegreen},
	keywordstyle=\color{magenta},
	numberstyle=\tiny\color{codegray},
	stringstyle=\color{codepurple},
	basicstyle=\ttfamily\footnotesize,
	breakatwhitespace=false,
	breaklines=true,
	captionpos=b,
	keepspaces=true,
	numbers=left,
	numbersep=5pt,
	showspaces=false,
	showstringspaces=false,
	showtabs=false,
	tabsize=2
}

\lstset{style=mystyle}

\usepackage{color}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=tb,
	aboveskip=3mm,
	belowskip=3mm,
	showstringspaces=false,
	columns=flexible,
	basicstyle={\small\ttfamily},
	numbers=none,
	numberstyle=\tiny\color{gray},
	keywordstyle=\color{blue},
	commentstyle=\color{dkgreen},
	stringstyle=\color{mauve},
	breaklines=true,
	breakatwhitespace=true,
	tabsize=3
}

\usepackage{import}
\usepackage{pdfpages}
\usepackage{transparent}
\usepackage{xcolor}



% Useful definitions frame
\theoremstyle{break}
\theoremheaderfont{\bfseries}
\newmdtheoremenv[%
	linecolor=gray,leftmargin=0,%
	rightmargin=0,
	innertopmargin=8pt,%
	innerbottommargin=8pt,
	ntheorem]{define}{Definizioni utili}[section]

% Example frame
\theoremstyle{break}
\theoremheaderfont{\bfseries}
\newmdtheoremenv[%
	linecolor=gray,leftmargin=0,%
	rightmargin=0,
	innertopmargin=8pt,%
	innerbottommargin=8pt,
	ntheorem]{example}{Esempio}[section]

% Important definition frame
\theoremstyle{break}
\theoremheaderfont{\bfseries}
\newmdtheoremenv[%
	linecolor=gray,leftmargin=0,%
	rightmargin=0,
	backgroundcolor=gray!40,%
	innertopmargin=8pt,%
	innerbottommargin=8pt,
	ntheorem]{definition}{Definizione}[section]

% Exercise frame
\theoremstyle{break}
\theoremheaderfont{\bfseries}
\newmdtheoremenv[%
	linecolor=gray,leftmargin=0,%
	rightmargin=0,
	innertopmargin=8pt,%
	innerbottommargin=8pt,
	ntheorem]{exercise}{Esercizio}[section]

% figure support
\usepackage{import}
\usepackage{xifthen}
\pdfminorversion=7
\usepackage{pdfpages}
\usepackage{transparent}
\newcommand{\incfig}[1]{%
	\def\svgwidth{\columnwidth}
	\import{./figures/}{#1.pdf_tex}
}

% FSM tikz
\tikzset{
    place/.style={
        circle,
        thick,
        draw=black,
        minimum size=6mm,
    },
        state/.style={
        circle,
        thick,
        draw=blue!75,
        fill=blue!20,
        minimum size=6mm,
    },
}

\pdfsuppresswarningpagegroup=1

\begin{document}
\input{title.tex}

\tableofcontents
\pagebreak

% Laboratorio
\section{Laboratorio}
\subsection{Vantaggi e svantaggi di assembly}
\subsubsection{Vantaggi}
Siccome assembly è un linguaggio di basso livello, è molto vicino all'hardware e quindi è possibile:
\begin{itemize}
	\item accedere direttamente ai \textbf{registri} della CPU
	\item scrivere \textbf{codice ottimizzato} per una specifica architettura di CPU
	\item ottimizzare le \textbf{sezioni "critiche"} dei programmi
\end{itemize}

\subsubsection{Svantaggi}
I principali svantaggi sono:
\begin{itemize}
	\item possono essere richieste \textbf{molte più righe} di codice
	\item è facile introdurre dei \textbf{bug} perchè la programmazione è più complessa
	\item il \textbf{debugging} è complesso
	\item \textbf{non è garantita la compatibilità} del codice per altri hardware
\end{itemize}

\subsection{Utilità}
Assembly permette di gestire direttamente il funzionamento della CPU, di conseguenza,
i programmi Assembly, una volta compilati sono tipicamente più veloci e più piccoli dei
programmi scritti in linguaggi di alto livello. Per questo motivo, l'assembly è utilizzato
per scrivere codice che deve essere il più veloce possibile, come ad esempio i driver di
hardware specifici.

\subsection{Registri}
Tutti i processori della famiglia x86 hanno i seguenti registri:
AX, BX, CX, DX, CS, DS, ES, SS, SP, BP, SI, DI, IP, FLAGS.

\vspace{1em}
\noindent Originariamente i registri AX, BX, CX, DX, SP, BP, SI, DI, IP e FLAGS avevano una dimensione
di 16 bit. A partire dal 80386, la loro dimensione è stata estesa a 32 bit e al loro nome
è stato aggiunto il prefisso E (Extended). Per ragioni di retrocompatibilità, i registri
di 16 bit possono essere utilizzati anche nei processori a 32 bit utilizzando il loro
nome originale.

\subsubsection{Registri general purpose}
I seguenti registri sono generici, pertanto è possibile assegnargli qualunque valore. Tuttavia,
durante l'esecuzione di alcune istruzioni i registri generici vengono utilizzati per
memorizzare valori ben determinati:
\begin{itemize}
	\item \textbf{EAX} (Accumulator register): è usato come accumulatore per
	      operazioni aritmetiche e contiene il risultato dell'operazione
	\item \textbf{EBX} (Base register): è usato per operazioni di indirizzamento della
	      memoria
	\item \textbf{ECX} (Counter register):  è usato per "contare", ad esempio nelle
	      operazioni di loop
	\item \textbf{EDX} (Data register): è usato nelle operazioni di input/output, nelle
	      divisioni e nelle moltiplicazioni

\end{itemize}

\subsubsection{Registri di segmento}
CS, DS, ES e SS sono i \textbf{registri di segmento} (segment registers) e devono
essere utilizzati con cautela:
\begin{itemize}
	\item \textbf{CS} (Code Segment): punta alla zona di memoria che contiene il codice.
	      Durante l'esecuzione del programma, assieme al registro IP, serve per
	      accedere alla prossima istruzione da eseguire (attenzione: non può
	      essere modificato!)
	\item \textbf{DS} (Data Segment): punta alla zona di memoria che contiene i dati
	\item \textbf{ES} (Extra Segment):  può essere usato come registro di segmento
	      ausiliario
	\item \textbf{SS} (Stack Segment): punta alla zona di memoria in cui risiede lo stack
\end{itemize}

\subsubsection{Registri puntatore}
ESP, EBP, EIP sono i registri puntatore (pointer registers):
\begin{itemize}
	\item \textbf{ESP} (Stack Pointer):  punta alla cima dello stack. Viene modificato
	      dalle operazioni di PUSH (inserimento di un dato nello stack) e POP
	      (estrazioni di un dato dallo stack). Si ricordi che lo stack è una
	      struttura di tipo LIFO (Last In First Out - l'ultimo che entra è il primo
	      che esce). È possibile modificarlo manualmente ma occorre cautela!
	\item \textbf{EBP} (Base Pointer): punta alla base della porzione di stack gestita in
	      quel punto del codice. È possibile modificarlo manualmente ma
	      occorre cautela!
	\item \textbf{EIP} (Instruction Pointer): punta alla prossima istruzione da eseguire.
	      Non può essere modificato!
\end{itemize}

\subsubsection{Registri indice}
ESI e EDI sono i registri indice (index registers) e vengono utilizzati per
operazioni con stringhe e vettori:
\begin{itemize}
	\item \textbf{ESI} (Source Index):  punta alla stringa/vettore sorgente
	\item \textbf{EDI} (Destination Index): punta alla stringa/vettore destinazione
	\item \textbf{EFLAGS}: è utilizzato per memorizzare lo stato corrente del processore.
	      Ciascuna flag (bit) del registro fornisce una particolare informazione.
	      Ad esempio, la flag in prima posizione (carry flag) viene posta a 1
	      quando c;è stato un riporto o un prestito durante un'operazione
	      aritmetica; la flag in seconda posizione (parity flag) viene usata come
	      bit di parità e viene posta a 1 quando il risultato dell'ultima
	      operazione ha un numero pari di 1
\end{itemize}

\subsubsection{Composizione dei registri}
I registri sono composti da 32 bit e possono essere divisi in registri più piccoli:
\begin{itemize}
	\item \textbf{EAX}: AX, AH, AL
	\item \textbf{EBX}: BX, BH, BL
	\item \textbf{ECX}: CX, CH, CL
	\item \textbf{EDX}: DX, DH, DL
	\item \textbf{ESP}: SP
	\item \textbf{EBP}: BP
	\item \textbf{ESI}: SI
	\item \textbf{EDI}: DI
\end{itemize}

\subsubsection{Composizione del registro EFLAGS}
Il registro EFLAGS è composto da 32 bit e ogni bit corrisponde ad un flag:
\begin{itemize}
	\item \textbf{ZF} (Zero flag):  impostato a 1 se il risultato dell'operazione è 0
	\item \textbf{SF} (Sign flag): impostato a 1 se il risultato dell'operazione è un
	      numero negativo, a 0 se è positivo (rappresentazione in complemento
	      a 2)
	\item \textbf{OF} (Overflow flag): impostato a 1 nel caso di overflow di
	      un'operazione
	\item \textbf{TF} (Trap flag): impostato a 1 genera un'interruzione ad ogni
	      istruzione. Utilizzato per l'esecuzione passo-passo dei programmi
	\item \textbf{IF} (Interrupt flag): impostato a 1 abilita gli interrupt esterni, con 0 li
	      disabilita
	\item \textbf{DF} (Direction flag): impostato a 1 indica che nelle operazioni di
	      spostamento di stringhe i registri DI e SI si autodecrementano (con 0
	      tali registri si auto incrementano)
\end{itemize}

\subsection{Modalità di indirizzamento}
Si rifersce al modo in cui un'istruzione assembly accede ai dati in memoria e può essere:
\begin{itemize}
	\item \textbf{Indirizzamento a registro}: l'operando è contenuto in un registro ed
	      il nome del registro è specificato nell'istruzione. Ad esempio:
	      \begin{center}
		      \texttt{\%Ri}
	      \end{center}

	\item \textbf{Indirizzamento diretto} (o assoluto): l'operando è contenuto in una
	      locazione di memoria, e l'indirizzo della locazione viene specificato
	      nell'istruzione. Ad esempio:
	      \begin{center}
		      \texttt{(IND)}
	      \end{center}

	\item \textbf{Indirizzamento immediato} (o di costante): l'operando è un valore
	      costante ed è definito esplicitamente nell'istruzione. Ad esempio:
	      \begin{center}
		      \texttt{\$VAL}
	      \end{center}

	\item \textbf{Indirizzamento indiretto}: l'indirizzo di un operando è contenuto in
	      un registro o in una locazione di memoria. L'indirizzo della locazione o
	      il registro viene specificato nell'istruzione. Ad esempio:
	      \begin{center}
		      \texttt{(\%Ri)} \quad o \quad \texttt{(\$VAL)}
	      \end{center}

	\item \textbf{Indirizzamento indicizzato} (Base e spiazzamento): l'indirizzo
	      effettivo dell'operando è calcolato sommando un valore costante al
	      contenuto di un registro. Ad esempio:
	      \begin{center}
		      \texttt{SPI(\%Ri)}
	      \end{center}

	\item \textbf{Indirizzamento con autoincremento}: l'indirizzo effettivo
	      dell'operando è il contenuto di un registro specificato nell'istruzione.
	      Dopo l'accesso, il contenuto del registro viene incrementato per
	      puntare all'elemento successivo

	\item \textbf{Indirizzamento con autodecremento}: il contenuto di un registro
	      specificato nell'istruzione viene decrementato. Il nuovo contenuto
	      viene usato come indirizzo effettivo dell'operando

\end{itemize}

\subsection{Istruzioni}
\subsubsection{Istruzioni di inizializzazione}
\begin{itemize}
	\item \texttt{mov src, dst} \quad \textbf{Move}: consente l'inizializzazione di un registro o di
	      un'area di memoria. Accetta i modificatori \texttt{l}, \texttt{w} e \texttt{b} per
	      indicare la dimensione dell'operando \texttt{s rc}
	\item \texttt{lea src, dst} \quad \textbf{Load Effective Address}: trasferisce l'indirizzo
	      effettivo dell'operando \texttt{src} nel registro \texttt{dst}
\end{itemize}

\subsubsection{Istruzioni aritmetiche e logiche}
\begin{itemize}
	\item \texttt{sar op1, op2} \quad \textbf{Shift Arithmetic Right}: esegue lo shift a destra sul
	      registro \texttt{op2} di tanti bit quanti specificati in \texttt{op1}. Il bit
	      più significativo viene replicato (così da funzionare anche
	      con numeri negativi in complemento 2) e il bit scartato
	      viene messo nel \textbf{Carry Flag}. \texttt{op1} può essere un registro
	      o un valore immediato, \texttt{op2} deve essere un registro
	\item \texttt{sal op1, op2} \quad \textbf{Shift Arithmetic Left}: esegue lo shift a sinistra sul
	      registro \texttt{op2} di tanti bit quanti specificati in \texttt{op1}. Il bit
	      meno significativo viene messo a \( 0 \)  e il bit scartato viene
	      messo nel \textbf{Carry Flag}. \texttt{op1} può essere un registro o un
	      valore immediato, \texttt{op2} deve essere un registro
	\item \texttt{inc op} \quad \textbf{Increment}: incrementa di 1 il valore memorizzato in
	      \texttt{op}. \texttt{op} può essere un registro o una locazione di memoria
	\item \texttt{dec op} \quad \textbf{Decrement}: decrementa di 1 il valore memorizzato in
	      \texttt{op}. \texttt{op} può essere un registro o una locazione di
	      memoria
	\item \texttt{add src, dst} \quad \textbf{Add}: somma a \texttt{dst} il valore di \texttt{src}
	      e memorizza il risultato in \texttt{dst}
	\item \texttt{sub src, dst} \quad \textbf{Subtract}: sottrae da \texttt{dst} il valore di \texttt{src}
	      e memorizza il risultato in \texttt{dst}
	\item \texttt{mul moltipl} \quad \textbf{Unsigned Multiplication}: esegue la moltiplicazione
	      senza segno. \texttt{moltipl} deve essere un registro o una
	      variabile. Se \texttt{moltipl} è un byte il registro \texttt{AL} viene
	      moltiplicato per l'operando e il risultato viene
	      memorizzato in \texttt{AX}. Se \texttt{moltipl} è una word il
	      contenuto del registro \texttt{AX} viene moltiplicato per
	      l'operando e il risultato viene memorizzato nella coppia
	      di registri \texttt{DX}:\texttt{AX} (\texttt{DX} conterrà i 16 bit più significativi
	      del risultato). Se \texttt{moltipl} è un long il contenuto del
	      registro E\texttt{AX} viene moltiplicato per l'operando e il
	      risultato viene memorizzato nella coppia di registri
	      \texttt{EDX}:\texttt{EAX} (\texttt{EDX} conterrà i 32 bit più significativi del
	      risultato).
	\item \texttt{imul moltipl} \quad moltiplicazione con segno
	\item \texttt{div divisore} \quad \textbf{Unsigned Division}:
	      esegue la divisione senza segno.
	      \texttt{divisore} deve essere un registro o una variabile. Se
	      \texttt{divisore} è un byte il registro \texttt{AX} viene diviso per
	      l'operando, il quoziente viene memorizzato in \texttt{AL}, e il
	      resto in \texttt{AH}. Se \texttt{divisore} è una word, il valore ottenuto
	      concatenando il contenuto di \texttt{DX} e \texttt{AX} viene diviso per
	      l'operando (i 16 bit più significativi del dividendo
	      devono essere memorizzati nel registro \texttt{DX}), il quoziente
	      viene memorizzato nel registro \texttt{AX} e il resto in \texttt{DX}. Se
	      \texttt{divisore} è un long, il valore ottenuto concatenando il
	      contenuto di \texttt{EDX} e \texttt{EAX} viene diviso per l'operando (i
	      32 bit più significativi del dividendo sono nel registro
	      \texttt{EDX}), il quoziente viene memorizzato nel registro \texttt{EAX}
	      e il resto in \texttt{EDX}
	\item \texttt{xor src, dst} \quad \textbf{Logical Exclusive OR}: calcola l'OR esclusivo bit a bit
	      dei due operandi e lo memorizza nell'operando \texttt{dst}.
	      Spesso si utilizza per azzerare un registro, utilizzandolo
	      sia come \texttt{src} che come \texttt{dst})
	\item \texttt{or src, dst} \quad \textbf{Logical OR}: calcola l'OR logico bit a bit dei due
	      operandi e lo memorizza nell'operando \texttt{dst}
	\item \texttt{and src, dst} \quad \textbf{Logical AND}: calcola l'AND bit a bit dei due operandi
	      e lo memorizza nell'operando \texttt{dst}
	\item \texttt{not op} \quad \textbf{Logical NOT}: inverte ogni singolo bit dell'operando op
\end{itemize}

\subsection{AT\&T vs Intel}
Le principali differenze tra la sintassi AT\&T e Intel sono:
\begin{itemize}
	\item In AT\&T i nomi dei registri hanno il carattere \texttt{\%} come prefisso
	\item In AT\&T l'ordine degli operandi è \texttt{<sorgente>, <destinazione>}, opposto
	      rispetto alla sintassi Intel
	\item In AT\&T la lunghezza dell'operando è specificata tramite un suffisso al nome
	      dell'istruzione. \texttt{b} per \textbf{byte} (8 bit), \texttt{w} per \textbf{word} (16 bit),
	      \texttt{l} per \textbf{double word} (32 bit)
	\item Gli operandi immediati in AT\&T sono preceduti dal simbolo \texttt{\$}
	\item la presenza di prefisso in un operando indica che si tratta di un
	      indirizzo di memoria. Ad esempio:
	      \begin{center}
		      \texttt{movl \$pippo, \%eax} \quad è diverso da \quad \texttt{movl pippo, \%eax}
	      \end{center}
	\item l'indicizzazione o l'indirezione è ottenuta racchiudendo tra parentesi
	      l'indirizzo di base espresso tramite un registro o un valore immediato.
	      Ad esempio:
	      \begin{center}
		      \texttt{movl 5, 17(\%ebp)}
	      \end{center}
\end{itemize}

\subsection{Assemblare, verificare ed eseguire un programma Assembly}
% Prima di tutto bisogna creare un file con estensione \texttt{.s} e scrivere il codice assembly.
% Dopo aver scritto il codice assembly, si compila il file con il comando \texttt{as} che crea un file binario
% (\texttt{.o}) contenente l'implementazione di ogni singolo file. Infine si uniscono i file binari con il comando
% \texttt{ld} che crea un file eseguibile a partire dai file binari.
%
% \begin{lstlisting}[language=bash]
%  $  as -o <nomefile>.o <nomefile>.s
%  $  ld -o <nomefile> <nomefile>.o
%  $  ./<nomefile>
%   
% \end{lstlisting}

Il processo di creazione di un programma Assembly passa attraverso le seguenti fasi:
\begin{enumerate}
	\item Scrittura di uno o più file ASCII (con estensione \texttt{.s}) contenenti il
	      programma sorgente, tramite un normale editor di testo.
	\item Assemblaggio dei file sorgenti, e generazione dei file \textbf{oggetto} (con
	      estensione \texttt{.o}), tramite un \textbf{assemblatore}.
	\item Creazione del file \textbf{eseguibile}, tramite un \textbf{linker}
	\item Verifica del funzionamento e correzione degli eventuali errori tramite un
	      \textbf{debugger}
\end{enumerate}

\subsubsection{L'assemblatore}
L'Assemblatore trasforma i file contenenti il programma sorgente in altrettanti file
oggetto contenenti il codice in linguaggio macchina. Durante questo corso verrà usato
l'assemblatore \textbf{gas} della GNU.

\noindent Per assemblare un file è necessario eseguire il seguente comando:
\begin{lstlisting}[language=bash]
  $  as -o <nomefile>.o <nomefile>.s
\end{lstlisting}

\subsubsection{Il linker}
Il linker combina i moduli oggetto e produce un unico file eseguibile. In particolare
unisce i moduli oggetto, risolvendo i riferimenti a simboli esterni; ricerca i file di
libreria contenenti le procedure esterne utilizzate dai vari moduli e produce un file
eseguibile. L'operazione di linking deve essere effettuata anche se il programma è
composto da un solo modulo oggetto.

\noindent Durante il corso verrà usato il linker \textbf{ld} della GNU.

\noindent Per creare l'eseguibile a partire da un file oggetto è necessario eseguire il
seguente comando:
\begin{lstlisting}[language=bash]
  $  ld -o <nomefile>.x <nomefile1>.o <nomefile2>.o ...
\end{lstlisting}

\subsubsection{Assembly 32bit su macchine 64bit}
La gran parte del codice ASM32 è compatibile con macchine a 64bit, tuttavia alcune
estensioni in particolari istruzioni non sono riconosciute dai compilatori. È possibile
utilizzare codice ASM32 su architetture a 64bit utilizzando dei flag di compilazione che
permettono di simulare il comportamento di una architettura a 32bit.
\begin{lstlisting}[language=bash]
  $  as --32 -o <nomefile>.o <nomefile>.s
  $  ld -m elf_i386 -o <nomefile> <nomefile>.o
\end{lstlisting}

\subsection{Stampa di numeri}
I numeri sono memorizzati nei registri e nelle variabili come interi in complemento a 2
su 32 bit. Affinchè essi possano essere stampati a video occorre trasformarli in stringhe
di caratteri cioè vettori di byte dove ciascun byte rappresenta un carattere secondo la
codifica ASCII.

\noindent Per trasformare un numero intero in una stringa occorre scomporlo nelle sue
cifre mediante divisioni successive per 10. Per la particolare conformazione della tabella
ASCII il codice del carattere corrispondente alla cifra \( n \) si ottiene come \( n+48 \).

\subsubsection{Tabella dei caratteri ASCII}
La tabella seguente è relativa al codice US ASCII, ANSI X3.4-1986 (ISO International
Reference Version). I codici decimali da 0 a 31 e il 127 sono caratteri non stampabili
(codici di controllo). Il 32 corrispondente al carattere "spazio". I codici dal 32 al 126
sono caratteri stampabili.
\begin{xltabular}{\textwidth}{|c|c|c|l|}
	\hline
	\textbf{Char} & \textbf{Dec} & \textbf{Nome} & \textbf{Descrizione} \\
	\hline
	& 0 & NUL (Ctrl-@) & NULL \\
	\hline
	& 1 & SOH (Ctrl-A) & Start of Heading \\
	\hline
	& 2 & STX (Ctrl-B) & Start of Text \\
	\hline
	& 3 & ETX (Ctrl-C) & End of Text \\
	\hline
	& 4 & EOT (Ctrl-D) & End of Transmission \\
	\hline
	& 5 & ENQ (Ctrl-E) & Enquiry \\
	\hline
	& 6 & ACK (Ctrl-F) & Acknowledge \\
	\hline
	& 7 & BEL (Ctrl-G) & Bell (Beep) \\
	\hline
	& 8 & BS (Ctrl-H) & Backspace \\
	\hline
	& 9 & HT (Ctrl-I) & Horizontal Tab \\
	\hline
	& 10 & LF (Ctrl-J) & Line Feed \\
	\hline
	& 11 & VT (Ctrl-K) & Vertical Tab \\
	\hline
	& 12 & FF (Ctrl-L) & Form Feed \\
	\hline
	& 13 & CR (Ctrl-M) & Carriage Return \\
	\hline
	& 14 & SO (Ctrl-N) & Shift Out \\
	\hline
	& 15 & SI (Ctrl-O) & Shift In \\
	\hline
	& 16 & DLE (Ctrl-P) & Data Link Escape \\
	\hline
	& 17 & DC1 (Ctrl-Q) & Device Control 1 (XON) \\
	\hline
	& 18 & DC2 (Ctrl-R) & Device Control 2 \\
	\hline
	& 19 & DC3 (Ctrl-S) & Device Control 3 (XOFF) \\
	\hline
	& 20 & DC4 (Ctrl-T) & Device Control 4 \\
	\hline
	& 21 & NAK (Ctrl-U) & Negative Acknowledge \\
	\hline
	& 22 & SYN (Ctrl-V) & Synchronous Idle \\
	\hline
	& 23 & ETB (Ctrl-W) & End of Transmission Block \\
	\hline
	& 24 & CAN (Ctrl-X) & Cancel \\
	\hline
	& 25 & EM (Ctrl-Y) & End of Medium \\
	\hline
	& 26 & SUB (Ctrl-Z) & Substitute \\
	\hline
	& 27 & ESC (Ctrl-[) & Escape \\
	\hline
	& 28 & FS (Ctrl-\textbackslash) & File Separator \\
	\hline
	& 29 & GS (Ctrl-]) & Group Separator \\
	\hline
	& 30 & RS (Ctrl-\textasciicircum) & Record Separator \\
	\hline
	& 31 & US (Ctrl-\_) & Unit Separator \\
	\hline
	\texttt{ } & 32 & & Space \\
	\hline
	\texttt{!} & 33 & & Exclamation mark \\
	\hline
	\texttt{"} & 34 & & Quotation mark \\
	\hline
	\texttt{\#} & 35 & & Number sign \\
	\hline
	\texttt{\$} & 36 & & Dollar sign \\
	\hline
	\texttt{\%} & 37 & & Percent sign \\
	\hline
	\texttt{\&} & 38 & & Ampersand \\
	\hline
	\texttt{'} & 39 & & Apostrophe \\
	\hline
	\texttt{(} & 40 & & Left parenthesis \\
	\hline
	\texttt{)} & 41 & & Right parenthesis \\
	\hline
	\texttt{*} & 42 & & Asterisk \\
	\hline
	\texttt{+} & 43 & & Plus sign \\
	\hline
	\texttt{,} & 44 & & Comma \\
	\hline
	\texttt{-} & 45 & & Hyphen \\
	\hline
	\texttt{.} & 46 & & Period, dot \\
	\hline
	\texttt{/} & 47 & & Slash \\
	\hline
	\texttt{0} & 48 & & Zero \\
	\hline
	\texttt{1} & 49 & & One \\
	\hline
	\texttt{2} & 50 & & Two \\
	\hline
	\texttt{3} & 51 & & Three \\
	\hline
	\texttt{4} & 52 & & Four \\
	\hline
	\texttt{5} & 53 & & Five \\
	\hline
	\texttt{6} & 54 & & Six \\
	\hline
	\texttt{7} & 55 & & Seven \\
	\hline
	\texttt{8} & 56 & & Eight \\
	\hline
	\texttt{9} & 57 & & Nine \\
	\hline
	\texttt{:} & 58 & & Colon \\
	\hline
	\texttt{;} & 59 & & Semicolon \\
	\hline
	\texttt{<} & 60 & & Less-than sign \\
	\hline
	\texttt{=} & 61 & & Equal sign \\
	\hline
	\texttt{>} & 62 & & Greater-than sign \\
	\hline
	\texttt{?} & 63 & & Question mark \\
	\hline
	\texttt{@} & 64 & & At sign \\
	\hline
	\texttt{A} & 65 & & Uppercase A \\
	\hline
	\texttt{B} & 66 & & Uppercase B \\
	\hline
	\texttt{C} & 67 & & Uppercase C \\
	\hline
	\texttt{D} & 68 & & Uppercase D \\
	\hline
	\texttt{E} & 69 & & Uppercase E \\
	\hline
	\texttt{F} & 70 & & Uppercase F \\
	\hline
	\texttt{G} & 71 & & Uppercase G \\
	\hline
	\texttt{H} & 72 & & Uppercase H \\
	\hline
	\texttt{I} & 73 & & Uppercase I \\
	\hline
	\texttt{J} & 74 & & Uppercase J \\
	\hline
	\texttt{K} & 75 & & Uppercase K \\
	\hline
	\texttt{L} & 76 & & Uppercase L \\
	\hline
	\texttt{M} & 77 & & Uppercase M \\
	\hline
	\texttt{N} & 78 & & Uppercase N \\
	\hline
	\texttt{O} & 79 & & Uppercase O \\
	\hline
	\texttt{P} & 80 & & Uppercase P \\
	\hline
	\texttt{Q} & 81 & & Uppercase Q \\
	\hline
	\texttt{R} & 82 & & Uppercase R \\
	\hline
	\texttt{S} & 83 & & Uppercase S \\
	\hline
	\texttt{T} & 84 & & Uppercase T \\
	\hline
	\texttt{U} & 85 & & Uppercase U \\
	\hline
	\texttt{V} & 86 & & Uppercase V \\
	\hline
	\texttt{W} & 87 & & Uppercase W \\
	\hline
	\texttt{X} & 88 & & Uppercase X \\
	\hline
	\texttt{Y} & 89 & & Uppercase Y \\
	\hline
	\texttt{Z} & 90 & & Uppercase Z\\
	\hline
	\texttt{[} & 91 & & Left square bracket \\
	\hline
	\texttt{\textbackslash} & 92 & & Backslash \\
	\hline
	\texttt{]} & 93 & & Right square bracket \\
	\hline
	\texttt{\textasciicircum} & 94 & & Circumflex accent\\
	\hline
	\texttt{\_} & 95 & & Underscore \\
	\hline
	\texttt{`} & 96 & & Grave accent \\
	\hline
	\texttt{a} & 97 & & Lowercase a \\
	\hline
	\texttt{b} & 98 & & Lowercase b \\
	\hline
	\texttt{c} & 99 & & Lowercase c \\
	\hline
	\texttt{d} & 100 & & Lowercase d \\
	\hline
	\texttt{e} & 101 & & Lowercase e \\
	\hline
	\texttt{f} & 102 & & Lowercase f \\
	\hline
	\texttt{g} & 103 & & Lowercase g \\
	\hline
	\texttt{h} & 104 & & Lowercase h \\
	\hline
	\texttt{i} & 105 & & Lowercase i \\
	\hline
	\texttt{j} & 106 & & Lowercase j \\
	\hline
	\texttt{k} & 107 & & Lowercase k \\
	\hline
	\texttt{l} & 108 & & Lowercase l \\
	\hline
	\texttt{m} & 109 & & Lowercase m \\
	\hline
	\texttt{n} & 110 & & Lowercase n \\
	\hline
	\texttt{o} & 111 & & Lowercase o \\
	\hline
	\texttt{p} & 112 & & Lowercase p \\
	\hline
	\texttt{q} & 113 & & Lowercase q \\
	\hline
	\texttt{r} & 114 & & Lowercase r \\
	\hline
	\texttt{s} & 115 & & Lowercase s \\
	\hline
	\texttt{t} & 116 & & Lowercase t \\
	\hline
	\texttt{u} & 117 & & Lowercase u \\
	\hline
	\texttt{v} & 118 & & Lowercase v \\
	\hline
	\texttt{w} & 119 & & Lowercase w \\
	\hline
	\texttt{x} & 120 & & Lowercase x \\
	\hline
	\texttt{y} & 121 & & Lowercase y \\
	\hline
	\texttt{z} & 122 & & Lowercase z \\
	\hline
	\texttt{\{} & 123 & & Left curly brace \\
	\hline
	\texttt{|} & 124 & & Vertical bar \\
	\hline
	\texttt{\}} & 125 & & Right curly brace \\
	\hline
	\texttt{\textasciitilde} & 126 & & Tilde \\
	\hline
	& 127 & DEL (Ctrl-?) & Delete \\
	\hline
\end{xltabular}

\subsection{Etichette ed istruzioni di salto}
In Assembly non esiste il costrutto \texttt{if} ... \texttt{then} ... \texttt{else}
e quindi le istruzioni di salto
servono per far saltare l'esecuzione del programma ad una certa istruzione in funzione
del valore di una condizione. Le uniche condizioni che si possono valutare sono \(<,=,>\) tra
due valori numerici e la presenza di zero nel registro ECX. In particolare, la valutazione
di una condizione di \(<,=,>\) consiste di due istruzioni: la prima sottrae tra loro i due valori
numerici e imposta i bit SF e ZF del registro EFLAGS, la seconda effettua il salto in base
al valore di tali flags.

\noindent Le etichette sono essenziali per le istruzioni di salto in quanto indicano a quale punto
della sequenza di istruzioni bisogna saltare. Occorre inserire prima dell'istruzione a cui
si vuole saltare un nome simbolico seguito dal carattere “\texttt{:}”. Ad esempio:
\begin{lstlisting}[language={[x86masm]Assembler}]
  etichetta:
    istruzioni
    ...
\end{lstlisting}
È importante che il nome dell'etichetta sia unico in tutto il programma. Anche in questo
caso, come per i nomi delle variabili, l'assemblatore trasforma i nomi delle etichette
in numeri binari (che in questo caso indicano l'indirizzo dell'istruzione che segue) a
meno che non si voglia conservarli per il debug (con l'opzione \texttt{--gstabs}).

\noindent In Assembly non esistono istruzioni ad alto livello per realizzare i cicli come \texttt{for} ...,
\texttt{while} ...; essi si devono costruire manualmente a partire dalle istruzioni di salto
condizionato. Se si vuole eseguire un ciclo per un certo numero di volte occorre utilizzare
ECX come contatore.

\subsection{Debugging}
% Fine laboratorio

\section{Architettura di Von Neumann}
L'esigenza era quella di avere un'architettura che permettesse di eseguire programmi
in modo automatico, senza dover cambiare il cablaggio del calcolatore, quindi il circuito
deve essere abbastanza generale per poter eseguire programmi diversi.

\subsection{Struttura}
L'architettura di Von Neumann è composta da 5 parti principali:
\begin{itemize}
	\item \textbf{Unità aritmetico-logica}: si occupa di eseguire le operazioni aritmetiche e logiche
	\item \textbf{Unità di controllo}: si occupa di controllare il flusso delle istruzioni
	\item \textbf{Memoria}: contiene i dati e le istruzioni
	\item \textbf{Input/Output}: permette di comunicare con l'esterno
	\item \textbf{Bus}: permette di trasferire i dati tra la memoria e l'unità aritmetico-logica (generalmente in oro)
\end{itemize}

\begin{figure}[H]
	\centering
	\begin{tikzpicture}
		% CPU
		\node[draw, rectangle, minimum width=2cm, minimum height=1.5cm] (cpu) at (0, 0) {\textbf{CPU}};
		% Memoria
		\node[draw, rectangle, align=center, minimum width=2cm, minimum height=1.5cm] (memory) at (4, 0) {\textbf{Memoria}\\\footnotesize Dati\\\footnotesize Istruzioni};

		% Bus
		\draw (-2,-2) -- (6.5,-2) node[right] {Bus};
		\draw[<->] (cpu) -- ++(0,-2);
		\draw[<->] (memory) -- ++(0,-2);

		% Input/Output below bus
		\node[draw, rectangle, minimum width=0.7cm, minimum height=0.7cm] (io) at (2, -3) {\textbf{I/O}};
		\draw[<->] (io) -- (2,-2);

		% Keyboard and mouse below I/O
		\node (keyboard) at (1, -4) {Tastiera};
		\node (mouse) at (3, -4) {Mouse};
		\draw[->] (keyboard) -- (io);
		\draw[->] (mouse) -- (io);


	\end{tikzpicture}
\end{figure}

\subsection{Caratteristiche}
Le istruzioni hanno bisogno di un'operazione che permetta di effettuare dei salti,
in modo da poter implementare i cicli e le strutture di controllo. Inoltre le istruzioni
devono essere eseugite in sequenza (un'istruzione alla volta).

\subsection{CPU}
Ogni processore ha un'set di istruzioni diverso in base all'architettura,
questo set di istruzioni è chiamato \textbf{ISA} (Instruction Set Architecture).
\textbf{Assembly} è un linguaggio di programmazione che permette di scrivere programmi
in base all'ISA del processore e questo linguaggio viene tradotto in linguaggio binario
attraverso un \textbf{assembler}. In questo corso viene usata l'architettura x86 (80x86).

\subsubsection{Modello semplificato}
Per rappresentare il funzionamento di un processore si può usare un modello semplificato
rappresentato ad alto livello. Questo modello è composto da:
\begin{itemize}
	\item \textbf{Central Processing Unit (CPU)}: esegue le istruzioni
	\item \textbf{Control Unit (CU)}: controlla il flusso delle istruzioni
	\item \textbf{Bus Dati (BD)}: trasferisce i dati alla CPU
	\item \textbf{Bus Istruzioni (BI)}: trasferisce le istruzioni alla CPU
	\item \textbf{Bus di Controllo (BC)}: trasferisce i segnali di controllo
	\item \textbf{Memory Address Register (MAR)}: contiene l'indirizzo di memoria da leggere
	\item \textbf{Memory Data Register (MDR)}: contiene i dati letti dalla memoria
	\item \textbf{Program Counter (PC)}: tiene conto dell'indirizzo dell'istruzione da eseguire
	\item \textbf{Instruction Register (IR)}: contiene l'istruzione corrente
	\item \textbf{Program Status Word (PSW)}: contiene i flag del processore (es. zero, carry, overflow).
	      È come se fosse un array in cui ad ogni indice corrisponde un flag per ogni operazione.
	\item \textbf{Register File}: contiene i registri del processore (es. EAX, EBX, ECX, EDX, ESI, EDI, ESP, EBP)
	\item \textbf{Arithmetic Logic Unit (ALU)}: esegue le operazioni aritmetiche e logiche
\end{itemize}
\begin{figure}[H]
	\centering
	\begin{tikzpicture}[scale=1.5]
		\draw (0,0) rectangle (4,4);
		\node[above left, scale=0.7] at (4,0) {CPU};

		\draw (2,2) rectangle (4,4);
		\node[above left, scale=0.7] at (3.4,2) {CU};

		\node[draw, rectangle, align=center, scale=0.8, minimum width=1cm, minimum height=0.8cm] (pc) at (2.4, 2.35) {PC};
		\node[draw, rectangle, align=center, scale=0.8, minimum width=1cm, minimum height=0.8cm] (ir) at (2.4, 2.95) {IR};
		\node[draw, rectangle, align=center, scale=0.8, minimum width=1cm, minimum height=0.5cm] (psw) at (3.4, 3.55) {PSW};

		% Bus Istruzioni
		\draw (-0.5,0) -- (-0.5,4) node[above, scale=0.7] {BI};

		% Bus Dati
		\draw (-1,0) -- (-1,4) node[above, scale=0.7] {BD};

		% Bus di controllo
		\draw (4.5,0) -- (4.5,4) node[above, scale=0.7] {BC};

		% MAR (Memory Address Register)
		\node[draw, rectangle, align=center, scale=0.8, minimum width=0.5cm, minimum height=0.5cm] (mar) at (0.5, 3) {M\\A\\R};
		\draw[latex-latex] (mar) -- (-0.5,3);

		% MDR (Memory Data Register)
		\node[draw, rectangle, align=center, scale=0.8, minimum width=0.5cm, minimum height=0.5cm] (mdr) at (0.5, 1) {M\\D\\R};
		\draw[latex-latex] (mdr) -- (-1,1);

		\draw[latex-latex] (4,3) -- (4.5,3);

		% Register file
		\draw (1,0.4) rectangle (2,1.6);
		\draw (1,0.6) -- (2,0.6);
		\draw (1,0.8) -- (2,0.8);
		\draw (1,1) -- (2,1);
		\draw (1,1.2) -- (2,1.2);
		\draw (1,1.4) -- (2,1.4);

		\node[below left, xshift=8, scale=0.7] at (1.82,0.4) {Register File};

		% ALU
		\draw (2.7,0.5) -- (3.3,0.5) -- (3.5,1.5) -- (3.2,1.5) -- (3,1.2) -- (2.8,1.5) -- (2.5,1.5) -- cycle;
		\node[above, scale=0.6] at (3,0.5) {ALU};

		% Collegamenti
		\draw[latex-] (2.6,1.5) -- ++(0,0.2) -- ++(-0.8,0) -- ++(0,-0.1);
		\draw[latex-] (3.4, 1.5) -- ++(0,0.4) -- ++(-2.2,0) -- ++(0,-0.3);
		\draw[-latex] (3.4,1) -- ++(0.4,0) -- ++(0,2) -- ++(-0.2,0) -| (psw);
		\draw[-latex] (3,0.5) -- ++(0,-0.3) -- ++(-0.5,0) -- ++(0,0.3) -- ++(-0.5,0);
		\draw[-latex] (2.3,2) -- ++(0,-1) -- ++(0.3,0);
	\end{tikzpicture}
	\caption{Struttura di un processore}
\end{figure}

\noindent Il flusso di esecuzione delle istruzioni è il seguente:
\begin{itemize}
	\item \textbf{Fetch}: CU legge l'istruzione dalla memoria
	\item \textbf{Decode}: CU decodifica l'istruzione
	\item \textbf{Execute}: ALU esegue l'istruzione
\end{itemize}

\begin{figure}[H]
	\centering
	\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=3cm,
			thick,main node/.style={circle,draw,font=\sffamily\Large\bfseries}]

		\node[main node] (1) {\footnotesize Fetch};
		\node[main node] (2) [right of=1] {\footnotesize Decode};
		\node[main node] (3) [right of=2] {\footnotesize Execute};

		\path[every node/.style={font=\sffamily\small}]
		(1) edge [bend left] node {} (2)
		(2) edge [bend left] node {} (3)
		(3) edge [bend left] node {} (1);
	\end{tikzpicture}
	\caption{Flusso di esecuzione delle istruzioni}
\end{figure}

\subsection{Modello concreto (LC-3)}
L'LC-3 è un processore Turing complete, ovvero può eseguire qualsiasi programma. È un
processore che nasce per motivi didattici, molto semplice e permette di capire come
funziona un processore. L'LC-3 è composto da:
\begin{itemize}
	\item \textbf{Memoria}:
	      \begin{itemize}
		      \item \textbf{MAR}: Memory Address Register, contiene l'indirizzo di memoria da leggere
		      \item \textbf{MDR}: Memory Data Register, contiene i dati letti dalla memoria
	      \end{itemize}
	\item \textbf{Processing Unit}:
	      \begin{itemize}
		      \item \textbf{ALU}
		      \item \textbf{Registri}: 8 registri da 16 bit
	      \end{itemize}
	\item \textbf{Input}:
	      \begin{itemize}
		      \item \textbf{Tastiera}
		      \item \textbf{Mouse}
		      \item \textbf{Scanner}
		      \item \textbf{Disco}
	      \end{itemize}
	\item \textbf{Output}:
	      \begin{itemize}
		      \item \textbf{Monitor}
		      \item \textbf{Stampante}
		      \item \textbf{LED}
		      \item \textbf{Disco}
	      \end{itemize}
	      L'imput e l'output non vengono gestiti direttamente dai dispositivi, ma vengono
	      gestiti dalla memoria.
	\item \textbf{Control Unit}:
	      \begin{itemize}
		      \item \textbf{PC}: Program Counter, contiene l'indirizzo dell'istruzione da eseguire
		      \item \textbf{IR}: Instruction Register, contiene l'istruzione corrente
	      \end{itemize}
\end{itemize}

\subsubsection{Memoria}
\( 2^16 \times 16 \) celle di memoria. Per interfacciarsi con la memoria si usa la
\texttt{LOAD} e la \texttt{STORE}. Questo viene fatto:
\begin{itemize}
	\item \textbf{LOAD}: per caricare una cella \( (A) \):
	      \begin{enumerate}
		      \item Scrive l'indirizzo della cella da leggere nel MAR
		      \item
		            TODO
	      \end{enumerate}
\end{itemize}

\subsubsection{Processing Unit}
Questa unità può eseguire 3 operazioni:
\begin{itemize}
	\item \textbf{ADD}
	\item \textbf{AND}
	\item \textbf{NOT}
\end{itemize}

\vspace{1em}
\noindent I registri sono 8 e vanno da \( R0, \ldots, R7 \) ognuno da 16 bit. La dimensione
della parola del processore è di 16 bit. Anche le istruzioni sono di 16 bit.

\subsubsection{Input e Output}
Ci sono 2 tipi di periferiche:
\begin{itemize}
	\item \textbf{A caratteri}: tastiera, mouse, scanner. Sono periferiche che comunicano
	      con il processore inviando un carattere alla volta.
	\item \textbf{A blocchi}: monitor, stampante, disco. Sono periferiche che comunicano
	      con il processore inviando un blocco di dati alla volta.
\end{itemize}
L'input e l'output viene gestito direttamente dalla CPU, quindi non c'è nessun componente
esterno che lo fa.
\begin{itemize}
	\item Per gestire la tastiera ci sono 2 registri:
	      \begin{itemize}
		      \item \textbf{KBDR}: Keyboard Data Register, contiene il carattere letto dalla tastiera
		      \item \textbf{KBSR}: Keyboard Status Register, contiene lo stato della tastiera
	      \end{itemize}
	\item Per gestire il monitor ci sono 2 registri:
	      \begin{itemize}
		      \item \textbf{DDR}: Display Data Register, contiene il carattere da scrivere sul monitor
		      \item \textbf{DSR}: Display Status Register, contiene lo stato del monitor
	      \end{itemize}
\end{itemize}

\subsubsection{Processazione delle istruzioni}
Il loop di esecuzione delle istruzioni è il seguente:
\begin{itemize}
	\item \textbf{Fetch}: legge l'istruzione dalla memoria
	\item \textbf{Decode}: decodifica l'istruzione
	\item \textbf{Evaluate address}: calcola l'indirizzo dell'operando
	\item \textbf{Fetch operands}: legge gli operandi dalla memoria
	\item \textbf{Execute}: esegue l'istruzione
	\item \textbf{Store result}: scrive il risultato nella memoria
\end{itemize}

\subsubsection{Istruzioni}
Le istruzioni sono di 16 bit e sono specificate nel seguente modo:
\begin{itemize}
	\item \textbf{opcode}: specifica l'operazione da eseguire
	\item \textbf{operands}: dati o indirizzi su cui operare
\end{itemize}
Ogni istruzione è codificata come una sequenza di bit ed è il componente più piccolo
e non interrompibile del sistema.

\vspace{1em}
\noindent La specifica di come sono fatte le istruzioni è chiamata \textbf{ISA}
(Instruction Set Architecture).

\subsubsection{Operazioni}
\begin{itemize}
  \item \textbf{Operazioni di calcolo}:
    \begin{itemize}
      \item \textbf{ADD}: somma due numeri
      \item \textbf{AND}: effettua l'AND bit a bit tra due numeri
      \item \textbf{NOT}: effettua il NOT bit a bit di un numero
    \end{itemize}
  \item \textbf{Operazioni di movimento dei dati}:
    \begin{itemize}
      \item \textbf{LD}
      \item \textbf{LDI}
      \item \textbf{LDR}
      \item \textbf{LEA}
      \item \textbf{ST}
      \item \textbf{STR}
      \item \textbf{STI} 
    \end{itemize}
  \item \textbf{Operazioni di controllo}:

    \noindent Sono gestite da 3 flag:
    \begin{itemize}
      \item \textbf{N}: negativo
      \item \textbf{Z}: zero
      \item \textbf{P}: positivo
    \end{itemize}
    Le operazioni sono:
    \begin{itemize}
      \item \textbf{BR}
      \item \textbf{JMP}
      \item \textbf{JSR}
      \item \textbf{JSRR}
      \item \textbf{RTI}
      \item \textbf{TRAP}
    \end{itemize}
\end{itemize}

I tipi di dato sono gestiti come 16 bit codificati in complemento a 2.

\subsubsection{Metodi di indirizzamento}
\begin{itemize}
  \item \textbf{Immediate}: l'operando è un valore costante
  \item \textbf{Register}: l'operando è un registro
  \item \textbf{PC-relative}: l'operando è un offset rispetto al PC
  \item \textbf{Indirect}: l'operando è un indirizzo in memoria
  \item \textbf{Base+offset}: l'operando è un indirizzo in memoria calcolato come somma di un registro e un offset
\end{itemize}

\section{Assembly (Intel x86)}
\subsection{Codifica}
Ogni istruzione è codificata nel seguente modo:

\begin{figure}[H]
	\centering
	\begin{tikzpicture}
		% Opcode
		\draw (0,0) rectangle (1.5,1);
		\node at (0.75,0.5) {Opcode};

		% Metodi di indirizzamento
		\draw (1.8,0) -- (1.8,1);
		\node[align=center, scale=0.7] at (1.65,0.5) {M\\I};

		% Source
		\draw (1.5,0) rectangle (3.6,1);
		\node at (2.55,0.5) {Source};

		% Metodi di indirizzamento
		\draw (3.3,0) -- (3.3,1);
		\node[align=center, scale=0.7] at (3.45,0.5) {M\\I};

		% Destination
		\draw (3.6,0) rectangle (5.6,1);
		\node at (4.6,0.5) {Destination};

	\end{tikzpicture}
\end{figure}

\subsection{Istruzioni}
\subsubsection{Istruzioni di inizializzazione}
\begin{itemize}
	\item \textbf{\texttt{MOVL <source> <destination>}}: copia il contenuto di un registro (o costante) in un altro.
	      Questa istruzione di solito viene utilizzata per spostare i valori dalla memoria ai
	      registri e viceversa, in modo da poter effettuare operazioni solo su dati presenti
	      nei registri e non direttamente in memoria, questo rende l'esecuzione più efficiente.
	\item \textbf{\texttt{NOP}}: non fa nulla e occupa solo un byte. La sua utilità è quella
	      di "riempire i buchi", cioè delle zone di memoria non occupate da nessuna istruzione.
\end{itemize}

\subsubsection{Istruzioni aritmetiche}
\begin{itemize}
	\item \textbf{\texttt{ADDL <source> <destination>}}: somma il contenuto di due registri (o costante).
	      Siccome sono disponibili solo 2 parametri, il risultato viene salvato nel secondo parametro
	      perchè viene visto sia come sorgente che destinazione per evitare di aggiungerne un terzo.
	\item \textbf{\texttt{SUBL <source> <destination>}}: sottrae il contenuto di due registri (o costante)
	\item \textbf{\texttt{MULL <source> <destination>}}: moltiplica il contenuto di due registri (o costante)
	\item \textbf{\texttt{INC <source>}}: incrementa il contenuto di un registro (o costante) di 1
	\item \textbf{\texttt{DEC <source>}}: decrementa il contenuto di un registro (o costante) di 1
\end{itemize}

\subsubsection{Istruzioni logiche}

\begin{itemize}
	\item \textbf{\texttt{CMPL <source> <destination>}}: confronta il contenuto di due registri (o costanti) e
	      modifica il flag \textbf{\texttt{PSW}} in base al risultato del confronto.
\end{itemize}

\subsubsection{Istruzioni di salto}
Se il salto è \textbf{assoluto} l'indirizzo fa riferimento alla memoria diretta, mentre se il salto è
\textbf{relativo} l'indirizzo è relativo al Program Counter.
\begin{itemize}
	\item \textbf{\texttt{JMP <etichetta>}}: salta all'istruzione con etichetta
	\item \textbf{\texttt{JE <etichetta>}}: salta all'istruzione con etichetta se i flag sono settati in modo che i due operandi siano uguali
	\item \textbf{\texttt{JNE <etichetta>}}: salta all'istruzione con etichetta se i flag sono settati in modo che i due operandi siano diversi
	\item \textbf{\texttt{JG <etichetta>}}: salta all'istruzione con etichetta se i flag sono settati in modo che il primo operando sia maggiore del secondo
	\item \textbf{\texttt{JGE <etichetta>}}: salta all'istruzione con etichetta se i flag sono settati in modo che il primo operando sia maggiore o uguale del secondo
	\item \textbf{\texttt{JL <etichetta>}}: salta all'istruzione con etichetta se i flag sono settati in modo che il primo operando sia minore del secondo
	\item \textbf{\texttt{JLE <etichetta>}}: salta all'istruzione con etichetta se i flag sono settati in modo che il primo operando sia minore o uguale del secondo
\end{itemize}
Comparando e poi utilizzando i salti si possono implementare le strutture di controllo come i cicli e le condizioni.
Nell'etichetta si può inserire un'indirizzo di memoria assoluto che permette di saltare a quell'indirizzo,
questo però non è molto utile perchè il programma potrebbe essere caricato in un'area diversa della memoria.

\subsubsection{Istruzioni di gestione dello Stack}
\begin{itemize}
	\item \textbf{\texttt{PUSHL <source>}}: inserisce il contenuto di un registro (o costante) nello stack
	\item \textbf{\texttt{POPL <destination>}}: estrae il contenuto dello stack e lo mette in un registro (o costante)
	\item \textbf{\texttt{CALL <etichetta>}}: salva l'indirizzo successivo al Program Counter nello stack e salta all'istruzione con etichetta
\end{itemize}

\subsubsection{Metodi di indirizzamento}
I metodi di indirizzamento (MI) sono diversi modi per accedere ai dati in memoria, i
più comuni sono:
\begin{itemize}
	\item \textbf{Registro}: Un'istruzione può accedere direttamente ai registri
	      ad esempio: \texttt{MOVL \%EAX, \%EBX}
	\item \textbf{Immediato}: Un'istruzione può accedere direttamente ai dati
	      ad esempio: \texttt{MOVL \$10, \%EBX}
	\item \textbf{Assoluto}: Un'istruzione può accedere direttamente ai dati
	      ad esempio: \texttt{MOVL DATO, \%EBX}\\
	      dove \texttt{DATO} è un'etichetta che punta ad un'indirizzo di memoria
	\item \textbf{Indiretto Registro}: Un'istruzione può contenere un registro che punta ad un altro registro
	      ad esempio: \texttt{MOVL (\%EAX), \%EBX}
	\item \textbf{Indiretto Registro con Spiazzamento}: Un'istruzione può mettere un offset
	      rispetto al registro contenuto nell'istruzione
	      ad esempio: \texttt{MOVL \$8(\%EAX), \%EBX}
\end{itemize}

\noindent Non tutte le istruzioni ammettono tutti i metodi di indirizzamento e alcuni metodi di indirizzamento
possono essere usati solo con alcune istruzioni.

\subsection{Esempi}
Un esempio di codice in C è il seguente:
\begin{lstlisting}[language=C]
  ...
  int a; // INDA (etichetta che punta ad un indirizzo di memoria con valore intero)
  int b; // INDB
  int c; // INDB
  ...
  a = 5; // %EAX
  b = 10; // %EBX

  if (a > b) {
    c = a - b; // %ECX
  } else { // ELSE
    c = a + b;
  }
  \end{lstlisting}

La traduzione in assembly è la seguente:
\begin{lstlisting}[language={[x86masm]Assembler}]
  MOVL INDA, %EAX // Ridondante
  MOVL $5, %EAX
  MOVL INDB, %EBX // Ridondante
  MOVL $10, %EBX
  MOVL %EAX, %ECX
  COMPL %EAX, %EBX
  JLE ELSE
  SUBL %ECX, %EAX
  JMP ENDIF
  ELSE:
  ADDL %EBX, %ECX
  ENDIF:
\end{lstlisting}

\noindent Un altro esempio di un for loop in C:
\begin{lstlisting}[language=C]
  for (int i = 0; i < 10; i++) { // int i; %EDX
    ...
  }
\end{lstlisting}

\noindent La traduzione in assembly è la seguente:
\begin{lstlisting}[language={[x86masm]Assembler}]
  MOVL $0, %EDX
  FOR:
  COMPL $10, %EDX
  JE ENDFOR
  ...
  INC %EDX
  JMP FOR
  ENDFOR:
\end{lstlisting}

\subsection{File assembly}
Un file assembly ha estensione \texttt{.s} e può contenere diverse sezioni:
\begin{itemize}
	\item \textbf{.section .data}: contiene le variabili globali e le costanti
	      \begin{lstlisting}[language={[x86masm]Assembler}]
  .section .data
  hello:
    .ascii "Hello, world!\n" ; Dichiarazione di una stringa costante

  hello_len:
    .long . - hello ; Lunghezza della stringa (posizione corrente (.) - posizione iniziale)
  \end{lstlisting}

	\item \textbf{.section .text}: contiene il codice assembly composto da istruzioni, etichette
	      e sottoprogrammi
	      \begin{lstlisting}[language={[x86masm]Assembler}]
  .section .text
  .global _start ; Nome convenzionale del punto di inizio del programma
  _start:
    movl ...
    ...
  \end{lstlisting}

	\item \textbf{.section .bss}: contiene le variabili globali non inizializzate (spazio da riservare)
\end{itemize}

\subsection{Compilazione}
Per compilare un file assembly si compiono i seguenti passi:
\begin{enumerate}
	\item \textbf{Compilazione}: si compila il file assembly con il comando \texttt{as} che
	      crea un file binario (\texttt{.o}) contenente
	      l'implementazione di ogni singolo file.
	\item \textbf{Linking}: si uniscono i file binari con il comando \texttt{ld} che crea un file eseguibile
	      a partire dai file binari.
	\item \textbf{Esecuzione}: si rende eseguibile il file e si esegue con il comando \\\texttt{./<nomefile>}
\end{enumerate}


\section{Memoria}
La memoria è una lista indicizzata di celle, a cui ognuna è associata un indirizzo.
La memoria è composta da due parti principali:
\begin{itemize}
	\item \textbf{Codice}: contiene le istruzioni
	\item \textbf{Dati statici}: contiene i dati
\end{itemize}

\noindent Non si può sapere a priori dove verrà caricato il programma in memoria, quindi
è necessario utilizzare lo spostamento relativo per accedere ai dati e alle istruzioni.

\begin{figure}[H]
	\centering
	\begin{tikzpicture}
		\draw (0,0) rectangle (2,1);
		\node at (1,0.5) {Codice};

		\draw (0,0) rectangle (2,-2);
		\node at (1,-1) {Istruzioni};

		\draw (0,-2) rectangle (2,-4);
		\node[align=center] at (1,-3) {Dati\\statici};

		\draw[<-] (0,-0.2) -- ++(-0.5,0) node[left] {Program Counter};
	\end{tikzpicture}
	\caption{Struttura della memoria}
\end{figure}

\begin{figure}[H]
	\begin{define}
		\textbf{Footprint}: è l'area di memoria occupata da un programma:
		\begin{itemize}
			\item \textbf{L}: 32 bit
			\item \textbf{V}: 16 bit
			\item \textbf{B}: 8 bit
		\end{itemize}
	\end{define}
\end{figure}

\subsection{Memoria dinamica}
La memoria dinamica è composta da due parti principali:
\begin{itemize}
	\item \textbf{Heap}: contiene le variabili allocate dinamicamente e ha una dimensione variabile
	\item \textbf{Stack}: contiene le variabili locali e i parametri delle funzioni. Ha una dimensione fissa
	      e limitata. Lo stack cresce con la modalità \textbf{LIFO} (Last In First Out), cioè l'ultimo
	      elemento inserito è il primo ad essere estratto e nell'architettura x86 cresce verso l'alto.
	      Lo stack è composta anche da 2 puntatori:
	      \begin{itemize}
		      \item \textbf{ESP} (Extended Stack Pointer): punta all'ultimo elemento inserito nello stack
		      \item \textbf{EBP} (Extended Base Pointer): punta alla base dello stack
	      \end{itemize}
\end{itemize}

\begin{figure}[H]
	\centering
	\begin{tikzpicture}
		\draw (0,0) rectangle (2,1);
		\node[align=center] at (1,0.5) {Dati\\Statici};

		\draw (0,0) rectangle (2,-2);
		\node[align=center] at (1,-1) {Variabili\\dinamiche};

		\draw (0,-2) rectangle (2,-4.1);
		\node at (1,-2.3) {Stack};

		\draw (0,-2.6) -- (2,-2.6) node[midway, below, yshift=-1, scale=0.8] {...};
		\draw (0,-2.9) -- (2,-2.9) node[midway, below, yshift=1, scale=0.8] {b};
		\draw (0,-3.2) -- (2,-3.2) node[midway, below, yshift=1, scale=0.8] {a};
		\draw (0,-3.5) -- (2,-3.5) node[midway, below, yshift=1, scale=0.8] {y};
		\draw (0,-3.8) -- (2,-3.8) node[midway, below, yshift=1, scale=0.8] {x};


		\draw[<-] (0,-3.2) -- ++(-0.5,0) node[left] {ESP};
		\draw[<-] (0,-3.8) -- ++(-0.5,0) node[left] {EBP};
	\end{tikzpicture}
	\caption{Struttura della memoria}
\end{figure}

\noindent Per gestire i dati nello stack si utilizzano le seguenti istruzioni:
\begin{itemize}
	\item \textbf{\texttt{PUSHL <source>}}: inserisce il contenuto di un registro (o costante) nello stack
	\item \textbf{\texttt{POPL <destination>}}: estrae il contenuto dello stack e lo mette in un registro (o costante)
\end{itemize}

\subsection{Richiamare una funzione}
Per richiamare uan funzione bisogna far saltare il Program Counter all'indirizzo della funzione
e poi salvare l'indirizzo successivo nello stack. Per fare ciò si utilizza l'istruzione \texttt{CALL}.
\begin{itemize}
	\item \textbf{\texttt{CALL <etichetta>}}: salva l'indirizzo successivo al Program Counter nello stack e salta all'istruzione con etichetta.
	      Quando la funzione termina, per tornare al punto di chiamata si utilizza l'istruzione \texttt{RET}.
	\item \textbf{\texttt{RET}}: estrae l'indirizzo successivo al Program Counter dallo stack e salta a quell'indirizzo (torna al punto di chiamata).
\end{itemize}

Per recuperare i dati in memoria si utilizza l'istruzione \texttt{LEAL} (Load Effective Address):
\begin{itemize}
	\item \textbf{\texttt{LEAL <source>, <destination>}}: prende l'indirizzo di memoria in cui è stato salvato qualcosa
	      e lo mette in un registro
\end{itemize}

\subsection{Struttura dettagliata della CPU}
Di seguito è riportato uno schema più dettagliato dei componenti della CPU
in modo da capire come vengono eseguite le istruzioni.
\begin{figure}[H]
	\centering
	\begin{tikzpicture}[scale=1.5]
		\draw (-1,-3) rectangle (3.5,5.4);
		\node[above left] at (3.5,-3) {CPU};

		\draw (2,2) rectangle (3,3);
		\node[above left, scale=0.7] at (2.4,2) {CU};
		\draw[latex-latex] (3,2.5) -- (4,2.5);

		\draw[-latex, dashed] (2.2,3) -- ++(0,0.5) node[above, scale=0.7] {$PC_{in}$};
		\draw[-latex, dashed] (2.4,3) -- ++(0,0.5);
		\draw[-latex, dashed] (2.6,3) -- ++(0,0.5);
		\draw[-latex, dashed] (2.8,3) -- ++(0,0.5) node[above, scale=0.7, xshift=8] {$PC_{out}$};

		\node[draw, scale=0.7] at (2.7,2.8) {PSW};

		\node[draw, scale=1] at (2.5,1.5) (ir) {IR};
		\draw[-latex] (ir) -- ++(0,0.5);
		\draw[latex-] (ir) -- ++(-1,0);


		\node[draw, rectangle, align=center, scale=0.8, minimum width=1.3cm, minimum height=0.8cm]
		(pc) at (0.8, 3.85) {PC};
		\draw (pc.west) -- ++(0,0.15) -- ++(0.15, -0.15) -- ++(-0.15,-0.15);

		% Tri state buffer
		\draw (1.2,3.3) circle (0.1) node (tristate-buffer) {};
		\draw (1.2,3.3) circle (0.1) node[below, yshift=-15, align=center, scale=0.5] {Tri-state\\buffer};
		\draw (1.2,3.3) -- ++(0.07,0.07);
		\draw (1.2,3.3) -- ++(-0.07,-0.07);
		\draw (1.2,3.3) -- ++(0.07,-0.07);
		\draw (1.2,3.3) -- ++(-0.07,0.07);
		% ----------------

		\draw[latex-] (tristate-buffer) -- ++(0,-0.3) -- ++(-0.5,0) node[left, scale=0.7]
		{$PC_{out}$};

		% Multiplexer 2 to 1
		\begin{scope}[shift={(0.67,4.5)}, scale=0.5]
			\draw (0,0) node (mux1-0) {1};
			\draw (0.5,0) node (mux1-1) {0};
			\draw (0.0,0.2) node (mux1-i0) {};
			\draw (0.5,0.2) node (mux1-i1) {};
			\draw (-0.3,0) node (mux1-s) {};
			\draw (0.25,-0.18) node (mux1-o) {};
			\draw (-0.5,0.3) -- ++(1.5,0) -- ++(-0.25, -0.6) -- ++(-1,0) -- ++(-0.25,0.6) -- (-0.5,0.3);
		\end{scope}
		\draw[-latex] (mux1-o) -- (pc);

		\draw[-latex] (pc.south) -- ++(0,-0.3) |- (tristate-buffer);
		\draw[-latex] (tristate-buffer) -- ++(0.3,0);
		\draw[-latex] (0.8,3.5) -- ++(0.5,0) -- ++(0,1.4) -| (mux1-i1);
		\draw[latex-] (mux1-i0) -- ++(0,0.5) -- ++(0.83,0);
		\draw[latex-] (mux1-s) -- ++(-0.4,0) node[left, scale=0.7] {$PC_{in}$};

		% ALU
		\begin{scope}[shift={(-2.5,-0.5)}]
			\draw (2.7,0.5) -- (3.3,0.5) -- (3.5,1.5) -- (3.2,1.5) -- (3,1.2) -- (2.8,1.5) -- (2.5,1.5) -- cycle;
			\node[above, scale=0.6] at (3,0.5) {ALU};
		\end{scope}

		% Multiplexer 4 to 1
		\begin{scope}[shift={(0,4.5)}, scale=0.5]
			\draw (-0.7,-6) node (mux4-0) {00};
			\draw (0,-6) node (mux4-1) {01};
			\draw (0.7,-6) node (mux4-2) {10};
			\draw (1.4,-6) node[scale=0.8] () {$\ldots$};
			\draw (1.4,-5.87) node (mux4-3) {};
			\draw (-0.7,-5.8) node (mux4-i0) {};
			\draw (0,-5.8) node (mux4-i1) {};
			\draw (0.7,-5.8) node (mux4-i2) {};
			\draw (1.4,-5.8) node (mux4-i3) {};
			\draw (1.7,-6) node (mux4-s) {};
			\draw (0.25,-6.18) node (mux4-o) {};
			\draw (-1.3,-5.7) -- ++(3.3,0) -- ++(-0.25, -0.6) -- ++(-2.8,0) -- ++(-0.25,0.6) -- cycle;
		\end{scope}

		% Register y
		\begin{scope}[shift={(0.1,3.5)}]
			\draw (0.25,-1) node[rectangle ,draw, minimum width=2cm, minimum height=0.7cm, scale=0.7] (y) {y};
			\draw (y.west) -- ++(0,0.15) -- ++(0.15, -0.15) -- ++(-0.15,-0.15);
		\end{scope}

		\draw[-latex] (y.east) -- ++(0.7,0);

		% Mux to alu
		\draw[latex-] (mux4-0) -- ++(0,0.4) node[above, scale=0.7] {0};
		\draw[latex-] (mux4-1) -- ++(0,0.4) node[above, scale=0.7] {4};
		\draw[latex-] (mux4-2) -- (y);
		\draw[latex-] (mux4-3) -- ++(0,0.34) node[above, scale=0.7] {cost};
		\draw[latex-] (mux4-s) -- ++(0.4,0) node[above, scale=0.7] {select};

		\draw[latex-] (0.15,1) -- ++(0,0.35);
		\draw[latex-] (0.85,1) -- ++(0,0.2) -- ++(0.65,0);

		% Alu in out
		\draw[-latex] (0.5,0) -- ++(0,-0.33);

		\draw[latex-] (0.1,0.4) -- ++(-0.5,0) node[left, align=center, scale=0.5] {ADD\\SUB\\MUL\\CR\\$\ldots$};

		% Register z
		\begin{scope}[shift={(0.25,0.5)}]
			\draw (0.25,-1) node[rectangle ,draw, minimum width=2cm, minimum height=0.7cm, scale=0.7] (z) {z};
			\draw (z.west) -- ++(0,0.15) -- ++(0.15, -0.15) -- ++(-0.15,-0.15);
		\end{scope}

		\draw[-latex] (z.east) -- ++(0.51,0);


		% MAR (Memory Address Register)
		\node[draw, rectangle, align=center, scale=0.8, minimum width=0.5cm, minimum height=0.5cm]
		(mdr) at (0.5, -2) {MDR};
		\draw[latex-latex] (mdr) -- ++(-2.5,0);
		\draw[latex-latex] (mdr) -- ++(1,0);

		% MDR (Memory Data Register)
		\node[draw, rectangle, align=center, scale=0.8, minimum width=0.5cm, minimum height=0.5cm]
		(mar) at (0.5, -1.5) {MAR};
		\draw[latex-latex] (mar) -- ++(-2,0);
		\draw[latex-] (mar) -- ++(1,0);

		% Register file
		\node[draw, scale=1] at (2.5,1.5) (ir) {IR};
		\draw (2, 0.8) rectangle (3, 1);
		\node[scale=0.7] at (2.5,0.9) {EAX};
		\draw (2, 0.6) rectangle (3, 0.8);
		\node[scale=0.7] at (2.5,0.7) {EBX};
		\draw (2, 0.4) rectangle (3, 0.6);
		\node[scale=0.7] at (2.5,0.5) {ECX};
		\draw (2, 0.2) rectangle (3, 0.4);
		\node[scale=0.7] at (2.5,0.3) {EDX};
		\draw (2, 0) rectangle (3, 0.2);
		\node[scale=0.7] at (2.5,0.1) {ESP};
		\draw (2, -0.2) rectangle (3, 0);
		\node[scale=0.7] at (2.5,-0.105) {Reg File};

		\draw[latex-latex] (2,0.4) -- ++(-0.5,0);

		% Bus CPU
		\draw (1.5,-3) -- (1.5,5.4) node[below right, scale=0.7, align=center] {Bus\\CPU};

		% Bus Istruzioni
		\draw (-1.5,-3) -- (-1.5,5.4) node[above, scale=0.7, align=center] {BI};

		% Bus Dati
		\draw (-2,-3) -- (-2,5.4) node[above, scale=0.7, align=center] {BD};

		% Bus di controllo
		\draw (4,-3) -- (4,5.4) node[above, scale=0.7, align=center] {BC};
	\end{tikzpicture}
	\caption{Schema della CPU}
\end{figure}

\noindent Da questo schema si possono notare le seguenti caratteristiche:
\begin{itemize}
	\item Nella gestione del Program Counter il segnale passa attraverso un \textbf{Buffer
		      Tri-State} che permette di disabilitare il segnale.
	\item Per mandare 2 valori alla ALU si utilizza un registro collegato ad un multiplexer
	      che permette di selezionare quale valore mandare alla ALU. Nel multiplexer sono
	      cablate delle costanti utili da passare alla ALU.
	\item Ogni indirizzo di memoria è gestito in \textbf{byte} indipendentemente.
	      Quindi per accedere a parole da 32 bit bisogna andare avanti di 4 byte, mentre
	      per accedere a parole da 64 bit bisogna andare avanti di 8 byte.
\end{itemize}

\section{Micro operazioni}
Le micro operazioni sono le operazioni elementari che la CPU esegue per eseguire
un'istruzione.

\begin{figure}[H]
	\begin{define}
		\textbf{CPI} (Clock Per Instruction): è il numero di cicli di clock necessari per
		eseguire un'istruzione. L'obiettivo è avere un CPI il più basso possibile.
	\end{define}
\end{figure}

\subsection{Esempi}
\begin{example}
	Andiamo ad analizzare la sequenza di micro operazioni (Fetch, Decode, Execute) per la
	seguente istruzione:
	\begin{center}
		\texttt{MOVL \%EAX, \%EBX}
	\end{center}

	\begin{enumerate}
		\item[F]
		      \begin{enumerate}
			      \item[1.] \( PC_{out},\; MAR_{in},\; READ ,\; SELECT_4,\; ADD,\; Z_{in}\) \\
			            Il Program Counter manda l'indirizzo di memoria in cui si trova l'istruzione da eseguire
			            al Memory Address Register e manda un segnale di lettura.

			            Il segnale di selezione 4 manda un segnale al multiplexer per selezionare il valore
			            da mandare alla ALU e il segnale di addizione manda un segnale alla ALU per sommare
			            4 all'indirizzo di memoria. Ciò vuol dire che l'indirizzo di memoria successivo è
			            l'indirizzo di memoria corrente + 1 word. Tutto ciò per incrementare il Program
			            Counter in modo da accedere all'istruzione successiva.

			      \item[2.] \( WMFC,\; Z_{out},\; PC_{in}\)  \\
			            \textbf{WMFC}(Wait for Memory Function to Complete): è un segnale che blocca il clock
			            successivo della CPU finchè il dato viene messo nel bus dati.

			            Siccome in questo ciclo di clock il bus non viene utilizzato viene sfruttato per
			            mandare il segnale di incremento al Program Counter.

			            Il segnale di lettura manda un segnale di attesa finchè il dato non viene messo nel bus dati.
			      \item[3.] \( MDR_{out},\; IR_{in} \) \\
			            Il Memory Data Register manda il dato letto dall'indirizzo di memoria all'Instruction Register.
		      \end{enumerate}

		\item[DE]
		      \begin{enumerate}
			      \item[4.] \( EAX_{out},\; EBX_{in},\; END \) \\
			            Il contenuto del registro EAX viene mandato in uscita e viene messo in ingresso
			            al registro EBX. Successivamente viene messo a 1 il segnale di fine che fa
			            ripartire il ciclo di Fetch-Decode-Execute.
		      \end{enumerate}
	\end{enumerate}
\end{example}
\begin{figure}[H]

\end{figure}

\begin{example}
	Istruzione:
	\begin{center}
		\texttt{MOVL (\%EAX), \%EBX}
	\end{center}

	\begin{enumerate}
		\item[F]
		      \begin{enumerate}
			      \item[1.] \( PC_{out},\; MAR_{in},\; READ ,\; SELECT_4,\; ADD,\; Z_{in}\)
			      \item[2.] \( WMFC,\; Z_{out},\; PC_{in}\)
			      \item[3.] \( MDR_{out},\; IR_{in} \)
		      \end{enumerate}
		\item[D]
		      \begin{enumerate}
			      \item[4.] \( EAX_{out},\; MAR_{in},\; READ \)
			      \item[5.] \( WMFC \)
		      \end{enumerate}
		\item[E]
		      \begin{enumerate}
			      \item[6.] \( MDR_{out},\; EBX_{in},\; END \)
		      \end{enumerate}
	\end{enumerate}
\end{example}

\begin{example}
	Istruzione:
	\begin{center}
		\texttt{ADDL \$4, \%ECX}
	\end{center}

	\noindent La costante 4 è già presente nell'Instruction Register, quindi non c'è bisogno di
	andare a leggerla dalla memoria.
	\begin{enumerate}
		\item[F]
		      \begin{enumerate}
			      \item[1.] \( PC_{out},\; MAR_{in},\; READ ,\; SELECT_4,\; ADD,\; Z_{in}\)
			      \item[2.] \( WMFC,\; Z_{out},\; PC_{in}\)
			      \item[3.] \( MDR_{out},\; IR_{in} \)
		      \end{enumerate}
		\item[DE]
		      \begin{enumerate}
			      \item[4.] \( OFFSET_{IR_{out}},\; y_{in} \) \\
			            L'offset dell'Instruction Register serve per prendere il pezzo in cui è situata
			            la costante 4
			      \item[5.] \( ECX_{out},\; SELECT_{y},\;ADD,\; Z_{in} \)
			      \item[6.] \( Z_{out},\; ECX_{in},\; END \)
		      \end{enumerate}
	\end{enumerate}
\end{example}

\begin{example}
	\begin{center}
		\texttt{JZ END} \quad (salto relativo)
	\end{center}

	\noindent Il valore dell'etichetta \texttt{END} è già calcolato dall'assembler e viene memorizzato
	nell'Instruction Register
	\begin{enumerate}
		\item [F]
		      \begin{enumerate}
			      \item[1.] \( PC_{out},\; MAR_{in},\; READ ,\; SELECT_4,\; ADD,\; Z_{in}\)
			      \item[2.] \( WMFC,\; Z_{out},\; PC_{in}\)
			      \item[3.] \( MDR_{out},\; IR_{in} \)
		      \end{enumerate}
		\item[DE]
		      \begin{enumerate}
			      \item[4.] (if ZERO == 0 END) \(,\; OFFSET_{IR_{out}},\; y_{in} \)\\
			            L'if e il resto vengono eseguiti insieme, sempre
			      \item[5.] \( PC_{out},\; SELECT_{y},\; ADD,\; Z_{in} \)
			      \item[6.] \( Z_{out},\; PC_{in},\; END \)
		      \end{enumerate}
	\end{enumerate}
\end{example}

\subsection{Struttura della Control Unit}
\noindent Per rappresentare i cicli di clock delle micro istruzioni si utilizza un
registro chiamato \textbf{Micro Program Counter} che indica la prossima micro istruzione
da eseguire. È un contatore con un segnale di reset che permette di far ripartire
l'esecuzione delle micro istruzioni. Questo registro viene poi collegato ad un decoder con 16 uscite che indica il tempo
del ciclo di clock. Se il segnale \( T_2 = 1 \) allora il segnale \( PC_{in} = 1 \),
quindi \( PC_{in} = T_2 \). È presente poi un decoder che parte dall'Istruction Register e ha in uscita tutte le istruzioni
\( I_n \). Si possono così realizzare tutte le equazioni in logica combinatoria, ad esempio:
\[
	END = (I_1 + I_2 + I_3 + \ldots) \cdot T_6 + I_3 \cdot T_4 \cdot \overline{ZERO}
\]
\begin{figure}[H]
	\centering
	\begin{tikzpicture}
		\draw (0,0) rectangle (4,4);
		\node[align=center] (logica-combinatoria) at (2,2) {Logica\\combinatoria};
		\draw[-latex] (0.3,0) -- ++(0,-0.5) node[below, scale=0.7] {$PC_{in}$};
		\draw[-latex] (1.15,0) -- ++(0,-0.5) node[below, scale=0.7] {$PC_{out}$};
		\draw[-latex] (2,0) -- ++(0,-0.5) node[below, xshift=2, scale=0.7] {$MAR_{in}$};
		\draw[-latex] (2.85,0) -- ++(0,-0.5) node[below, yshift=-3, scale=0.7] {$\ldots$};
		\draw[-latex] (3.7,0) -- ++(0,-0.5) node[below, scale=0.7] {$END$} --
		++(2,0) -- ++(0,5) |- (3,5.75);


		\draw (-1,0) rectangle (-0.5,4);
		\node[label={[label distance=0cm,text depth=-1ex,rotate=-90]right:Decoder}]
		at (-0.85,2.6) {};
		\draw[-latex] (-0.5,3.6) -- (0,3.6) node[midway, above, scale=0.7] {$I_1$};
		\draw[-latex] (-0.5,3.2) -- (0,3.2) node[midway, above, scale=0.7] {$I_2$};
		\draw[-latex] (-0.5,2.8) -- (0,2.8) node[midway, above, scale=0.7] {$I_3$};
		\draw[-latex] (-0.5,2.4) -- (0,2.4);
		\draw[-latex] (-0.5,2) -- (0,2);
		\draw[-latex] (-0.5,1.6) -- (0,1.6);
		\draw[-latex] (-0.5,1.2) -- (0,1.2);
		\draw[-latex] (-0.5,0.8) -- (0,0.8);
		\draw[-latex] (-0.5,0.4) -- (0,0.4) node[midway, above, scale=0.7] {$I_{16}$};

		\draw (-2,0) rectangle (-1.5,4);
		\node[label={[label distance=0cm,text depth=-1ex,rotate=-90]right:IR}]
		at (-1.86,2.3) {};
		\draw[-latex] (-1.5,2) -- (-1,2);

		\draw (4.5,0) rectangle (5,4);
		\node[label={[label distance=0cm,text depth=-1ex,rotate=90]right:PSW}]
		at (4.65,1.5) {};
		\draw[latex-] (4,2) -- (4.5,2);

		\draw (0.5, 4.5) rectangle (3.5, 5);
		\node[align=center] at (2,4.75) {Decoder};
		\draw[latex-] (1,4) -- (1,4.5) node[midway, left, scale=0.7] {$T_1$};
		\draw[latex-] (1.5,4) -- (1.5,4.5) node[midway, left, scale=0.7] {$T_2$};
		\draw[latex-] (2,4) -- (2,4.5) node[midway, left, scale=0.7] {$T_3$};
		\node[align=center, scale=0.6] at (2.3,4.25) {$\ldots$};
		\draw[latex-] (3,4) -- (3,4.5) node[midway, left, scale=0.7] {$T_{16}$};

		\draw (1, 5.5) rectangle (3, 6);
		\node at (2,5.75) (mpc) {MPC};
		\draw (1,5.9) -- ++(0.15, -0.15) -- ++(-0.15,-0.15);
		\draw[latex-] (1,5.75) -- ++(-0.5,0) node[left, scale=0.7] {CLK};
		\draw[-latex] (2,5.5) -- (2,5);
		\draw (1.9,5.23) -- ++(0.2,0.2) node[right, yshift=-3, scale=0.7] {4};
	\end{tikzpicture}
\end{figure}

\noindent Esiste una memoria che contiene tutte le micro istruzioni chiamata \textbf{Firmware},
ma \textbf{CPU cablate} in questo modo non si realizzano più.

\subsection{Esercizi}

\begin{exercise}
  Descrivere le micro operazioni per l'istruzione:
  \begin{center}
    Fetch
  \end{center}

  \begin{enumerate}
    \item[F]
      \begin{enumerate}
        \item[1.] \( PC_{out},\; MAR_{in},\; READ ,\; SELECT_4,\; ADD,\; Z_{in}\) \\
          Il Program Counter manda l'indirizzo di memoria in cui si trova l'istruzione da eseguire
          al Memory Address Register e manda un segnale di lettura.

          Il segnale di selezione 4 manda un segnale al multiplexer per selezionare il valore
          da mandare alla ALU e il segnale di addizione manda un segnale alla ALU per sommare
          4 all'indirizzo di memoria. Ciò vuol dire che l'indirizzo di memoria successivo è
          l'indirizzo di memoria corrente + 1 word. Tutto ciò per incrementare il Program
          Counter in modo da accedere all'istruzione successiva.

        \item[2.] \( Z_{out},\; PC_{in},\;WMFC \)  \\
          \textbf{WMFC}(Wait for Memory Function to Complete): è un segnale che blocca il clock
          successivo della CPU finchè il dato viene messo nel bus dati.

          Siccome in questo ciclo di clock il bus non viene utilizzato viene sfruttato per
          mandare il segnale di incremento al Program Counter.

          Il segnale di lettura manda un segnale di attesa finchè il dato non viene messo nel bus dati.
        \item[3.] \( MDR_{out},\; IR_{in} \) \\
          Il Memory Data Register manda il dato letto dall'indirizzo di memoria all'Instruction Register.
      \end{enumerate}
  \end{enumerate}
\end{exercise}

\begin{exercise}
  Descrivere le micro operazioni per l'istruzione:
  \begin{center}
    \texttt{INC \%EAX}
  \end{center}

  \begin{enumerate}
    \item[F]
      \begin{enumerate}
        \item[1.] \( PC_{out},\; MAR_{in},\; READ ,\; SELECT_4,\; ADD,\; Z_{in}\)
        \item[2.] \( Z_{out},\; PC_{in},\;WMFC \)
        \item[3.] \( MDR_{out},\; IR_{in} \)
      \end{enumerate}

    \item [DE]
      \begin{enumerate}
        \item[1.] \( EAX_{out},\; SELECT_0,\; CB,\; ADD,\; Z_{in} \)
        \item[2.] \( Z_{out},\; EAX_{in},\; END \) 
      \end{enumerate}
  \end{enumerate}
\end{exercise}

\begin{exercise}
  Descrivere le micro operazioni per l'istruzione:
  \begin{center}
    \texttt{INC var}
  \end{center}
  Assumo la variabile come un indirizzo immediato nell'istruzione. Si fa
  riferimento ad essa con \( IR_{imm\_field} \) 

  \begin{enumerate}
    \item[F]
      \begin{enumerate}
        \item[1.] \( PC_{out},\; MAR_{in},\; READ ,\; SELECT_4,\; ADD,\; Z_{in}\)
        \item[2.] \( Z_{out},\; PC_{in},\;WMFC \)
        \item[3.] \( MDR_{out},\; IR_{in} \)
      \end{enumerate}

    \item [DE]
      \begin{enumerate}
        \item[1.] \( IR_{imm\_field\_out},\; MAR_{in},\; READ ,\; WMFC \)
        \item[2.] \( MDR_{out},\; SELECT_0 ,\; CB ,\; ADD ,\; Z_{in} \)
        \item [3.] \( Z_{out} ,\; MDR_{in} ,\; WRITE ,\; WMFC ,\; END \) 
      \end{enumerate}
  \end{enumerate}
\end{exercise}

\begin{exercise}
  Descrivere le micro operazioni per l'istruzione:
  \begin{center}
    \texttt{CALL etichetta}
  \end{center}
  Dove etichetta è un indirizzo immediato, ma relativo al program counter 
  \( PC + IR_{imm\_field} \) 

  \begin{enumerate}
    \item[F]
      \begin{enumerate}
        \item[1.] \( PC_{out},\; MAR_{in},\; READ ,\; SELECT_4,\; ADD,\; Z_{in}\)
        \item[2.] \( Z_{out},\; PC_{in},\;WMFC \)
        \item[3.] \( MDR_{out},\; IR_{in} \)
      \end{enumerate}

    \item [DE]
      \begin{enumerate}
        \item[1.] \( ESP_{out} ,\; SELECT_4 ,\; SUB,\; Z_{in} \)
        \item[2.] \( Z_{out},\; MAR_{in} ,\; ESP_{in} \) 
        \item[3.] \( PC_{out} ,\; MDR_{in} ,\; WRITE ,\; V_{in}\) 
        \item[4.] \( IR_{imm\_field} ,\; SELECT_V, ADD ,\; Z_{in} ,\; WMFC \) 
        \item[5.] \( Z_{out} ,\; PC_{in} ,\; END\) 
      \end{enumerate}
  \end{enumerate}
\end{exercise}

\begin{exercise}
  Descrivere le micro operazioni per l'istruzione:
  \begin{center}
    \texttt{RETURN}
  \end{center}
  \begin{enumerate}
    \item[F]
      \begin{enumerate}
        \item[1.] \( PC_{out},\; MAR_{in},\; READ ,\; SELECT_4,\; ADD,\; Z_{in}\)
        \item[2.] \( Z_{out},\; PC_{in},\;WMFC \)
        \item[3.] \( MDR_{out},\; IR_{in} \)
      \end{enumerate}

    \item [DE]
      \begin{enumerate}
        \item[1.] \( ESP_{out} ,\; SELECT_4 ,\; ADD,\; Z_{in},\; MAR_{in},\; READ \)
        \item[3.] \( Z_{out},\; ESP_{in},\; EMFC \)
        \item[3.] \( MDR_{out}, PC_{in} \) 
      \end{enumerate}
  \end{enumerate}
\end{exercise}

\begin{exercise}
  Descrivere le micro operazioni per l'istruzione:
  \begin{center}
    \texttt{CALL (\%EAX, \%EBX)}
  \end{center}
  Viene fatta la call all'indirizzo ottenuto sommando EBX a EAX

  \begin{enumerate}
    \item[F]
      \begin{enumerate}
        \item[1.] \( PC_{out},\; MAR_{in},\; READ ,\; SELECT_4,\; ADD,\; Z_{in}\)
        \item[2.] \( Z_{out},\; PC_{in},\;WMFC \)
        \item[3.] \( MDR_{out},\; IR_{in} \)
      \end{enumerate}

    \item [DE]
      \begin{enumerate}
        \item[1.] \( ESP_{out} ,\; SELECT_4 ,\; SUB,\; Z_{in} \)
        \item[2.] \( Z_{out},\; MAR_{in} ,\; ESP_{in} \) 
        \item[6.] \( PC_{out} ,\; MDR_{in} ,\; WRITE \) 
        \item[3.] \( EAX_{out} ,\; V_{in} \)
        \item[4.] \( EBX_{out},\; SELECT_V,\; ADD ,\; Z_{in}, WMFC \) 
        \item[5.] \( Z_{out} ,\; PC_{in} ,\; END\) 
      \end{enumerate}
  \end{enumerate}
\end{exercise}

\section{Dispositivi di input e output}
\begin{figure}[H]
	\centering
	\begin{tikzpicture}
		% CPU
		\node[draw, rectangle, minimum width=2cm, minimum height=1.5cm] (cpu) at (0, 0) {\textbf{CPU}};
		% Memoria
		\node[draw, rectangle, align=center, minimum width=2cm, minimum height=1.5cm] (memory) at (4, 0) {\textbf{Memoria}\\\footnotesize Dati\\\footnotesize Istruzioni};

		% Bus
		\draw (-2,-2) -- (6.5,-2) node[right] {Bus};
		\draw[<->] (cpu) -- ++(0,-2);
		\draw[<->] (memory) -- ++(0,-2);

		% Input/Output below bus
		\node[draw, rectangle, minimum width=0.7cm, minimum height=0.7cm] (io) at (2, -3) {\textbf{I/O}};
		\draw[<->] (io) -- (2,-2);

		% Keyboard and mouse below I/O
		\node (keyboard) at (1, -4) {Tastiera};
		\node (mouse) at (3, -4) {Mouse};
		\draw[->] (keyboard) -- (io);
		\draw[->] (mouse) -- (io);
	\end{tikzpicture}
	\caption{Schema di un sistema con dispositivi di input e output}
\end{figure}

\noindent Per poter ottenere un'interazione con l'utente è necessario avere dei dispositivi
di input e output e a loro volta devono essere codificati per far corrispondere
l'intenzione dell'utente con l'azione del computer. La strutture del microcontrollore
input/output è composto da:
\begin{itemize}
	\item \textbf{Dato}: contiene i dati da inviare o ricevere
	\item \textbf{Stato}: contiene lo stato del dispositivo
	\item \textbf{MC}: contiene il microcontrollore del dispositivo
	\item \textbf{IntA/D}: contiene l'interfaccia di analogico/digitale
\end{itemize}
\begin{figure}[H]
	\centering
	\begin{tikzpicture}
		\draw (0,0) rectangle (4,4);
		\draw (0.5,2.5) rectangle (1.8,3.5) node[midway] {Dato};
		\draw (2.2,2.5) rectangle (3.5,3.5) node[midway] {Stato};
		\draw (1.5,1) rectangle (2.5,2) node[midway] {MC};
		\draw (0,0) rectangle (1,1) node[midway, scale=0.7] {IntA/D};
		\node at (4,0) [above left, scale=0.7] {I/O};
	\end{tikzpicture}
	\caption{Struttura del microcontrollore input/output}
\end{figure}

\noindent La CPU accede ai valori dei registri di input/outpit tramite degli indirizzi
che vengono riservati in un intervallo di memoria. Gli indirizzi di \texttt{Dato} e
\texttt{Stato} sono:
\begin{itemize}
	\item \texttt{IND DATA KEY} (Dato)
	\item \texttt{IND STATUS KEY} (Stato)
\end{itemize}
Questi indirizzi sono assegnati in fase di progettazione del sistema e sono fissi,
ma si possono anche cambiare in certe architetture.

\vspace{1em}
\noindent Ogni bit nel registro \texttt{status} ha un preciso significato, ad esempio
se vale 0 significa che nessun tasto è stato premuto, se vale 1 significa che un tasto
è stato premuto.

\vspace{1em}
\noindent Un esempio in assembly è il seguente:
\begin{lstlisting}[language={[x86masm]Assembler}]
 TEST_KEY:
  MOVL IND_STATUS_KEY, %EAX ; Carica lo stato della tastiera nel registro EAX
  CMPL $0, %EAX ; Compara il valore di EAX con 0
  JE TEST_KEY ; Se EAX = 0 allora salta a TEST_KEY
  MOV IND_DATA_KEY, %EBX ; Carica il tasto premuto nel registro EBX
  MOV %EBX, INDC ; Carica il tasto premuto nel registro C
\end{lstlisting}
\noindent La verifica di un dispositivo di input/output è un'operazione che viene detta
\textbf{polling}.

\vspace{1em}
\noindent Ogni volta che si vuole leggere un dato da un dispositivo di input/output si deve
effettuare una \textbf{SVC} (Supervisor Call) che permette di richiamare del pezzo
di codice al livello del sistema operativo che permette di effettuare diverse operazioni.

\subsection{Ottimizzazione}
Ogni operazione di lettura effettuata con il bus richiede circa 10 cicli di clock.
\begin{lstlisting}[language={[x86masm]Assembler}]
 TEST_KEY:
  MOVL IND_STATUS_KEY, %EAX ; 1 Read 1 Read Bus
  CMPL $0, %EAX ; 1 Read
  JE TEST_KEY ; 1 Read
  MOV IND_DATA_KEY, %EBX 
  MOV %EBX, INDC 
\end{lstlisting}
\noindent In totale si avranno \( 10 + 3 \) cicli di clock \( \approx 10 \). Con una
frequenza di \( 10GHz \) si avranno \( 10^9 clock/sec \). Visto che un umano può premere
un tasto al massimo 10 volte al secondo, si può dire che la frequenza di lettura è
troppo alta, quindi si sprecano cicli di clock e non può essere gestito in polling.

\subsection{Interrupt}
Al posto di fare polling, cioè la CPU che controlla continuamente lo stato del dispositivo,
si può utilizzare un \textbf{interrupt} che è un segnale hardware che interrompe il normale
flusso di esecuzione del programma solo quando il dispositivo è pronto. La CPU
\textbf{prima di ogni fetch} controlla se c'è qualche richiesta di interrupt.
\begin{figure}[H]
	\centering
	\begin{tikzpicture}
		\draw (0,0) rectangle (2,2) node[midway] {CPU};
		\draw[latex-] (2,1.5) -- ++(4,0) node[right, scale=0.7] {BC};
		\draw[-latex] (2,1) -- ++(4,0) node[right, scale=0.7] {BD};
		\draw[-latex] (2,0.5) -- ++(4,0) node[right, scale=0.7] {BI};

		\node[draw, rectangle, minimum width=0.5cm, minimum height=0.5cm]
		(io1) at (2.8,-1) {I/O};
		\node[draw, rectangle, minimum width=0.5cm, minimum height=0.5cm]
		(io2) at (4.5,-1) {I/O};
		\node at (5.5,-1) {$\ldots$};

		\draw[-latex] (io1) -- (2.8,1.5);
		\draw[-latex] (io2) -- (4.5,1.5);
		\draw[-latex] (io1) -- (io2);

		\draw[-latex] (1,0) -- ++(0,-1) node[below, scale=0.7] {INTACK} |- (io1);
	\end{tikzpicture}
\end{figure}

\noindent Esiste un bit \( \overline{INTERRUPT} \) che è sempre a 1 (negato a 0) che
vale 1 solo quando c'è una \textbf{interrupt request}. Ogni interrupt ha un valore
che contiene un pezzo di codice chiamato \textbf{Interrupt Service Routine (ISR)}
che viene passato alla CPU attraverso il \texttt{INTACK} (Interrupt Acknowledge).
Le ISR sono gestite dal sistema operativo e tutto l'insieme viene chiamato \textbf{Device Driver}.
Ogni dispositivo input/output ha interrupt con valori diversi.

\vspace{1em}
\noindent Siccome l'esecuzione di un interrupt può modificare i registri della CPU può esserci
qualche conflitto con dei programmi già in esecuzione, quindi c'è bisogno di un meccanismo
per eseguire l'ISR senza che vengano modificati i registri della CPU. Questo viene
effettuato dal dispositivo input/output che salva il valore dei registri \texttt{PSW} e
\texttt{PC} ed eventuali altri registri salvaldoli nello stack prima di eseguire l'ISR.

\subsection{DMA (Direct Memory Access)}
Per trasferire grandi quantità di dati da un dispositivo di input/output alla memoria
non conviene utilizzare degli interrupt perchè sarebbe uno spreco di risorse. Si utilizza
il DMA che è un dispositivo che permette di trasferire dati dalla memoria al dispositivo
di input/output senza passare per la CPU.

\begin{figure}[H]
	\centering
	\begin{tikzpicture}
		% CPU
		\node[draw, rectangle, minimum width=2cm, minimum height=1.5cm] (cpu) at (0, 0) {\textbf{CPU}};
		% Memoria
		\node[draw, rectangle, align=center, minimum width=2cm, minimum height=1.5cm] (memory) at (4, 0) {\textbf{Memoria}\\\footnotesize Dati\\\footnotesize Istruzioni};

		% Bus
		\draw (-2,-2) -- (6.5,-2) node[right] {Bus};
		\draw[latex-latex] (cpu) -- ++(0,-2);
		\draw[latex-latex] (memory) -- ++(0,-2);

		% Input/Output below bus
		\node[draw, rectangle, minimum width=0.7cm, minimum height=0.7cm] (dma) at (2, -3) {\textbf{DMA}};
		\draw[latex-latex] (dma) -- (2,-2);

	\end{tikzpicture}
	\caption{Schema di un sistema con DMA}
\end{figure}

\begin{figure}[H]
	\centering
	\begin{tikzpicture}
		\draw (0,0) rectangle (4,4);
		\draw (0.5,2.5) rectangle (1.8,3.5) node[midway] {Data};
		\draw (2.2,2.5) rectangle (3.5,3.5) node[midway] {Status};

		\node[draw, rectangle, minimum width=0.5cm, minimum height=0.5cm] (mem)
		at (1.1,1.7) {MEM};
		\node[draw, rectangle, minimum width=0.5cm, minimum height=0.5cm] (cpu)
		at (2.9,1.7) {CPU};

		\draw[latex-latex] (mem) -- (cpu);

		\draw (0,0) rectangle (1,1) node[midway, scale=0.7] {A/D};
		\node at (4,0) [above left, scale=0.7] {DMA};
	\end{tikzpicture}
	\caption{Struttura del DMA}
\end{figure}


\subsection{Bus}
Il bus è una linea di comunicazione che collegana i vari componenti di un sistema
informatico. Vengono gestiti direttamente dalla CPU che quando non lo usa lo assegna ad
altri componenti.

\subsubsection{Bus Sincrono}
Il segnale di clock è presente. Questo tipo di bus
non viene mai realizzato perchè rallenta il sistema. Vengono invece utilizzati
soltanto per collegare i componenti all'interno di un chip. Il segnale di clock
può anche avere un ritardo, quindi non è detto che tutti i componenti ricevano
il segnale di clock nello stesso momento.

\subsubsection{Bus Asincrono}
Il segnale di clock non è presente. Ciò permette di
adattare dinamicamente la velocità di trasmissione dei dati in base alla
velocità di trasmissione dei componenti.

\begin{figure}[H]
	\centering
	\begin{tikzpicture}
		\draw (0,0) rectangle (2,2) node[midway] {CPU};
		\draw[latex-] (2,1.5) -- ++(4,0) node[right, scale=0.7] {\( \overline{BBSY} \) };
		\draw[latex-] (2,0.5) -- ++(4,0) node[right, scale=0.7] {\( \overline{BR} \) };

		\node[draw, rectangle, minimum width=0.5cm, minimum height=0.5cm]
		(dma1) at (2.8,-1) {\( DMA_1 \) };
		\node[draw, rectangle, minimum width=0.5cm, minimum height=0.5cm]
		(dma2) at (5,-1) {\( DMA_2 \)};
		\node at (6,-1) {$\ldots$};

		\draw[latex-latex] (2.5,1.5) -- ++(0,-2.2);
		\draw[latex-] (3.1,0.5) -- ++(0,-1.2);

		\draw[latex-latex] (4.7,1.5) -- ++(0,-2.2);
		\draw[latex-] (5.3,0.5) -- ++(0,-1.2);

		\draw[-latex] (dma1) -- (dma2) node[midway, below, scale=0.9] {\( BG_2 \) };

		\draw[-latex] (1,0) -- ++(0,-1) |- (dma1) node[midway, below right, scale=0.9]
			{\( BG_1 \) };
	\end{tikzpicture}
	\caption{Schema di un sistema con bus}
\end{figure}

\noindent I segnali di controllo del bus sono:
\begin{itemize}
	\item \( \overline{BBSY} \) (Bus Busy): quando vale 0 indica che il bus è occupato
	\item \( \overline{BR} \) (Bus Request): quando vale 0 indica che il dispositivo vuole
	      utilizzare il bus
	\item \( BG_1 \) (Bus Grant): indica che il bus è assegnato al DMA1
	\item \( BG_2 \) (Bus Grant): indica che il bus è assegnato al DMA2
\end{itemize}

\begin{figure}[H]
	\begin{center}
		\begin{tikzpicture}[scale=0.8]
			\draw [->] (0,0) -- (12,0) node[right] {t};
			\draw (0,0) -- (0,8) node[above] {};
			\draw [gray!50, ultra thin, help lines, ystep=10] (0,0) grid (12,8);

			\draw [blue, ultra thick] plot coordinates { (0,8) (1,8) (1,8) (2,8) (2,7) (3,7) (3,7) (4,7) (4,7) (5,7) (5,7) (6,7) (6,7) (7,7) (7,7) (8.5,7) (8.5,8) (9,8) (12,8) };
			\draw [magenta, ultra thick] plot coordinates { (0,5) (1,5) (1,5) (2,5) (2,5) (3,5) (3,6) (4,6) (4,6) (5,6) (5,6) (6,6) (6,6) (7,6) (7,6) (8,6) (8,6) (9,6) (9,6) (10,6) (10,5) (11,5) (11,5) (12,5) (12,5) };
			\draw [red, ultra thick] plot coordinates { (0,3) (2,3) (2,3) (3.5,3) (3.5,4) (10.5,4) (10.5,3) (12,3)  };
			\draw [orange, ultra thick] plot coordinates { (0,1) (8,1) (8,2) (9,2) (9,1) (12,1) };

			\draw[thick, opacity=0.3] (8,8) -- (8,0) node[below right, opacity=1] {BUS non usato};
			\draw[thick, opacity=0.3] (9,8) -- (9,0);

			\node[blue, anchor=east] at (0,7) {\( \overline{BR} \) };
			\node[magenta, anchor=east] at (0,5) {\( BG_1 \) };
			\node[red, anchor=east] at (0,3) {\( BG_2 \) };
			\node[orange, anchor=east] at (0,1) {\( \overline{BBSY} \) };
		\end{tikzpicture}
	\end{center}
	\caption{Segnali di controllo DMA}
\end{figure}

\noindent Il \( DMA_2 \) vuole utilizzare il bus, che però è già in uso dalla CPU, quindi
mette a 0 il \( \overline{BR} \) e aspetta che il bus venga liberato.
Quando la CPU libera il BUS vede la request del \( DMA_2 \) e mette a 0 il \( BG_1 \) e
il \( BG_2 \).
Il \( \overline{BBSY} \) viene messo a 0 quando il bus è occupato e quando viene liberato
viene messo a 1 mettendo a 1 il \( \overline{BR} \) e resettando a 0 il \( BG_1 \) e \( BG_2 \).

\vspace{1em}
\noindent In questo modo si riduce al minimo il tempo in cui il BUS \textbf{non} è
utilizzato.

\section{Multitasking (multiprocesso)}
Il multitasking è la capacità di un sistema operativo di eseguire più
processi contemporaneamente e questa è una caratteristica che sta alla base di tutti
i calcolatori moderni.

\begin{figure}[H]
	\begin{define}
		Il concetto di \textbf{programma} è diverso da un \textbf{processo}. Un programma è
		un file binario che contiene le istruzioni da eseguire, mentre un processo è un
		programma in esecuzione.
	\end{define}
\end{figure}

\noindent Per permettere che più processi vengano eseguiti contemporaneamente si
ricorre al concetto di \textbf{time sharing}
\begin{figure}[H]
	\begin{center}
		\begin{tikzpicture}[scale=0.8]
			\draw [->] (0,0) -- (10,0) node[right] {t};
			\draw (0,0) -- (0,6) node[above] {};
			\draw [gray!50, ultra thin, help lines, ystep=10] (0,0) grid (4,6);
			\draw [gray!50, ultra thin, help lines, ystep=10, xshift=-15] (4.5,0) grid (10,6);

			\draw [magenta, ultra thick] plot coordinates { (0,5) (1,5) };
			\draw [magenta, ultra thick] plot coordinates { (3,5) (4,5) };
			\draw [magenta, ultra thick] plot coordinates { (6.5,5) (7.5,5) };

			\draw [red, ultra thick] plot coordinates { (1,3) (2,3) };
			\draw [red, ultra thick] plot coordinates { (4,3) (4.5,3) };
			\draw [red, ultra thick] plot coordinates { (5.5,3) (6.5,3) };
			\draw [red, ultra thick] plot coordinates { (8.5,3) (9.5,3) };

			\draw [orange, ultra thick] plot coordinates { (2,1) (3,1) };
			\draw [orange, ultra thick] plot coordinates { (4.5,1) (5.5,1) };
			\draw [orange, ultra thick] plot coordinates { (7.5,1) (8.5,1) };

			\node[magenta, anchor=east] at (0,5) {\( p_1 \) };
			\node[red, anchor=east] at (0,3) {\( p_2 \) };
			\node[orange, anchor=east] at (0,1) {\( p_3 \) };

			\node[scale=0.6] at (4.1,3.45) (svc) {SVC};
			\draw[-latex] (svc) -- (4.5,3);

			\draw (0,-0.2) -- ++(0,-0.2) -- ++(1,0) node[below, midway, scale=0.7, align=center]
			{quanto\\di tempo} -- ++(0,0.2);
		\end{tikzpicture}
	\end{center}
	\caption{Time sharing tra i processi}
\end{figure}
\noindent Il quanto di tempo è stato messo a \( 1ms \) perchè è il tempo minimo per cui un
umano non percepisce il cambio di processo. I processi vengono eseguiti per poco tempo,
ma così frequentemente che sembra che vengano eseguiti contemporaneamente.

\vspace{1em}
\noindent Se un processo in esecuzione esegue una supervisor call (SVC) il processo viene
immediatamente interrotto e viene eseguita la SVC. Questo perchè finchè la SVC verrà
eseguita si perderebbero migliaia di quanti di tempo.

\subsection{Kernel}
La parte del sistema operativo che
gestisce i processi si chiama \textbf{kernel} e lo fa dialogando direttamente con la CPU.

\begin{figure}[H]
	\centering
	\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=3cm,
			thick,main node/.style={circle,draw,font=\sffamily\Large\bfseries}]

		\node[main node] (1) {\footnotesize \( Exec_u \) };
		\node[main node] (2) [below of=1] {\footnotesize \( Exec_s \) };
		\node[main node] (3) [below of=2] {\footnotesize Attesa};
		\node[main node] (4) [right of=3] {\footnotesize Pronto};

		\path[every node/.style={font=\sffamily\small}]
		(1) edge [bend right, align=center] node[left] {SVC\\ (int sw)} (2)
		(2) edge [bend right] node {} (3)
		(2) edge [bend right] node[right] {Iret} (1)
		(3) edge [bend right] node[midway, below] {Evento} (4)
		(4) edge [loop right] node {\( \begin{array}{c}
					p_1    \\
					p_2    \\
					\vdots \\
					p_n
				\end{array} \) } (4)
		(2) edge [bend left] node[right] {Preemption} (4);
	\end{tikzpicture}
	\caption{Flusso di esecuzione delle istruzioni}
\end{figure}

\noindent La chiamata di una SVC porta l'esecuzione dalla modalità utente (\( E_u \) )
alla modalità supervisor (\( E_s \) ). Questo perchè la SVC può accedere a tutte le
parti del sistema operativo e quindi deve avere i permessi necessari. Nell'architettura
x86 gli SVC sono degli interrupt chiamati \textbf{Software Interrupt}. L'istruzione
assembly è la seguente:
\begin{lstlisting}[language={[x86masm]Assembler}]
 INT $0x80 ; Numero dell'interrupt
\end{lstlisting}

\noindent La \textbf{preemption} è l'interruzione di un processo in esecuzione per
eseguire un altro processo. Questo avviene quando un processo è stato eseguito per
un tempo maggiore del quanto di tempo.

\subsubsection{Scheduler}
È una delle operazioni principali del sistema operativo. La CPU conta i cicli di clock
che sono stati destinati ad un processo, in questo modo si può sapere che frazione del
quanto di tempo è stata impiegata direttamente per il processo e non per eseguire gli
interrupt. Per sapere quanto tempo è stato impiegato per eseguire un processo si
usa il seguente comando bash:
\begin{lstlisting}[language=bash]
$ time ./programma
\end{lstlisting}
\noindent L'output è diviso in:
\begin{itemize}
	\item \textbf{User}: tempo impiegato per eseguire il programma
	\item \textbf{System}: tempo impiegato per eseguire gli interrupt
	\item \textbf{Real}: tempo reale impiegato per eseguire il programma
\end{itemize}

\vspace{1em}
\noindent Lo scheduler controlla se il tempo dedicato ad un singolo processo è maggiore
della metà di un quanto di tempo, in tal caso lo sospende e passa ad un altro processo,
altrimenti lo fa continuare. Lo scheduler quindi decide quale processo della lista dei
processi pronti deve essere eseguito. Ogni processo ha una certa priorità e lo scheduler
deve decidere quale processo eseguire in base alla priorità e al tempo di esecuzione (
tempo reale). Per modificare la priorità dei processi si utilizza i seguenti comandi bash:
\begin{lstlisting}[language=bash]
$ nice -n 10 ./programma
\end{lstlisting}
\noindent Il comando \texttt{nice} permette di modificare la priorità di un processo solo
hardware, ma non software. Per modificare la priorità software si utilizza il comando:
\begin{lstlisting}[language=bash]
$ renice -n 10 -p 1234
\end{lstlisting}
\noindent Il comando \texttt{renice} permette di modificare la priorità di un processo
software.

\subsection{Realtime}
Un processo può essere eseguito in tempo reale se il tempo di esecuzione è all'interno
di un certo intervallo di tempo. Ci sono 2 tipi di realtime:
\begin{itemize}
	\item \textbf{Soft Realtime}: il processo deve essere eseguito entro un certo intervallo
	      di tempo ristretto ma non troppo.
	\item \textbf{Hard Realtime}: il processo deve essere eseguito entro un certo intervallo
	      di tempo molto stretto.
\end{itemize}

\subsection{Caratteristiche di un processo}
Ogni processo ha le seguenti caratteristiche contenute in un \textbf{descrittore}:
\begin{itemize}
	\item \textbf{PID}: identificatore del processo
	\item \textbf{Proprietà}: proprietario del processo
	\item \textbf{Stato}: indica lo stato della cpu
	\item \textbf{Cache}: contiene le informazioni più utilizzate dal processo
	\item \textbf{File ID}: contiene i file aperti dal processo
\end{itemize}

\noindent Questa struttura deve essere salvata dallo scheduler quando il processo viene
sospeso e deve essere caricata quando il processo viene ripreso. Questa operazione
viene chiamata \textbf{Context Switch}.


\end{document}
