\documentclass[a4paper]{article}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{textcomp}
\usepackage[italian]{babel}
\usepackage{amsmath, amssymb}
\usepackage{booktabs,xltabular}
\usepackage{amsfonts}
\usepackage{cancel}
\usepackage{mdframed}
\usepackage{makecell}
\usepackage{float}
\usepackage{xcolor}
\usepackage{listings}
\usepackage{graphicx}
\usepackage{tikz}
\usetikzlibrary{shapes, arrows, automata, petri, decorations.pathreplacing, positioning, calc}
\usepackage{circuitikz}
\usepackage[label=corner]{karnaugh-map}
\graphicspath{{./figures/}}

\usepackage{ntheorem}
\newtheorem{theorem}{Teorema}

\usepackage{import}
\usepackage{pdfpages}
\usepackage{transparent}
\usepackage{xcolor}

\usepackage{hyperref}
\hypersetup{
    colorlinks=false,
}

% Code blocks
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.95}

\lstdefinestyle{mystyle}{
	backgroundcolor=\color{backcolour},
	commentstyle=\color{codegreen},
	keywordstyle=\color{magenta},
	numberstyle=\tiny\color{codegray},
	stringstyle=\color{codepurple},
	basicstyle=\ttfamily\footnotesize,
	breakatwhitespace=false,
	breaklines=true,
	captionpos=b,
	keepspaces=true,
	numbers=left,
	numbersep=5pt,
	showspaces=false,
	showstringspaces=false,
	showtabs=false,
	tabsize=2
}

\lstset{style=mystyle}

\usepackage{color}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=tb,
	aboveskip=3mm,
	belowskip=3mm,
	showstringspaces=false,
	columns=flexible,
	basicstyle={\small\ttfamily},
	numbers=none,
	numberstyle=\tiny\color{gray},
	keywordstyle=\color{blue},
	commentstyle=\color{dkgreen},
	stringstyle=\color{mauve},
	breaklines=true,
	breakatwhitespace=true,
	tabsize=3
}

\usepackage{import}
\usepackage{pdfpages}
\usepackage{transparent}
\usepackage{xcolor}



% Useful definitions frame
\theoremstyle{break}
\theoremheaderfont{\bfseries}
\newmdtheoremenv[%
	linecolor=gray,leftmargin=0,%
	rightmargin=0,
	innertopmargin=8pt,%
	innerbottommargin=8pt,
	ntheorem]{define}{Definizioni utili}[section]

% Example frame
\theoremstyle{break}
\theoremheaderfont{\bfseries}
\newmdtheoremenv[%
	linecolor=gray,leftmargin=0,%
	rightmargin=0,
	innertopmargin=8pt,%
	innerbottommargin=8pt,
	ntheorem]{example}{Esempio}[section]

% Important definition frame
\theoremstyle{break}
\theoremheaderfont{\bfseries}
\newmdtheoremenv[%
	linecolor=gray,leftmargin=0,%
	rightmargin=0,
	backgroundcolor=gray!40,%
	innertopmargin=8pt,%
	innerbottommargin=8pt,
	ntheorem]{definition}{Definizione}[section]

% Exercise frame
\theoremstyle{break}
\theoremheaderfont{\bfseries}
\newmdtheoremenv[%
	linecolor=gray,leftmargin=0,%
	rightmargin=0,
	innertopmargin=8pt,%
	innerbottommargin=8pt,
	ntheorem]{exercise}{Esercizio}[section]

% figure support
\usepackage{import}
\usepackage{xifthen}
\pdfminorversion=7
\usepackage{pdfpages}
\usepackage{transparent}
\newcommand{\incfig}[1]{%
	\def\svgwidth{\columnwidth}
	\import{./figures/}{#1.pdf_tex}
}

% FSM tikz
\tikzset{
    place/.style={
        circle,
        thick,
        draw=black,
        minimum size=6mm,
    },
        state/.style={
        circle,
        thick,
        draw=blue!75,
        fill=blue!20,
        minimum size=6mm,
    },
}

\pdfsuppresswarningpagegroup=1

\begin{document}

\input{title.tex}

\tableofcontents
\pagebreak

% Laboratorio
\section{Laboratorio}
\subsection{Vantaggi e svantaggi di assembly}
\subsubsection{Vantaggi}
Siccome assembly è un linguaggio di basso livello, è molto vicino all'hardware e quindi è possibile:
\begin{itemize}
	\item accedere direttamente ai \textbf{registri} della CPU
	\item scrivere \textbf{codice ottimizzato} per una specifica architettura di CPU
	\item ottimizzare le \textbf{sezioni "critiche"} dei programmi
\end{itemize}

\subsubsection{Svantaggi}
I principali svantaggi sono:
\begin{itemize}
	\item possono essere richieste \textbf{molte più righe} di codice
	\item è facile introdurre dei \textbf{bug} perchè la programmazione è più complessa
	\item il \textbf{debugging} è complesso
	\item \textbf{non è garantita la compatibilità} del codice per altri hardware
\end{itemize}

\subsection{Utilità}
Assembly permette di gestire direttamente il funzionamento della CPU, di conseguenza,
i programmi Assembly, una volta compilati sono tipicamente più veloci e più piccoli dei
programmi scritti in linguaggi di alto livello. Per questo motivo, l'assembly è utilizzato
per scrivere codice che deve essere il più veloce possibile, come ad esempio i driver di
hardware specifici.

\subsection{Registri}
Tutti i processori della famiglia x86 hanno i seguenti registri:
AX, BX, CX, DX, CS, DS, ES, SS, SP, BP, SI, DI, IP, FLAGS.

\vspace{1em}
\noindent Originariamente i registri AX, BX, CX, DX, SP, BP, SI, DI, IP e FLAGS avevano una dimensione
di 16 bit. A partire dal 80386, la loro dimensione è stata estesa a 32 bit e al loro nome
è stato aggiunto il prefisso E (Extended). Per ragioni di retrocompatibilità, i registri
di 16 bit possono essere utilizzati anche nei processori a 32 bit utilizzando il loro
nome originale.

\subsubsection{Registri general purpose}
I seguenti registri sono generici, pertanto è possibile assegnargli qualunque valore. Tuttavia,
durante l'esecuzione di alcune istruzioni i registri generici vengono utilizzati per
memorizzare valori ben determinati:
\begin{itemize}
	\item \textbf{EAX} (Accumulator register): è usato come accumulatore per
	      operazioni aritmetiche e contiene il risultato dell'operazione
	\item \textbf{EBX} (Base register): è usato per operazioni di indirizzamento della
	      memoria
	\item \textbf{ECX} (Counter register):  è usato per "contare", ad esempio nelle
	      operazioni di loop
	\item \textbf{EDX} (Data register): è usato nelle operazioni di input/output, nelle
	      divisioni e nelle moltiplicazioni

\end{itemize}

\subsubsection{Registri di segmento}
CS, DS, ES e SS sono i \textbf{registri di segmento} (segment registers) e devono
essere utilizzati con cautela:
\begin{itemize}
	\item \textbf{CS} (Code Segment): punta alla zona di memoria che contiene il codice.
	      Durante l'esecuzione del programma, assieme al registro IP, serve per
	      accedere alla prossima istruzione da eseguire (attenzione: non può
	      essere modificato!)
	\item \textbf{DS} (Data Segment): punta alla zona di memoria che contiene i dati
	\item \textbf{ES} (Extra Segment):  può essere usato come registro di segmento
	      ausiliario
	\item \textbf{SS} (Stack Segment): punta alla zona di memoria in cui risiede lo stack
\end{itemize}

\subsubsection{Registri puntatore}
ESP, EBP, EIP sono i registri puntatore (pointer registers):
\begin{itemize}
	\item \textbf{ESP} (Stack Pointer):  punta alla cima dello stack. Viene modificato
	      dalle operazioni di PUSH (inserimento di un dato nello stack) e POP
	      (estrazioni di un dato dallo stack). Si ricordi che lo stack è una
	      struttura di tipo LIFO (Last In First Out - l'ultimo che entra è il primo
	      che esce). È possibile modificarlo manualmente ma occorre cautela!
	\item \textbf{EBP} (Base Pointer): punta alla base della porzione di stack gestita in
	      quel punto del codice. È possibile modificarlo manualmente ma
	      occorre cautela!
	\item \textbf{EIP} (Instruction Pointer): punta alla prossima istruzione da eseguire.
	      Non può essere modificato!
\end{itemize}

\subsubsection{Registri indice}
ESI e EDI sono i registri indice (index registers) e vengono utilizzati per
operazioni con stringhe e vettori:
\begin{itemize}
	\item \textbf{ESI} (Source Index):  punta alla stringa/vettore sorgente
	\item \textbf{EDI} (Destination Index): punta alla stringa/vettore destinazione
	\item \textbf{EFLAGS}: è utilizzato per memorizzare lo stato corrente del processore.
	      Ciascuna flag (bit) del registro fornisce una particolare informazione.
	      Ad esempio, la flag in prima posizione (carry flag) viene posta a 1
	      quando c;è stato un riporto o un prestito durante un'operazione
	      aritmetica; la flag in seconda posizione (parity flag) viene usata come
	      bit di parità e viene posta a 1 quando il risultato dell'ultima
	      operazione ha un numero pari di 1
\end{itemize}

\subsubsection{Composizione dei registri}
I registri sono composti da 32 bit e possono essere divisi in registri più piccoli:
\begin{itemize}
	\item \textbf{EAX}: AX, AH, AL
	\item \textbf{EBX}: BX, BH, BL
	\item \textbf{ECX}: CX, CH, CL
	\item \textbf{EDX}: DX, DH, DL
	\item \textbf{ESP}: SP
	\item \textbf{EBP}: BP
	\item \textbf{ESI}: SI
	\item \textbf{EDI}: DI
\end{itemize}

\subsubsection{Composizione del registro EFLAGS}
Il registro EFLAGS è composto da 32 bit e ogni bit corrisponde ad un flag:
\begin{itemize}
	\item \textbf{ZF} (Zero flag):  impostato a 1 se il risultato dell'operazione è 0
	\item \textbf{SF} (Sign flag): impostato a 1 se il risultato dell'operazione è un
	      numero negativo, a 0 se è positivo (rappresentazione in complemento
	      a 2)
	\item \textbf{OF} (Overflow flag): impostato a 1 nel caso di overflow di
	      un'operazione
	\item \textbf{TF} (Trap flag): impostato a 1 genera un'interruzione ad ogni
	      istruzione. Utilizzato per l'esecuzione passo-passo dei programmi
	\item \textbf{IF} (Interrupt flag): impostato a 1 abilita gli interrupt esterni, con 0 li
	      disabilita
	\item \textbf{DF} (Direction flag): impostato a 1 indica che nelle operazioni di
	      spostamento di stringhe i registri DI e SI si autodecrementano (con 0
	      tali registri si auto incrementano)
\end{itemize}

\subsection{Modalità di indirizzamento}
Si rifersce al modo in cui un'istruzione assembly accede ai dati in memoria e può essere:
\begin{itemize}
	\item \textbf{Indirizzamento a registro}: l'operando è contenuto in un registro ed
	      il nome del registro è specificato nell'istruzione. Ad esempio:
	      \begin{center}
		      \texttt{\%Ri}
	      \end{center}

	\item \textbf{Indirizzamento diretto} (o assoluto): l'operando è contenuto in una
	      locazione di memoria, e l'indirizzo della locazione viene specificato
	      nell'istruzione. Ad esempio:
	      \begin{center}
		      \texttt{(IND)}
	      \end{center}

	\item \textbf{Indirizzamento immediato} (o di costante): l'operando è un valore
	      costante ed è definito esplicitamente nell'istruzione. Ad esempio:
	      \begin{center}
		      \texttt{\$VAL}
	      \end{center}

	\item \textbf{Indirizzamento indiretto}: l'indirizzo di un operando è contenuto in
	      un registro o in una locazione di memoria. L'indirizzo della locazione o
	      il registro viene specificato nell'istruzione. Ad esempio:
	      \begin{center}
		      \texttt{(\%Ri)} \quad o \quad \texttt{(\$VAL)}
	      \end{center}

	\item \textbf{Indirizzamento indicizzato} (Base e spiazzamento): l'indirizzo
	      effettivo dell'operando è calcolato sommando un valore costante al
	      contenuto di un registro. Ad esempio:
	      \begin{center}
		      \texttt{SPI(\%Ri)}
	      \end{center}

	\item \textbf{Indirizzamento con autoincremento}: l'indirizzo effettivo
	      dell'operando è il contenuto di un registro specificato nell'istruzione.
	      Dopo l'accesso, il contenuto del registro viene incrementato per
	      puntare all'elemento successivo

	\item \textbf{Indirizzamento con autodecremento}: il contenuto di un registro
	      specificato nell'istruzione viene decrementato. Il nuovo contenuto
	      viene usato come indirizzo effettivo dell'operando

\end{itemize}

\subsection{Istruzioni}
\subsubsection{Istruzioni di inizializzazione}
\begin{itemize}
	\item \texttt{mov src, dst} \quad \textbf{Move}: consente l'inizializzazione di un registro o di
	      un'area di memoria. Accetta i modificatori \texttt{l}, \texttt{w} e \texttt{b} per
	      indicare la dimensione dell'operando \texttt{s rc}
	\item \texttt{lea src, dst} \quad \textbf{Load Effective Address}: trasferisce l'indirizzo
	      effettivo dell'operando \texttt{src} nel registro \texttt{dst}
\end{itemize}

\subsubsection{Istruzioni aritmetiche e logiche}
\begin{itemize}
	\item \texttt{sar op1, op2} \quad \textbf{Shift Arithmetic Right}: esegue lo shift a destra sul
	      registro \texttt{op2} di tanti bit quanti specificati in \texttt{op1}. Il bit
	      più significativo viene replicato (così da funzionare anche
	      con numeri negativi in complemento 2) e il bit scartato
	      viene messo nel \textbf{Carry Flag}. \texttt{op1} può essere un registro
	      o un valore immediato, \texttt{op2} deve essere un registro
	\item \texttt{sal op1, op2} \quad \textbf{Shift Arithmetic Left}: esegue lo shift a sinistra sul
	      registro \texttt{op2} di tanti bit quanti specificati in \texttt{op1}. Il bit
	      meno significativo viene messo a \( 0 \)  e il bit scartato viene
	      messo nel \textbf{Carry Flag}. \texttt{op1} può essere un registro o un
	      valore immediato, \texttt{op2} deve essere un registro
	\item \texttt{inc op} \quad \textbf{Increment}: incrementa di 1 il valore memorizzato in
	      \texttt{op}. \texttt{op} può essere un registro o una locazione di memoria
	\item \texttt{dec op} \quad \textbf{Decrement}: decrementa di 1 il valore memorizzato in
	      \texttt{op}. \texttt{op} può essere un registro o una locazione di
	      memoria
	\item \texttt{add src, dst} \quad \textbf{Add}: somma a \texttt{dst} il valore di \texttt{src}
	      e memorizza il risultato in \texttt{dst}
	\item \texttt{sub src, dst} \quad \textbf{Subtract}: sottrae da \texttt{dst} il valore di \texttt{src}
	      e memorizza il risultato in \texttt{dst}
	\item \texttt{mul moltipl} \quad \textbf{Unsigned Multiplication}: esegue la moltiplicazione
	      senza segno. \texttt{moltipl} deve essere un registro o una
	      variabile. Se \texttt{moltipl} è un byte il registro \texttt{AL} viene
	      moltiplicato per l'operando e il risultato viene
	      memorizzato in \texttt{AX}. Se \texttt{moltipl} è una word il
	      contenuto del registro \texttt{AX} viene moltiplicato per
	      l'operando e il risultato viene memorizzato nella coppia
	      di registri \texttt{DX}:\texttt{AX} (\texttt{DX} conterrà i 16 bit più significativi
	      del risultato). Se \texttt{moltipl} è un long il contenuto del
	      registro E\texttt{AX} viene moltiplicato per l'operando e il
	      risultato viene memorizzato nella coppia di registri
	      \texttt{EDX}:\texttt{EAX} (\texttt{EDX} conterrà i 32 bit più significativi del
	      risultato).
	\item \texttt{imul moltipl} \quad moltiplicazione con segno
	\item \texttt{div divisore} \quad \textbf{Unsigned Division}:
	      esegue la divisione senza segno.
	      \texttt{divisore} deve essere un registro o una variabile. Se
	      \texttt{divisore} è un byte il registro \texttt{AX} viene diviso per
	      l'operando, il quoziente viene memorizzato in \texttt{AL}, e il
	      resto in \texttt{AH}. Se \texttt{divisore} è una word, il valore ottenuto
	      concatenando il contenuto di \texttt{DX} e \texttt{AX} viene diviso per
	      l'operando (i 16 bit più significativi del dividendo
	      devono essere memorizzati nel registro \texttt{DX}), il quoziente
	      viene memorizzato nel registro \texttt{AX} e il resto in \texttt{DX}. Se
	      \texttt{divisore} è un long, il valore ottenuto concatenando il
	      contenuto di \texttt{EDX} e \texttt{EAX} viene diviso per l'operando (i
	      32 bit più significativi del dividendo sono nel registro
	      \texttt{EDX}), il quoziente viene memorizzato nel registro \texttt{EAX}
	      e il resto in \texttt{EDX}
	\item \texttt{xor src, dst} \quad \textbf{Logical Exclusive OR}: calcola l'OR esclusivo bit a bit
	      dei due operandi e lo memorizza nell'operando \texttt{dst}.
	      Spesso si utilizza per azzerare un registro, utilizzandolo
	      sia come \texttt{src} che come \texttt{dst})
	\item \texttt{or src, dst} \quad \textbf{Logical OR}: calcola l'OR logico bit a bit dei due
	      operandi e lo memorizza nell'operando \texttt{dst}
	\item \texttt{and src, dst} \quad \textbf{Logical AND}: calcola l'AND bit a bit dei due operandi
	      e lo memorizza nell'operando \texttt{dst}
	\item \texttt{not op} \quad \textbf{Logical NOT}: inverte ogni singolo bit dell'operando op
\end{itemize}

\subsection{AT\&T vs Intel}
Le principali differenze tra la sintassi AT\&T e Intel sono:
\begin{itemize}
	\item In AT\&T i nomi dei registri hanno il carattere \texttt{\%} come prefisso
	\item In AT\&T l'ordine degli operandi è \texttt{<sorgente>, <destinazione>}, opposto
	      rispetto alla sintassi Intel
	\item In AT\&T la lunghezza dell'operando è specificata tramite un suffisso al nome
	      dell'istruzione. \texttt{b} per \textbf{byte} (8 bit), \texttt{w} per \textbf{word} (16 bit),
	      \texttt{l} per \textbf{double word} (32 bit)
	\item Gli operandi immediati in AT\&T sono preceduti dal simbolo \texttt{\$}
	\item la presenza di prefisso in un operando indica che si tratta di un
	      indirizzo di memoria. Ad esempio:
	      \begin{center}
		      \texttt{movl \$pippo, \%eax} \quad è diverso da \quad \texttt{movl pippo, \%eax}
	      \end{center}
	\item l'indicizzazione o l'indirezione è ottenuta racchiudendo tra parentesi
	      l'indirizzo di base espresso tramite un registro o un valore immediato.
	      Ad esempio:
	      \begin{center}
		      \texttt{movl 5, 17(\%ebp)}
	      \end{center}
\end{itemize}

\subsection{Assemblare, verificare ed eseguire un programma Assembly}
% Prima di tutto bisogna creare un file con estensione \texttt{.s} e scrivere il codice assembly.
% Dopo aver scritto il codice assembly, si compila il file con il comando \texttt{as} che crea un file binario
% (\texttt{.o}) contenente l'implementazione di ogni singolo file. Infine si uniscono i file binari con il comando
% \texttt{ld} che crea un file eseguibile a partire dai file binari.
%
% \begin{lstlisting}[language=bash]
%  $  as -o <nomefile>.o <nomefile>.s
%  $  ld -o <nomefile> <nomefile>.o
%  $  ./<nomefile>
%   
% \end{lstlisting}

Il processo di creazione di un programma Assembly passa attraverso le seguenti fasi:
\begin{enumerate}
	\item Scrittura di uno o più file ASCII (con estensione \texttt{.s}) contenenti il
	      programma sorgente, tramite un normale editor di testo.
	\item Assemblaggio dei file sorgenti, e generazione dei file \textbf{oggetto} (con
	      estensione \texttt{.o}), tramite un \textbf{assemblatore}.
	\item Creazione del file \textbf{eseguibile}, tramite un \textbf{linker}
	\item Verifica del funzionamento e correzione degli eventuali errori tramite un
	      \textbf{debugger}
\end{enumerate}

\subsubsection{L'assemblatore}
L'Assemblatore trasforma i file contenenti il programma sorgente in altrettanti file
oggetto contenenti il codice in linguaggio macchina. Durante questo corso verrà usato
l'assemblatore \textbf{gas} della GNU.

\noindent Per assemblare un file è necessario eseguire il seguente comando:
\begin{lstlisting}[language=bash]
  $  as -o <nomefile>.o <nomefile>.s
\end{lstlisting}

\subsubsection{Il linker}
Il linker combina i moduli oggetto e produce un unico file eseguibile. In particolare
unisce i moduli oggetto, risolvendo i riferimenti a simboli esterni; ricerca i file di
libreria contenenti le procedure esterne utilizzate dai vari moduli e produce un file
eseguibile. L'operazione di linking deve essere effettuata anche se il programma è
composto da un solo modulo oggetto.

\noindent Durante il corso verrà usato il linker \textbf{ld} della GNU.

\noindent Per creare l'eseguibile a partire da un file oggetto è necessario eseguire il
seguente comando:
\begin{lstlisting}[language=bash]
  $  ld -o <nomefile>.x <nomefile1>.o <nomefile2>.o ...
\end{lstlisting}

\subsubsection{Assembly 32bit su macchine 64bit}
La gran parte del codice ASM32 è compatibile con macchine a 64bit, tuttavia alcune
estensioni in particolari istruzioni non sono riconosciute dai compilatori. È possibile
utilizzare codice ASM32 su architetture a 64bit utilizzando dei flag di compilazione che
permettono di simulare il comportamento di una architettura a 32bit.
\begin{lstlisting}[language=bash]
  $  as --32 -o <nomefile>.o <nomefile>.s
  $  ld -m elf_i386 -o <nomefile> <nomefile>.o
\end{lstlisting}

\subsection{Stampa di numeri}
I numeri sono memorizzati nei registri e nelle variabili come interi in complemento a 2
su 32 bit. Affinchè essi possano essere stampati a video occorre trasformarli in stringhe
di caratteri cioè vettori di byte dove ciascun byte rappresenta un carattere secondo la
codifica ASCII.

\noindent Per trasformare un numero intero in una stringa occorre scomporlo nelle sue
cifre mediante divisioni successive per 10. Per la particolare conformazione della tabella
ASCII il codice del carattere corrispondente alla cifra \( n \) si ottiene come \( n+48 \).

\subsubsection{Tabella dei caratteri ASCII}
La tabella seguente è relativa al codice US ASCII, ANSI X3.4-1986 (ISO International
Reference Version). I codici decimali da 0 a 31 e il 127 sono caratteri non stampabili
(codici di controllo). Il 32 corrispondente al carattere "spazio". I codici dal 32 al 126
sono caratteri stampabili.
\begin{xltabular}{\textwidth}{|c|c|c|l|}
	\hline
	\textbf{Char} & \textbf{Dec} & \textbf{Nome} & \textbf{Descrizione} \\
	\hline
	& 0 & NUL (Ctrl-@) & NULL \\
	\hline
	& 1 & SOH (Ctrl-A) & Start of Heading \\
	\hline
	& 2 & STX (Ctrl-B) & Start of Text \\
	\hline
	& 3 & ETX (Ctrl-C) & End of Text \\
	\hline
	& 4 & EOT (Ctrl-D) & End of Transmission \\
	\hline
	& 5 & ENQ (Ctrl-E) & Enquiry \\
	\hline
	& 6 & ACK (Ctrl-F) & Acknowledge \\
	\hline
	& 7 & BEL (Ctrl-G) & Bell (Beep) \\
	\hline
	& 8 & BS (Ctrl-H) & Backspace \\
	\hline
	& 9 & HT (Ctrl-I) & Horizontal Tab \\
	\hline
	& 10 & LF (Ctrl-J) & Line Feed \\
	\hline
	& 11 & VT (Ctrl-K) & Vertical Tab \\
	\hline
	& 12 & FF (Ctrl-L) & Form Feed \\
	\hline
	& 13 & CR (Ctrl-M) & Carriage Return \\
	\hline
	& 14 & SO (Ctrl-N) & Shift Out \\
	\hline
	& 15 & SI (Ctrl-O) & Shift In \\
	\hline
	& 16 & DLE (Ctrl-P) & Data Link Escape \\
	\hline
	& 17 & DC1 (Ctrl-Q) & Device Control 1 (XON) \\
	\hline
	& 18 & DC2 (Ctrl-R) & Device Control 2 \\
	\hline
	& 19 & DC3 (Ctrl-S) & Device Control 3 (XOFF) \\
	\hline
	& 20 & DC4 (Ctrl-T) & Device Control 4 \\
	\hline
	& 21 & NAK (Ctrl-U) & Negative Acknowledge \\
	\hline
	& 22 & SYN (Ctrl-V) & Synchronous Idle \\
	\hline
	& 23 & ETB (Ctrl-W) & End of Transmission Block \\
	\hline
	& 24 & CAN (Ctrl-X) & Cancel \\
	\hline
	& 25 & EM (Ctrl-Y) & End of Medium \\
	\hline
	& 26 & SUB (Ctrl-Z) & Substitute \\
	\hline
	& 27 & ESC (Ctrl-[) & Escape \\
	\hline
	& 28 & FS (Ctrl-\textbackslash) & File Separator \\
	\hline
	& 29 & GS (Ctrl-]) & Group Separator \\
	\hline
	& 30 & RS (Ctrl-\textasciicircum) & Record Separator \\
	\hline
	& 31 & US (Ctrl-\_) & Unit Separator \\
	\hline
	\texttt{ } & 32 & & Space \\
	\hline
	\texttt{!} & 33 & & Exclamation mark \\
	\hline
	\texttt{"} & 34 & & Quotation mark \\
	\hline
	\texttt{\#} & 35 & & Number sign \\
	\hline
	\texttt{\$} & 36 & & Dollar sign \\
	\hline
	\texttt{\%} & 37 & & Percent sign \\
	\hline
	\texttt{\&} & 38 & & Ampersand \\
	\hline
	\texttt{'} & 39 & & Apostrophe \\
	\hline
	\texttt{(} & 40 & & Left parenthesis \\
	\hline
	\texttt{)} & 41 & & Right parenthesis \\
	\hline
	\texttt{*} & 42 & & Asterisk \\
	\hline
	\texttt{+} & 43 & & Plus sign \\
	\hline
	\texttt{,} & 44 & & Comma \\
	\hline
	\texttt{-} & 45 & & Hyphen \\
	\hline
	\texttt{.} & 46 & & Period, dot \\
	\hline
	\texttt{/} & 47 & & Slash \\
	\hline
	\texttt{0} & 48 & & Zero \\
	\hline
	\texttt{1} & 49 & & One \\
	\hline
	\texttt{2} & 50 & & Two \\
	\hline
	\texttt{3} & 51 & & Three \\
	\hline
	\texttt{4} & 52 & & Four \\
	\hline
	\texttt{5} & 53 & & Five \\
	\hline
	\texttt{6} & 54 & & Six \\
	\hline
	\texttt{7} & 55 & & Seven \\
	\hline
	\texttt{8} & 56 & & Eight \\
	\hline
	\texttt{9} & 57 & & Nine \\
	\hline
	\texttt{:} & 58 & & Colon \\
	\hline
	\texttt{;} & 59 & & Semicolon \\
	\hline
	\texttt{<} & 60 & & Less-than sign \\
	\hline
	\texttt{=} & 61 & & Equal sign \\
	\hline
	\texttt{>} & 62 & & Greater-than sign \\
	\hline
	\texttt{?} & 63 & & Question mark \\
	\hline
	\texttt{@} & 64 & & At sign \\
	\hline
	\texttt{A} & 65 & & Uppercase A \\
	\hline
	\texttt{B} & 66 & & Uppercase B \\
	\hline
	\texttt{C} & 67 & & Uppercase C \\
	\hline
	\texttt{D} & 68 & & Uppercase D \\
	\hline
	\texttt{E} & 69 & & Uppercase E \\
	\hline
	\texttt{F} & 70 & & Uppercase F \\
	\hline
	\texttt{G} & 71 & & Uppercase G \\
	\hline
	\texttt{H} & 72 & & Uppercase H \\
	\hline
	\texttt{I} & 73 & & Uppercase I \\
	\hline
	\texttt{J} & 74 & & Uppercase J \\
	\hline
	\texttt{K} & 75 & & Uppercase K \\
	\hline
	\texttt{L} & 76 & & Uppercase L \\
	\hline
	\texttt{M} & 77 & & Uppercase M \\
	\hline
	\texttt{N} & 78 & & Uppercase N \\
	\hline
	\texttt{O} & 79 & & Uppercase O \\
	\hline
	\texttt{P} & 80 & & Uppercase P \\
	\hline
	\texttt{Q} & 81 & & Uppercase Q \\
	\hline
	\texttt{R} & 82 & & Uppercase R \\
	\hline
	\texttt{S} & 83 & & Uppercase S \\
	\hline
	\texttt{T} & 84 & & Uppercase T \\
	\hline
	\texttt{U} & 85 & & Uppercase U \\
	\hline
	\texttt{V} & 86 & & Uppercase V \\
	\hline
	\texttt{W} & 87 & & Uppercase W \\
	\hline
	\texttt{X} & 88 & & Uppercase X \\
	\hline
	\texttt{Y} & 89 & & Uppercase Y \\
	\hline
	\texttt{Z} & 90 & & Uppercase Z\\
	\hline
	\texttt{[} & 91 & & Left square bracket \\
	\hline
	\texttt{\textbackslash} & 92 & & Backslash \\
	\hline
	\texttt{]} & 93 & & Right square bracket \\
	\hline
	\texttt{\textasciicircum} & 94 & & Circumflex accent\\
	\hline
	\texttt{\_} & 95 & & Underscore \\
	\hline
	\texttt{`} & 96 & & Grave accent \\
	\hline
	\texttt{a} & 97 & & Lowercase a \\
	\hline
	\texttt{b} & 98 & & Lowercase b \\
	\hline
	\texttt{c} & 99 & & Lowercase c \\
	\hline
	\texttt{d} & 100 & & Lowercase d \\
	\hline
	\texttt{e} & 101 & & Lowercase e \\
	\hline
	\texttt{f} & 102 & & Lowercase f \\
	\hline
	\texttt{g} & 103 & & Lowercase g \\
	\hline
	\texttt{h} & 104 & & Lowercase h \\
	\hline
	\texttt{i} & 105 & & Lowercase i \\
	\hline
	\texttt{j} & 106 & & Lowercase j \\
	\hline
	\texttt{k} & 107 & & Lowercase k \\
	\hline
	\texttt{l} & 108 & & Lowercase l \\
	\hline
	\texttt{m} & 109 & & Lowercase m \\
	\hline
	\texttt{n} & 110 & & Lowercase n \\
	\hline
	\texttt{o} & 111 & & Lowercase o \\
	\hline
	\texttt{p} & 112 & & Lowercase p \\
	\hline
	\texttt{q} & 113 & & Lowercase q \\
	\hline
	\texttt{r} & 114 & & Lowercase r \\
	\hline
	\texttt{s} & 115 & & Lowercase s \\
	\hline
	\texttt{t} & 116 & & Lowercase t \\
	\hline
	\texttt{u} & 117 & & Lowercase u \\
	\hline
	\texttt{v} & 118 & & Lowercase v \\
	\hline
	\texttt{w} & 119 & & Lowercase w \\
	\hline
	\texttt{x} & 120 & & Lowercase x \\
	\hline
	\texttt{y} & 121 & & Lowercase y \\
	\hline
	\texttt{z} & 122 & & Lowercase z \\
	\hline
	\texttt{\{} & 123 & & Left curly brace \\
	\hline
	\texttt{|} & 124 & & Vertical bar \\
	\hline
	\texttt{\}} & 125 & & Right curly brace \\
	\hline
	\texttt{\textasciitilde} & 126 & & Tilde \\
	\hline
	& 127 & DEL (Ctrl-?) & Delete \\
	\hline
\end{xltabular}

\subsection{Etichette ed istruzioni di salto}
In Assembly non esiste il costrutto \texttt{if} ... \texttt{then} ... \texttt{else}
e quindi le istruzioni di salto
servono per far saltare l'esecuzione del programma ad una certa istruzione in funzione
del valore di una condizione. Le uniche condizioni che si possono valutare sono \(<,=,>\) tra
due valori numerici e la presenza di zero nel registro ECX. In particolare, la valutazione
di una condizione di \(<,=,>\) consiste di due istruzioni: la prima sottrae tra loro i due valori
numerici e imposta i bit SF e ZF del registro EFLAGS, la seconda effettua il salto in base
al valore di tali flags.

\noindent Le etichette sono essenziali per le istruzioni di salto in quanto indicano a quale punto
della sequenza di istruzioni bisogna saltare. Occorre inserire prima dell'istruzione a cui
si vuole saltare un nome simbolico seguito dal carattere “\texttt{:}”. Ad esempio:
\begin{lstlisting}[language={[x86masm]Assembler}]
  etichetta:
    istruzioni
    ...
\end{lstlisting}
È importante che il nome dell'etichetta sia unico in tutto il programma. Anche in questo
caso, come per i nomi delle variabili, l'assemblatore trasforma i nomi delle etichette
in numeri binari (che in questo caso indicano l'indirizzo dell'istruzione che segue) a
meno che non si voglia conservarli per il debug (con l'opzione \texttt{--gstabs}).

\noindent In Assembly non esistono istruzioni ad alto livello per realizzare i cicli come \texttt{for} ...,
\texttt{while} ...; essi si devono costruire manualmente a partire dalle istruzioni di salto
condizionato. Se si vuole eseguire un ciclo per un certo numero di volte occorre utilizzare
ECX come contatore.

% Fine laboratorio

\section{Architettura di Von Neumann}
L'esigenza era quella di avere un'architettura che permettesse di eseguire programmi
in modo automatico, senza dover cambiare il cablaggio del calcolatore, quindi il circuito
deve essere abbastanza generale per poter eseguire programmi diversi.

\subsection{Struttura}
L'architettura di Von Neumann è composta da 5 parti principali:
\begin{itemize}
	\item \textbf{Unità aritmetico-logica}: si occupa di eseguire le operazioni aritmetiche e logiche
	\item \textbf{Unità di controllo}: si occupa di controllare il flusso delle istruzioni
	\item \textbf{Memoria}: contiene i dati e le istruzioni
	\item \textbf{Input/Output}: permette di comunicare con l'esterno
	\item \textbf{Bus}: permette di trasferire i dati tra la memoria e l'unità aritmetico-logica (generalmente in oro)
\end{itemize}

\begin{figure}[H]
	\centering
	\begin{tikzpicture}
		% CPU
		\node[draw, rectangle, minimum width=2cm, minimum height=1.5cm] (cpu) at (0, 0) {\textbf{CPU}};
		% Memoria
		\node[draw, rectangle, align=center, minimum width=2cm, minimum height=1.5cm] (memory) at (4, 0) {\textbf{Memoria}\\\footnotesize Dati\\\footnotesize Istruzioni};

		% Bus
		\draw (-2,-2) -- (6.5,-2) node[right] {Bus};
		\draw[<->] (cpu) -- ++(0,-2);
		\draw[<->] (memory) -- ++(0,-2);

		% Input/Output below bus
		\node[draw, rectangle, minimum width=0.7cm, minimum height=0.7cm] (io) at (2, -3) {\textbf{I/O}};
		\draw[<->] (io) -- (2,-2);

		% Keyboard and mouse below I/O
		\node (keyboard) at (1, -4) {Tastiera};
		\node (mouse) at (3, -4) {Mouse};
		\draw[->] (keyboard) -- (io);
		\draw[->] (mouse) -- (io);


	\end{tikzpicture}
\end{figure}

\subsection{Caratteristiche}
Le istruzioni hanno bisogno di un'operazione che permetta di effettuare dei salti,
in modo da poter implementare i cicli e le strutture di controllo. Inoltre le istruzioni
devono essere eseugite in sequenza (un'istruzione alla volta).

\subsection{CPU}
Ogni processore ha un set di istruzioni diverso in base all'architettura,
questo set di istruzioni è chiamato \textbf{ISA} (Instruction Set Architecture).
\textbf{Assembly} è un linguaggio di programmazione che permette di scrivere programmi
in base all'ISA del processore e questo linguaggio viene tradotto in linguaggio binario
attraverso un \textbf{assembler}. In questo corso viene usata l'architettura x86 (80x86).

\subsubsection{Modello semplificato}
Per rappresentare il funzionamento di un processore si può usare un modello semplificato
rappresentato ad alto livello. Questo modello è composto da:
\begin{itemize}
	\item \textbf{Central Processing Unit (CPU)}: esegue le istruzioni
	\item \textbf{Control Unit (CU)}: controlla il flusso delle istruzioni
	\item \textbf{Bus Dati (BD)}: trasferisce i dati alla CPU
	\item \textbf{Bus Istruzioni (BI)}: trasferisce le istruzioni alla CPU
	\item \textbf{Bus di Controllo (BC)}: trasferisce i segnali di controllo
	\item \textbf{Memory Address Register (MAR)}: contiene l'indirizzo di memoria da leggere
	\item \textbf{Memory Data Register (MDR)}: contiene i dati letti dalla memoria
	\item \textbf{Program Counter (PC)}: tiene conto dell'indirizzo dell'istruzione da eseguire
	\item \textbf{Instruction Register (IR)}: contiene l'istruzione corrente
	\item \textbf{Program Status Word (PSW)}: contiene i flag del processore (es. zero, carry, overflow).
	      È come se fosse un array in cui ad ogni indice corrisponde un flag per ogni operazione.
	\item \textbf{Register File}: contiene i registri del processore (es. EAX, EBX, ECX, EDX, ESI, EDI, ESP, EBP)
	\item \textbf{Arithmetic Logic Unit (ALU)}: esegue le operazioni aritmetiche e logiche
\end{itemize}
\begin{figure}[H]
	\centering
	\begin{tikzpicture}[scale=1.5]
		\draw (0,0) rectangle (4,4);
		\node[above left, scale=0.7] at (4,0) {CPU};

		\draw (2,2) rectangle (4,4);
		\node[above left, scale=0.7] at (3.4,2) {CU};

		\node[draw, rectangle, align=center, scale=0.8, minimum width=1cm, minimum height=0.8cm] (pc) at (2.4, 2.35) {PC};
		\node[draw, rectangle, align=center, scale=0.8, minimum width=1cm, minimum height=0.8cm] (ir) at (2.4, 2.95) {IR};
		\node[draw, rectangle, align=center, scale=0.8, minimum width=1cm, minimum height=0.5cm] (psw) at (3.4, 3.55) {PSW};

		% Bus Istruzioni
		\draw (-0.5,0) -- (-0.5,4) node[above, scale=0.7] {BI};

		% Bus Dati
		\draw (-1,0) -- (-1,4) node[above, scale=0.7] {BD};

		% Bus di controllo
		\draw (4.5,0) -- (4.5,4) node[above, scale=0.7] {BC};

		% MAR (Memory Address Register)
		\node[draw, rectangle, align=center, scale=0.8, minimum width=0.5cm, minimum height=0.5cm] (mar) at (0.5, 3) {M\\A\\R};
		\draw[latex-latex] (mar) -- (-0.5,3);

		% MDR (Memory Data Register)
		\node[draw, rectangle, align=center, scale=0.8, minimum width=0.5cm, minimum height=0.5cm] (mdr) at (0.5, 1) {M\\D\\R};
		\draw[latex-latex] (mdr) -- (-1,1);

		\draw[latex-latex] (4,3) -- (4.5,3);

		% Register file
		\draw (1,0.4) rectangle (2,1.6);
		\draw (1,0.6) -- (2,0.6);
		\draw (1,0.8) -- (2,0.8);
		\draw (1,1) -- (2,1);
		\draw (1,1.2) -- (2,1.2);
		\draw (1,1.4) -- (2,1.4);

		\node[below left, xshift=8, scale=0.7] at (1.82,0.4) {Register File};

		% ALU
		\draw (2.7,0.5) -- (3.3,0.5) -- (3.5,1.5) -- (3.2,1.5) -- (3,1.2) -- (2.8,1.5) -- (2.5,1.5) -- cycle;
		\node[above, scale=0.6] at (3,0.5) {ALU};

		% Collegamenti
		\draw[latex-] (2.6,1.5) -- ++(0,0.2) -- ++(-0.8,0) -- ++(0,-0.1);
		\draw[latex-] (3.4, 1.5) -- ++(0,0.4) -- ++(-2.2,0) -- ++(0,-0.3);
		\draw[-latex] (3.4,1) -- ++(0.4,0) -- ++(0,2) -- ++(-0.2,0) -| (psw);
		\draw[-latex] (3,0.5) -- ++(0,-0.3) -- ++(-0.5,0) -- ++(0,0.3) -- ++(-0.5,0);
		\draw[-latex] (2.3,2) -- ++(0,-1) -- ++(0.3,0);
	\end{tikzpicture}
	\caption{Struttura di un processore}
\end{figure}

\noindent Il flusso di esecuzione delle istruzioni è il seguente:
\begin{itemize}
	\item \textbf{Fetch}: CU legge l'istruzione dalla memoria
	\item \textbf{Decode}: CU decodifica l'istruzione
	\item \textbf{Execute}: ALU esegue l'istruzione
\end{itemize}

\begin{figure}[H]
	\centering
	\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=3cm,
			thick,main node/.style={circle,draw,font=\sffamily\Large\bfseries}]

		\node[main node] (1) {\footnotesize Fetch};
		\node[main node] (2) [right of=1] {\footnotesize Decode};
		\node[main node] (3) [right of=2] {\footnotesize Execute};

		\path[every node/.style={font=\sffamily\small}]
		(1) edge [bend left] node {} (2)
		(2) edge [bend left] node {} (3)
		(3) edge [bend left] node {} (1);
	\end{tikzpicture}
	\caption{Flusso di esecuzione delle istruzioni}
\end{figure}

\subsection{Modello concreto (LC-3)}
L'LC-3 è un processore Turing complete, ovvero può eseguire qualsiasi programma. È un
processore che nasce per motivi didattici, molto semplice e permette di capire come
funziona un processore. L'LC-3 è composto da:
\begin{itemize}
	\item \textbf{Memoria}:
	      \begin{itemize}
		      \item \textbf{MAR}: Memory Address Register, contiene l'indirizzo di memoria da leggere
		      \item \textbf{MDR}: Memory Data Register, contiene i dati letti dalla memoria
	      \end{itemize}
	\item \textbf{Processing Unit}:
	      \begin{itemize}
		      \item \textbf{ALU}
		      \item \textbf{Registri}: 8 registri da 16 bit
	      \end{itemize}
	\item \textbf{Input}:
	      \begin{itemize}
		      \item \textbf{Tastiera}
		      \item \textbf{Mouse}
		      \item \textbf{Scanner}
		      \item \textbf{Disco}
	      \end{itemize}
	\item \textbf{Output}:
	      \begin{itemize}
		      \item \textbf{Monitor}
		      \item \textbf{Stampante}
		      \item \textbf{LED}
		      \item \textbf{Disco}
	      \end{itemize}
	      L'imput e l'output non vengono gestiti direttamente dai dispositivi, ma vengono
	      gestiti dalla memoria.
	\item \textbf{Control Unit}:
	      \begin{itemize}
		      \item \textbf{PC}: Program Counter, contiene l'indirizzo dell'istruzione da eseguire
		      \item \textbf{IR}: Instruction Register, contiene l'istruzione corrente
	      \end{itemize}
\end{itemize}

\subsubsection{Memoria}
\( 2^16 \times 16 \) celle di memoria. Per interfacciarsi con la memoria si usa la
\texttt{LOAD} e la \texttt{STORE}.

\vspace{1em}
\noindent I registri sono 8 e vanno da \( R0, \ldots, R7 \) ognuno da 16 bit. La dimensione
della parola del processore è di 16 bit. Anche le istruzioni sono di 16 bit.

\subsubsection{Processing Unit}
Questa unità può eseguire 3 operazioni:
\begin{itemize}
	\item \textbf{ADD}
	\item \textbf{AND}
	\item \textbf{NOT}
\end{itemize}

\subsubsection{Input e Output}
Ci sono 2 tipi di periferiche:
\begin{itemize}
	\item \textbf{A caratteri}: tastiera, mouse, scanner. Sono periferiche che comunicano
	      con il processore inviando un carattere alla volta.
	\item \textbf{A blocchi}: monitor, stampante, disco. Sono periferiche che comunicano
	      con il processore inviando un blocco di dati alla volta.
\end{itemize}
L'input e l'output viene gestito direttamente dalla CPU, quindi non c'è nessun componente
esterno che lo fa.
\begin{itemize}
	\item Per gestire la tastiera ci sono 2 registri:
	      \begin{itemize}
		      \item \textbf{KBDR}: Keyboard Data Register, contiene il carattere letto dalla tastiera
		      \item \textbf{KBSR}: Keyboard Status Register, contiene lo stato della tastiera
	      \end{itemize}
	\item Per gestire il monitor ci sono 2 registri:
	      \begin{itemize}
		      \item \textbf{DDR}: Display Data Register, contiene il carattere da scrivere sul monitor
		      \item \textbf{DSR}: Display Status Register, contiene lo stato del monitor
	      \end{itemize}
\end{itemize}

\subsubsection{Processazione delle istruzioni}
Il loop di esecuzione delle istruzioni è il seguente:
\begin{itemize}
	\item \textbf{Fetch}: legge l'istruzione dalla memoria
	\item \textbf{Decode}: decodifica l'istruzione
	\item \textbf{Evaluate address}: calcola l'indirizzo dell'operando
	\item \textbf{Fetch operands}: legge gli operandi dalla memoria
	\item \textbf{Execute}: esegue l'istruzione
	\item \textbf{Store result}: scrive il risultato nella memoria
\end{itemize}

\subsubsection{Istruzioni}
Le istruzioni sono di 16 bit e sono specificate nel seguente modo:
\begin{itemize}
	\item \textbf{opcode}: specifica l'operazione da eseguire
	\item \textbf{operands}: dati o indirizzi su cui operare
\end{itemize}
Ogni istruzione è codificata come una sequenza di bit ed è il componente più piccolo
e non interrompibile del sistema.

\vspace{1em}
\noindent La specifica di come sono fatte le istruzioni è chiamata \textbf{ISA}
(Instruction Set Architecture).

\subsubsection{Operazioni}
\begin{itemize}
	\item \textbf{Operazioni di calcolo}:
	      \begin{itemize}
		      \item \textbf{ADD}: somma due numeri
		      \item \textbf{AND}: effettua l'AND bit a bit tra due numeri
		      \item \textbf{NOT}: effettua il NOT bit a bit di un numero
	      \end{itemize}
	\item \textbf{Operazioni di movimento dei dati}:
	      \begin{itemize}
		      \item \textbf{LD}
		      \item \textbf{LDI}
		      \item \textbf{LDR}
		      \item \textbf{LEA}
		      \item \textbf{ST}
		      \item \textbf{STR}
		      \item \textbf{STI}
	      \end{itemize}
	\item \textbf{Operazioni di controllo}:

	      \noindent Sono gestite da 3 flag:
	      \begin{itemize}
		      \item \textbf{N}: negativo
		      \item \textbf{Z}: zero
		      \item \textbf{P}: positivo
	      \end{itemize}
	      Le operazioni sono:
	      \begin{itemize}
		      \item \textbf{BR}
		      \item \textbf{JMP}
		      \item \textbf{JSR}
		      \item \textbf{JSRR}
		      \item \textbf{RTI}
		      \item \textbf{TRAP}
	      \end{itemize}
\end{itemize}

I tipi di dato sono gestiti come 16 bit codificati in complemento a 2.

\subsubsection{Metodi di indirizzamento}
\begin{itemize}
	\item \textbf{Immediate}: l'operando è un valore costante
	\item \textbf{Register}: l'operando è un registro
	\item \textbf{PC-relative}: l'operando è un offset rispetto al PC
	\item \textbf{Indirect}: l'operando è un indirizzo in memoria
	\item \textbf{Base+offset}: l'operando è un indirizzo in memoria calcolato come somma di un registro e un offset
\end{itemize}

\section{Assembly (Intel x86)}
\subsection{Codifica}
Ogni istruzione è codificata nel seguente modo:

\begin{figure}[H]
	\centering
	\begin{tikzpicture}
		% Opcode
		\draw (0,0) rectangle (1.5,1);
		\node at (0.75,0.5) {Opcode};

		% Metodi di indirizzamento
		\draw (1.8,0) -- (1.8,1);
		\node[align=center, scale=0.7] at (1.65,0.5) {M\\I};

		% Source
		\draw (1.5,0) rectangle (3.6,1);
		\node at (2.55,0.5) {Source};

		% Metodi di indirizzamento
		\draw (3.3,0) -- (3.3,1);
		\node[align=center, scale=0.7] at (3.45,0.5) {M\\I};

		% Destination
		\draw (3.6,0) rectangle (5.6,1);
		\node at (4.6,0.5) {Destination};

	\end{tikzpicture}
\end{figure}

\noindent dove \textbf{MI} indica il metodo di indirizzamento.

\subsection{Istruzioni}
\subsubsection{Istruzioni di inizializzazione}
\begin{itemize}
	\item \textbf{\texttt{MOVL <source> <destination>}}: copia il contenuto di un registro (o costante) in un altro.
	      Questa istruzione di solito viene utilizzata per spostare i valori dalla memoria ai
	      registri e viceversa, in modo da poter effettuare operazioni solo su dati presenti
	      nei registri e non direttamente in memoria, questo rende l'esecuzione più efficiente.
	\item \textbf{\texttt{NOP}}: non fa nulla e occupa solo un byte. La sua utilità è quella
	      di "riempire i buchi", cioè delle zone di memoria non occupate da nessuna istruzione.
\end{itemize}

\subsubsection{Istruzioni aritmetiche}
\begin{itemize}
	\item \textbf{\texttt{ADDL <source> <destination>}}: somma il contenuto di due registri (o costante).
	      Siccome sono disponibili solo 2 parametri, il risultato viene salvato nel secondo parametro
	      perchè viene visto sia come sorgente che destinazione per evitare di aggiungerne un terzo.
	\item \textbf{\texttt{SUBL <source> <destination>}}: sottrae il contenuto di due registri (o costante)
	\item \textbf{\texttt{MULL <source> <destination>}}: moltiplica il contenuto di due registri (o costante)
	\item \textbf{\texttt{INC <source>}}: incrementa il contenuto di un registro (o costante) di 1
	\item \textbf{\texttt{DEC <source>}}: decrementa il contenuto di un registro (o costante) di 1
\end{itemize}

\subsubsection{Istruzioni logiche}

\begin{itemize}
	\item \textbf{\texttt{CMPL <source> <destination>}}: confronta il contenuto di due registri (o costanti) e
	      modifica il flag \textbf{\texttt{PSW}} in base al risultato del confronto.
\end{itemize}

\subsubsection{Istruzioni di salto}
Se il salto è \textbf{assoluto} l'indirizzo fa riferimento alla memoria diretta, mentre se il salto è
\textbf{relativo} l'indirizzo è relativo al Program Counter.
\begin{itemize}
	\item \textbf{\texttt{JMP <etichetta>}}: salta all'istruzione con etichetta
	\item \textbf{\texttt{JE <etichetta>}}: salta all'istruzione con etichetta se i flag sono settati in modo che i due operandi siano uguali
	\item \textbf{\texttt{JNE <etichetta>}}: salta all'istruzione con etichetta se i flag sono settati in modo che i due operandi siano diversi
	\item \textbf{\texttt{JG <etichetta>}}: salta all'istruzione con etichetta se i flag sono settati in modo che il primo operando sia maggiore del secondo
	\item \textbf{\texttt{JGE <etichetta>}}: salta all'istruzione con etichetta se i flag sono settati in modo che il primo operando sia maggiore o uguale del secondo
	\item \textbf{\texttt{JL <etichetta>}}: salta all'istruzione con etichetta se i flag sono settati in modo che il primo operando sia minore del secondo
	\item \textbf{\texttt{JLE <etichetta>}}: salta all'istruzione con etichetta se i flag sono settati in modo che il primo operando sia minore o uguale del secondo
\end{itemize}
Comparando e poi utilizzando i salti si possono implementare le strutture di controllo come i cicli e le condizioni.
Nell'etichetta si può inserire un'indirizzo di memoria assoluto che permette di saltare a quell'indirizzo,
questo però non è molto utile perchè il programma potrebbe essere caricato in un'area diversa della memoria.

\subsubsection{Istruzioni di gestione dello Stack}
\begin{itemize}
	\item \textbf{\texttt{PUSHL <source>}}: inserisce il contenuto di un registro (o costante) nello stack
	\item \textbf{\texttt{POPL <destination>}}: estrae il contenuto dello stack e lo mette in un registro (o costante)
	\item \textbf{\texttt{CALL <etichetta>}}: salva l'indirizzo successivo al Program Counter nello stack e salta all'istruzione con etichetta
\end{itemize}

\subsubsection{Metodi di indirizzamento}
I metodi di indirizzamento (MI) sono diversi modi per accedere ai dati in memoria, i
più comuni sono:
\begin{itemize}
	\item \textbf{Registro}: Un'istruzione può accedere direttamente ai registri
	      ad esempio: \texttt{MOVL \%EAX, \%EBX}
	\item \textbf{Immediato}: Un'istruzione può accedere direttamente ai dati
	      ad esempio: \texttt{MOVL \$10, \%EBX}
	\item \textbf{Assoluto}: Un'istruzione può accedere direttamente ai dati
	      ad esempio: \texttt{MOVL DATO, \%EBX}\\
	      dove \texttt{DATO} è un'etichetta che punta ad un'indirizzo di memoria
	\item \textbf{Indiretto Registro}: Un'istruzione può contenere un registro che punta ad un altro registro
	      ad esempio: \texttt{MOVL (\%EAX), \%EBX}
	\item \textbf{Indiretto Registro con Spiazzamento}: Un'istruzione può mettere un offset
	      rispetto al registro contenuto nell'istruzione
	      ad esempio: \texttt{MOVL \$8(\%EAX), \%EBX}
\end{itemize}

\noindent Non tutte le istruzioni ammettono tutti i metodi di indirizzamento e alcuni metodi di indirizzamento
possono essere usati solo con alcune istruzioni.

\subsection{Esempi}
Un esempio di codice in C è il seguente:
\begin{lstlisting}[language=C]
  ...
  int a; // INDA (etichetta che punta ad un indirizzo di memoria con valore intero)
  int b; // INDB
  int c; // INDB
  ...
  a = 5; // %EAX
  b = 10; // %EBX

  if (a > b) {
    c = a - b; // %ECX
  } else { // ELSE
    c = a + b;
  }
  \end{lstlisting}

La traduzione in assembly è la seguente:
\begin{lstlisting}[language={[x86masm]Assembler}]
  MOVL INDA, %EAX // Ridondante
  MOVL $5, %EAX
  MOVL INDB, %EBX // Ridondante
  MOVL $10, %EBX
  MOVL %EAX, %ECX
  COMPL %EAX, %EBX
  JLE ELSE
  SUBL %ECX, %EAX
  JMP ENDIF
  ELSE:
  ADDL %EBX, %ECX
  ENDIF:
\end{lstlisting}

\noindent Un altro esempio di un for loop in C:
\begin{lstlisting}[language=C]
  for (int i = 0; i < 10; i++) { // int i; %EDX
    ...
  }
\end{lstlisting}

\noindent La traduzione in assembly è la seguente:
\begin{lstlisting}[language={[x86masm]Assembler}]
  MOVL $0, %EDX
  FOR:
  COMPL $10, %EDX
  JE ENDFOR
  ...
  INC %EDX
  JMP FOR
  ENDFOR:
\end{lstlisting}

\subsection{File assembly}
Un file assembly ha estensione \texttt{.s} e può contenere diverse sezioni:
\begin{itemize}
	\item \textbf{.section .data}: contiene le variabili globali e le costanti
	      \begin{lstlisting}[language={[x86masm]Assembler}]
  .section .data
  hello:
    .ascii "Hello, world!\n" ; Dichiarazione di una stringa costante

  hello_len:
    .long . - hello ; Lunghezza della stringa (posizione corrente (.) - posizione iniziale)
  \end{lstlisting}

	\item \textbf{.section .text}: contiene il codice assembly composto da istruzioni, etichette
	      e sottoprogrammi
	      \begin{lstlisting}[language={[x86masm]Assembler}]
  .section .text
  .global _start ; Nome convenzionale del punto di inizio del programma
  _start:
    movl ...
    ...
  \end{lstlisting}

	\item \textbf{.section .bss}: contiene le variabili globali non inizializzate (spazio da riservare)
\end{itemize}

\subsection{Compilazione}
Per compilare un file assembly si compiono i seguenti passi:
\begin{enumerate}
	\item \textbf{Compilazione}: si compila il file assembly con il comando \texttt{as} che
	      crea un file binario (\texttt{.o}) contenente
	      l'implementazione di ogni singolo file.
	\item \textbf{Linking}: si uniscono i file binari con il comando \texttt{ld} che crea un file eseguibile
	      a partire dai file binari.
	\item \textbf{Esecuzione}: si rende eseguibile il file e si esegue con il comando \\\texttt{./<nomefile>}
\end{enumerate}


\section{Memoria}
La memoria è una lista indicizzata di celle, a cui ognuna è associata un indirizzo.
La memoria è composta da due parti principali:
\begin{itemize}
	\item \textbf{Codice}: contiene le istruzioni
	\item \textbf{Dati statici}: contiene i dati
\end{itemize}

\noindent Non si può sapere a priori dove verrà caricato il programma in memoria, quindi
è necessario utilizzare lo spostamento relativo per accedere ai dati e alle istruzioni.

\begin{figure}[H]
	\centering
	\begin{tikzpicture}
		\draw (0,0) rectangle (2,1);
		\node at (1,0.5) {Codice};

		\draw (0,0) rectangle (2,-2);
		\node at (1,-1) {Istruzioni};

		\draw (0,-2) rectangle (2,-4);
		\node[align=center] at (1,-3) {Dati\\statici};

		\draw[<-] (0,-0.2) -- ++(-0.5,0) node[left] {Program Counter};
	\end{tikzpicture}
	\caption{Struttura della memoria}
\end{figure}

\begin{figure}[H]
	\begin{define}
		\textbf{Footprint}: è l'area di memoria occupata da un programma:
		\begin{itemize}
			\item \textbf{L}: 32 bit
			\item \textbf{V}: 16 bit
			\item \textbf{B}: 8 bit
		\end{itemize}
	\end{define}
\end{figure}

\subsection{Memoria dinamica}
La parte dei dati è composta da due parti principali:
\begin{itemize}
	\item \textbf{Heap}: contiene le variabili allocate dinamicamente e ha una dimensione variabile
	\item \textbf{Stack}: contiene le variabili locali e i parametri delle funzioni. Ha una dimensione fissa
	      e limitata. Lo stack cresce con la modalità \textbf{LIFO} (Last In First Out), cioè l'ultimo
	      elemento inserito è il primo ad essere estratto e nell'architettura x86 cresce verso l'alto.
	      Lo stack è composto da 2 puntatori:
	      \begin{itemize}
		      \item \textbf{ESP} (Extended Stack Pointer): punta all'ultimo elemento inserito nello stack
		      \item \textbf{EBP} (Extended Base Pointer): punta alla base dello stack
	      \end{itemize}
\end{itemize}

\begin{figure}[H]
	\centering
	\begin{tikzpicture}
		\draw (0,0) rectangle (2,1);
		\node[align=center] at (1,0.5) {Dati\\Statici};

		\draw (0,0) rectangle (2,-2);
		\node[align=center] at (1,-1) {Variabili\\dinamiche};

		\draw (0,-2) rectangle (2,-4.1);
		\node at (1,-2.3) {Stack};

		\draw (0,-2.6) -- (2,-2.6) node[midway, below, yshift=-1, scale=0.8] {...};
		\draw (0,-2.9) -- (2,-2.9) node[midway, below, yshift=1, scale=0.8] {b};
		\draw (0,-3.2) -- (2,-3.2) node[midway, below, yshift=1, scale=0.8] {a};
		\draw (0,-3.5) -- (2,-3.5) node[midway, below, yshift=1, scale=0.8] {y};
		\draw (0,-3.8) -- (2,-3.8) node[midway, below, yshift=1, scale=0.8] {x};


		\draw[<-] (0,-3.2) -- ++(-0.5,0) node[left] {ESP};
		\draw[<-] (0,-3.8) -- ++(-0.5,0) node[left] {EBP};
	\end{tikzpicture}
	\caption{Struttura della memoria}
\end{figure}

\noindent Per gestire i dati nello stack si utilizzano le seguenti istruzioni:
\begin{itemize}
	\item \textbf{\texttt{PUSHL <source>}}: inserisce il contenuto di un registro (o costante) nello stack
	\item \textbf{\texttt{POPL <destination>}}: estrae il contenuto dello stack e lo mette in un registro (o costante)
\end{itemize}

\subsection{Richiamare una funzione}
Per richiamare una funzione bisogna far saltare il Program Counter all'indirizzo della funzione
e poi salvare l'indirizzo successivo nello stack. Per fare ciò si utilizza l'istruzione \texttt{CALL}.
\begin{itemize}
	\item \textbf{\texttt{CALL <etichetta>}}: salva l'indirizzo successivo al Program Counter nello stack e salta all'istruzione con etichetta.
	      Quando la funzione termina, per tornare al punto di chiamata si utilizza l'istruzione \texttt{RET}.
	\item \textbf{\texttt{RET}}: estrae l'indirizzo successivo al Program Counter dallo stack e salta a quell'indirizzo (torna al punto di chiamata).
\end{itemize}

Per recuperare i dati in memoria si utilizza l'istruzione \texttt{LEAL} (Load Effective Address):
\begin{itemize}
	\item \textbf{\texttt{LEAL <source>, <destination>}}: prende l'indirizzo di memoria in cui è stato salvato qualcosa
	      e lo mette in un registro
\end{itemize}

\subsection{Struttura dettagliata della CPU}
Di seguito è riportato uno schema più dettagliato dei componenti della CPU
in modo da capire come vengono eseguite le istruzioni.
\begin{figure}[H]
	\centering
	\begin{tikzpicture}[scale=1.5]
		\draw (-1,-3) rectangle (3.5,5.4);
		\node[above left] at (3.5,-3) {CPU};

		\draw (2,2) rectangle (3,3);
		\node[above left, scale=0.7] at (2.4,2) {CU};
		\draw[latex-latex] (3,2.5) -- (4,2.5);

		\draw[-latex, dashed] (2.2,3) -- ++(0,0.5) node[above, scale=0.7] {$PC_{in}$};
		\draw[-latex, dashed] (2.4,3) -- ++(0,0.5);
		\draw[-latex, dashed] (2.6,3) -- ++(0,0.5);
		\draw[-latex, dashed] (2.8,3) -- ++(0,0.5) node[above, scale=0.7, xshift=8] {$PC_{out}$};

		\node[draw, scale=0.7] at (2.7,2.8) {PSW};

		\node[draw, scale=1] at (2.5,1.5) (ir) {IR};
		\draw[-latex] (ir) -- ++(0,0.5);
		\draw[latex-] (ir) -- ++(-1,0);


		\node[draw, rectangle, align=center, scale=0.8, minimum width=1.3cm, minimum height=0.8cm]
		(pc) at (0.8, 3.85) {PC};
		\draw (pc.west) -- ++(0,0.15) -- ++(0.15, -0.15) -- ++(-0.15,-0.15);

		% Tri state buffer
		\draw (1.2,3.3) circle (0.1) node (tristate-buffer) {};
		\draw (1.2,3.3) circle (0.1) node[below, yshift=-15, align=center, scale=0.5] {Tri-state\\buffer};
		\draw (1.2,3.3) -- ++(0.07,0.07);
		\draw (1.2,3.3) -- ++(-0.07,-0.07);
		\draw (1.2,3.3) -- ++(0.07,-0.07);
		\draw (1.2,3.3) -- ++(-0.07,0.07);
		% ----------------

		\draw[latex-] (tristate-buffer) -- ++(0,-0.3) -- ++(-0.5,0) node[left, scale=0.7]
		{$PC_{out}$};

		% Multiplexer 2 to 1
		\begin{scope}[shift={(0.67,4.5)}, scale=0.5]
			\draw (0,0) node (mux1-0) {1};
			\draw (0.5,0) node (mux1-1) {0};
			\draw (0.0,0.2) node (mux1-i0) {};
			\draw (0.5,0.2) node (mux1-i1) {};
			\draw (-0.3,0) node (mux1-s) {};
			\draw (0.25,-0.18) node (mux1-o) {};
			\draw (-0.5,0.3) -- ++(1.5,0) -- ++(-0.25, -0.6) -- ++(-1,0) -- ++(-0.25,0.6) -- (-0.5,0.3);
		\end{scope}
		\draw[-latex] (mux1-o) -- (pc);

		\draw[-latex] (pc.south) -- ++(0,-0.3) |- (tristate-buffer);
		\draw[-latex] (tristate-buffer) -- ++(0.3,0);
		\draw[-latex] (0.8,3.5) -- ++(0.5,0) -- ++(0,1.4) -| (mux1-i1);
		\draw[latex-] (mux1-i0) -- ++(0,0.5) -- ++(0.83,0);
		\draw[latex-] (mux1-s) -- ++(-0.4,0) node[left, scale=0.7] {$PC_{in}$};

		% ALU
		\begin{scope}[shift={(-2.5,-0.5)}]
			\draw (2.7,0.5) -- (3.3,0.5) -- (3.5,1.5) -- (3.2,1.5) -- (3,1.2) -- (2.8,1.5) -- (2.5,1.5) -- cycle;
			\node[above, scale=0.6] at (3,0.5) {ALU};
		\end{scope}

		% Multiplexer 4 to 1
		\begin{scope}[shift={(0,4.5)}, scale=0.5]
			\draw (-0.7,-6) node (mux4-0) {00};
			\draw (0,-6) node (mux4-1) {01};
			\draw (0.7,-6) node (mux4-2) {10};
			\draw (1.4,-6) node[scale=0.8] () {$\ldots$};
			\draw (1.4,-5.87) node (mux4-3) {};
			\draw (-0.7,-5.8) node (mux4-i0) {};
			\draw (0,-5.8) node (mux4-i1) {};
			\draw (0.7,-5.8) node (mux4-i2) {};
			\draw (1.4,-5.8) node (mux4-i3) {};
			\draw (1.7,-6) node (mux4-s) {};
			\draw (0.25,-6.18) node (mux4-o) {};
			\draw (-1.3,-5.7) -- ++(3.3,0) -- ++(-0.25, -0.6) -- ++(-2.8,0) -- ++(-0.25,0.6) -- cycle;
		\end{scope}

		% Register y
		\begin{scope}[shift={(0.1,3.5)}]
			\draw (0.25,-1) node[rectangle ,draw, minimum width=2cm, minimum height=0.7cm, scale=0.7] (y) {y};
			\draw (y.west) -- ++(0,0.15) -- ++(0.15, -0.15) -- ++(-0.15,-0.15);
		\end{scope}

		\draw[-latex] (y.east) -- ++(0.7,0);

		% Mux to alu
		\draw[latex-] (mux4-0) -- ++(0,0.4) node[above, scale=0.7] {0};
		\draw[latex-] (mux4-1) -- ++(0,0.4) node[above, scale=0.7] {4};
		\draw[latex-] (mux4-2) -- (y);
		\draw[latex-] (mux4-3) -- ++(0,0.34) node[above, scale=0.7] {cost};
		\draw[latex-] (mux4-s) -- ++(0.4,0) node[above, scale=0.7] {select};

		\draw[latex-] (0.15,1) -- ++(0,0.35);
		\draw[latex-] (0.85,1) -- ++(0,0.2) -- ++(0.65,0);

		% Alu in out
		\draw[-latex] (0.5,0) -- ++(0,-0.33);

		\draw[latex-] (0.1,0.4) -- ++(-0.5,0) node[left, align=center, scale=0.5] {ADD\\SUB\\MUL\\CR\\$\ldots$};

		% Register z
		\begin{scope}[shift={(0.25,0.5)}]
			\draw (0.25,-1) node[rectangle ,draw, minimum width=2cm, minimum height=0.7cm, scale=0.7] (z) {z};
			\draw (z.west) -- ++(0,0.15) -- ++(0.15, -0.15) -- ++(-0.15,-0.15);
		\end{scope}

		\draw[-latex] (z.east) -- ++(0.51,0);


		% MAR (Memory Address Register)
		\node[draw, rectangle, align=center, scale=0.8, minimum width=0.5cm, minimum height=0.5cm]
		(mdr) at (0.5, -2) {MDR};
		\draw[latex-latex] (mdr) -- ++(-2.5,0);
		\draw[latex-latex] (mdr) -- ++(1,0);

		% MDR (Memory Data Register)
		\node[draw, rectangle, align=center, scale=0.8, minimum width=0.5cm, minimum height=0.5cm]
		(mar) at (0.5, -1.5) {MAR};
		\draw[latex-latex] (mar) -- ++(-2,0);
		\draw[latex-] (mar) -- ++(1,0);

		% Register file
		\node[draw, scale=1] at (2.5,1.5) (ir) {IR};
		\draw (2, 0.8) rectangle (3, 1);
		\node[scale=0.7] at (2.5,0.9) {EAX};
		\draw (2, 0.6) rectangle (3, 0.8);
		\node[scale=0.7] at (2.5,0.7) {EBX};
		\draw (2, 0.4) rectangle (3, 0.6);
		\node[scale=0.7] at (2.5,0.5) {ECX};
		\draw (2, 0.2) rectangle (3, 0.4);
		\node[scale=0.7] at (2.5,0.3) {EDX};
		\draw (2, 0) rectangle (3, 0.2);
		\node[scale=0.7] at (2.5,0.1) {ESP};
		\draw (2, -0.2) rectangle (3, 0);
		\node[scale=0.7] at (2.5,-0.105) {Reg File};

		\draw[latex-latex] (2,0.4) -- ++(-0.5,0);

		% Bus CPU
		\draw (1.5,-3) -- (1.5,5.4) node[below right, scale=0.7, align=center] {Bus\\CPU};

		% Bus Istruzioni
		\draw (-1.5,-3) -- (-1.5,5.4) node[above, scale=0.7, align=center] {BI};

		% Bus Dati
		\draw (-2,-3) -- (-2,5.4) node[above, scale=0.7, align=center] {BD};

		% Bus di controllo
		\draw (4,-3) -- (4,5.4) node[above, scale=0.7, align=center] {BC};
	\end{tikzpicture}
	\caption{Schema della CPU}
\end{figure}

\noindent Da questo schema si possono notare le seguenti caratteristiche:
\begin{itemize}
	\item Nella gestione del Program Counter il segnale passa attraverso un \textbf{Buffer
		      Tri-State} che permette di disabilitare il segnale.
	\item Per mandare 2 valori alla ALU si utilizza un registro collegato ad un multiplexer
	      che permette di selezionare quale valore mandare alla ALU. Nel multiplexer sono
	      cablate anche delle costanti utili.
	\item Ogni indirizzo di memoria è gestito in \textbf{byte} indipendentemente.
	      Quindi per accedere a parole da 32 bit bisogna andare avanti di 4 byte, mentre
	      per accedere a parole da 64 bit bisogna andare avanti di 8 byte.
\end{itemize}

\section{Micro operazioni}
Le micro operazioni sono le operazioni elementari che la CPU esegue per eseguire
un'istruzione.

\begin{figure}[H]
	\begin{define}
		\textbf{CPI} (Clock Per Instruction): è il numero di cicli di clock necessari per
		eseguire un'istruzione. L'obiettivo è avere un CPI il più basso possibile.
	\end{define}
\end{figure}

\subsection{Esempi}
\begin{example}
	Andiamo ad analizzare la sequenza di micro operazioni (Fetch, Decode, Execute) per la
	seguente istruzione:
	\begin{center}
		\texttt{MOVL \%EAX, \%EBX}
	\end{center}

	\begin{enumerate}
		\item[F]
		      \begin{enumerate}
			      \item[1.] \( PC_{out},\; MAR_{in},\; READ ,\; SELECT_4,\; ADD,\; Z_{in}\) \\
			            Il Program Counter manda l'indirizzo di memoria in cui si trova l'istruzione da eseguire
			            al Memory Address Register e manda un segnale di lettura.

			            Il segnale di selezione 4 manda un segnale al multiplexer per selezionare il valore
			            da mandare alla ALU e il segnale di addizione manda un segnale alla ALU per sommare
			            4 all'indirizzo di memoria. Ciò vuol dire che l'indirizzo di memoria successivo è
			            l'indirizzo di memoria corrente + 1 word. Tutto ciò per incrementare il Program
			            Counter in modo da accedere all'istruzione successiva.

			      \item[2.] \( WMFC,\; Z_{out},\; PC_{in}\)  \\
			            \textbf{WMFC}(Wait for Memory Function to Complete): è un segnale che blocca la CPU finchè il dato viene messo nel bus dati.

			            Siccome in questo ciclo di clock il bus non viene utilizzato viene sfruttato per
			            mandare il segnale di incremento al Program Counter.

			            Il segnale di lettura manda un segnale di attesa finchè il dato non viene messo nel bus dati.
			      \item[3.] \( MDR_{out},\; IR_{in} \) \\
			            Il Memory Data Register manda il dato letto dall'indirizzo di memoria all'Instruction Register.
		      \end{enumerate}

		\item[DE]
		      \begin{enumerate}
			      \item[4.] \( EAX_{out},\; EBX_{in},\; END \) \\
			            Il contenuto del registro EAX viene mandato in uscita e viene messo in ingresso
			            al registro EBX. Successivamente viene messo a 1 il segnale di fine che fa
			            ripartire il ciclo di Fetch-Decode-Execute.
		      \end{enumerate}
	\end{enumerate}
\end{example}
\begin{figure}[H]

\end{figure}

\begin{example}
	Istruzione:
	\begin{center}
		\texttt{MOVL (\%EAX), \%EBX}
	\end{center}

	\begin{enumerate}
		\item[F]
		      \begin{enumerate}
			      \item[1.] \( PC_{out},\; MAR_{in},\; READ ,\; SELECT_4,\; ADD,\; Z_{in}\)
			      \item[2.] \( WMFC,\; Z_{out},\; PC_{in}\)
			      \item[3.] \( MDR_{out},\; IR_{in} \)
		      \end{enumerate}
		\item[D]
		      \begin{enumerate}
			      \item[4.] \( EAX_{out},\; MAR_{in},\; READ \)
			      \item[5.] \( WMFC \)
		      \end{enumerate}
		\item[E]
		      \begin{enumerate}
			      \item[6.] \( MDR_{out},\; EBX_{in},\; END \)
		      \end{enumerate}
	\end{enumerate}
\end{example}

\begin{example}
	Istruzione:
	\begin{center}
		\texttt{ADDL \$4, \%ECX}
	\end{center}

	\noindent La costante 4 è già presente nell'Instruction Register, quindi non c'è bisogno di
	andare a leggerla dalla memoria.
	\begin{enumerate}
		\item[F]
		      \begin{enumerate}
			      \item[1.] \( PC_{out},\; MAR_{in},\; READ ,\; SELECT_4,\; ADD,\; Z_{in}\)
			      \item[2.] \( WMFC,\; Z_{out},\; PC_{in}\)
			      \item[3.] \( MDR_{out},\; IR_{in} \)
		      \end{enumerate}
		\item[DE]
		      \begin{enumerate}
			      \item[4.] \( OFFSET_{IR_{out}},\; y_{in} \) \\
			            L'offset dell'Instruction Register serve per prendere il pezzo in cui è situata
			            la costante 4
			      \item[5.] \( ECX_{out},\; SELECT_{y},\;ADD,\; Z_{in} \)
			      \item[6.] \( Z_{out},\; ECX_{in},\; END \)
		      \end{enumerate}
	\end{enumerate}
\end{example}

\begin{example}
	\begin{center}
		\texttt{JZ END} \quad (salto relativo)
	\end{center}

	\noindent Il valore dell'etichetta \texttt{END} è già calcolato dall'assembler e viene memorizzato
	nell'Instruction Register
	\begin{enumerate}
		\item [F]
		      \begin{enumerate}
			      \item[1.] \( PC_{out},\; MAR_{in},\; READ ,\; SELECT_4,\; ADD,\; Z_{in}\)
			      \item[2.] \( WMFC,\; Z_{out},\; PC_{in}\)
			      \item[3.] \( MDR_{out},\; IR_{in} \)
		      \end{enumerate}
		\item[DE]
		      \begin{enumerate}
			      \item[4.] (if ZERO == 0 END) \(,\; OFFSET_{IR_{out}},\; y_{in} \)\\
			            L'if e il resto vengono eseguiti insieme, sempre
			      \item[5.] \( PC_{out},\; SELECT_{y},\; ADD,\; Z_{in} \)
			      \item[6.] \( Z_{out},\; PC_{in},\; END \)
		      \end{enumerate}
	\end{enumerate}
\end{example}

\subsection{Struttura della Control Unit}
\noindent Per rappresentare i cicli di clock delle micro istruzioni si utilizza un
registro chiamato \textbf{Micro Program Counter} che indica la prossima micro istruzione
da eseguire. È un contatore con un segnale di reset che permette di far ripartire
l'esecuzione delle micro istruzioni. Questo registro viene poi collegato ad un decoder con 16 uscite che indica il tempo
del ciclo di clock. Se il segnale \( T_2 = 1 \) allora il segnale \( PC_{in} = 1 \),
quindi \( PC_{in} = T_2 \). È presente poi un decoder che parte dall'Istruction Register e ha in uscita tutte le istruzioni
\( I_n \). Si possono così realizzare tutte le equazioni in logica combinatoria, ad esempio:
\[
	END = (I_1 + I_2 + I_3 + \ldots) \cdot T_6 + I_3 \cdot T_4 \cdot \overline{ZERO}
\]
\begin{figure}[H]
	\centering
	\begin{tikzpicture}
		\draw (0,0) rectangle (4,4);
		\node[align=center] (logica-combinatoria) at (2,2) {Logica\\combinatoria};
		\draw[-latex] (0.3,0) -- ++(0,-0.5) node[below, scale=0.7] {$PC_{in}$};
		\draw[-latex] (1.15,0) -- ++(0,-0.5) node[below, scale=0.7] {$PC_{out}$};
		\draw[-latex] (2,0) -- ++(0,-0.5) node[below, xshift=2, scale=0.7] {$MAR_{in}$};
		\draw[-latex] (2.85,0) -- ++(0,-0.5) node[below, yshift=-3, scale=0.7] {$\ldots$};
		\draw[-latex] (3.7,0) -- ++(0,-0.5) node[below, scale=0.7] {$END$} --
		++(2,0) -- ++(0,5) |- (3,5.75);


		\draw (-1,0) rectangle (-0.5,4);
		\node[label={[label distance=0cm,text depth=-1ex,rotate=-90]right:Decoder}]
		at (-0.85,2.6) {};
		\draw[-latex] (-0.5,3.6) -- (0,3.6) node[midway, above, scale=0.7] {$I_1$};
		\draw[-latex] (-0.5,3.2) -- (0,3.2) node[midway, above, scale=0.7] {$I_2$};
		\draw[-latex] (-0.5,2.8) -- (0,2.8) node[midway, above, scale=0.7] {$I_3$};
		\draw[-latex] (-0.5,2.4) -- (0,2.4);
		\draw[-latex] (-0.5,2) -- (0,2);
		\draw[-latex] (-0.5,1.6) -- (0,1.6);
		\draw[-latex] (-0.5,1.2) -- (0,1.2);
		\draw[-latex] (-0.5,0.8) -- (0,0.8);
		\draw[-latex] (-0.5,0.4) -- (0,0.4) node[midway, above, scale=0.7] {$I_{16}$};

		\draw (-2,0) rectangle (-1.5,4);
		\node[label={[label distance=0cm,text depth=-1ex,rotate=-90]right:IR}]
		at (-1.86,2.3) {};
		\draw[-latex] (-1.5,2) -- (-1,2);

		\draw (4.5,0) rectangle (5,4);
		\node[label={[label distance=0cm,text depth=-1ex,rotate=90]right:PSW}]
		at (4.65,1.5) {};
		\draw[latex-] (4,2) -- (4.5,2);

		\draw (0.5, 4.5) rectangle (3.5, 5);
		\node[align=center] at (2,4.75) {Decoder};
		\draw[latex-] (1,4) -- (1,4.5) node[midway, left, scale=0.7] {$T_1$};
		\draw[latex-] (1.5,4) -- (1.5,4.5) node[midway, left, scale=0.7] {$T_2$};
		\draw[latex-] (2,4) -- (2,4.5) node[midway, left, scale=0.7] {$T_3$};
		\node[align=center, scale=0.6] at (2.3,4.25) {$\ldots$};
		\draw[latex-] (3,4) -- (3,4.5) node[midway, left, scale=0.7] {$T_{16}$};

		\draw (1, 5.5) rectangle (3, 6);
		\node at (2,5.75) (mpc) {MPC};
		\draw (1,5.9) -- ++(0.15, -0.15) -- ++(-0.15,-0.15);
		\draw[latex-] (1,5.75) -- ++(-0.5,0) node[left, scale=0.7] {CLK};
		\draw[-latex] (2,5.5) -- (2,5);
		\draw (1.9,5.23) -- ++(0.2,0.2) node[right, yshift=-3, scale=0.7] {4};
	\end{tikzpicture}
\end{figure}

\noindent Esiste una memoria che contiene tutte le micro istruzioni chiamata \textbf{Firmware},
ma \textbf{CPU cablate} in questo modo non si realizzano più.

\subsection{Esercizi}

\begin{exercise}
	Descrivere le micro operazioni per l'istruzione:
	\begin{center}
		Fetch
	\end{center}

	\begin{enumerate}
		\item[F]
		      \begin{enumerate}
			      \item[1.] \( PC_{out},\; MAR_{in},\; READ ,\; SELECT_4,\; ADD,\; Z_{in}\) \\
			            Il Program Counter manda l'indirizzo di memoria in cui si trova l'istruzione da eseguire
			            al Memory Address Register e manda un segnale di lettura.

			            Il segnale di selezione 4 manda un segnale al multiplexer per selezionare il valore
			            da mandare alla ALU e il segnale di addizione manda un segnale alla ALU per sommare
			            4 all'indirizzo di memoria. Ciò vuol dire che l'indirizzo di memoria successivo è
			            l'indirizzo di memoria corrente + 1 word. Tutto ciò per incrementare il Program
			            Counter in modo da accedere all'istruzione successiva.

			      \item[2.] \( Z_{out},\; PC_{in},\;WMFC \)  \\
			            \textbf{WMFC}(Wait for Memory Function to Complete): è un segnale che blocca
			            la CPU finchè il dato viene messo nel bus dati.

			            Siccome in questo ciclo di clock il bus non viene utilizzato viene sfruttato per
			            mandare il segnale di incremento al Program Counter.

			            Il segnale di lettura manda un segnale di attesa finchè il dato non viene messo nel bus dati.
			      \item[3.] \( MDR_{out},\; IR_{in} \) \\
			            Il Memory Data Register manda il dato letto dall'indirizzo di memoria all'Instruction Register.
		      \end{enumerate}
	\end{enumerate}
\end{exercise}

\begin{exercise}
	Descrivere le micro operazioni per l'istruzione:
	\begin{center}
		\texttt{INC \%EAX}
	\end{center}

	\begin{enumerate}
		\item[F]
		      \begin{enumerate}
			      \item[1.] \( PC_{out},\; MAR_{in},\; READ ,\; SELECT_4,\; ADD,\; Z_{in}\)
			      \item[2.] \( Z_{out},\; PC_{in},\;WMFC \)
			      \item[3.] \( MDR_{out},\; IR_{in} \)
		      \end{enumerate}

		\item [DE]
		      \begin{enumerate}
			      \item[1.] \( EAX_{out},\; SELECT_0,\; CB,\; ADD,\; Z_{in} \)
			      \item[2.] \( Z_{out},\; EAX_{in},\; END \)
		      \end{enumerate}
	\end{enumerate}
\end{exercise}

\begin{exercise}
	Descrivere le micro operazioni per l'istruzione:
	\begin{center}
		\texttt{INC var}
	\end{center}
	Assumo la variabile come un indirizzo immediato nell'istruzione. Si fa
	riferimento ad essa con \( IR_{imm\_field} \)

	\begin{enumerate}
		\item[F]
		      \begin{enumerate}
			      \item[1.] \( PC_{out},\; MAR_{in},\; READ ,\; SELECT_4,\; ADD,\; Z_{in}\)
			      \item[2.] \( Z_{out},\; PC_{in},\;WMFC \)
			      \item[3.] \( MDR_{out},\; IR_{in} \)
		      \end{enumerate}

		\item [DE]
		      \begin{enumerate}
			      \item[1.] \( IR_{imm\_field\_out},\; MAR_{in},\; READ ,\; WMFC \)
			      \item[2.] \( MDR_{out},\; SELECT_0 ,\; CB ,\; ADD ,\; Z_{in} \)
			      \item [3.] \( Z_{out} ,\; MDR_{in} ,\; WRITE ,\; WMFC ,\; END \)
		      \end{enumerate}
	\end{enumerate}
\end{exercise}

\begin{exercise}
	Descrivere le micro operazioni per l'istruzione:
	\begin{center}
		\texttt{CALL etichetta}
	\end{center}
	Dove etichetta è un indirizzo immediato, ma relativo al program counter
	\( PC + IR_{imm\_field} \)

	\begin{enumerate}
		\item[F]
		      \begin{enumerate}
			      \item[1.] \( PC_{out},\; MAR_{in},\; READ ,\; SELECT_4,\; ADD,\; Z_{in}\)
			      \item[2.] \( Z_{out},\; PC_{in},\;WMFC \)
			      \item[3.] \( MDR_{out},\; IR_{in} \)
		      \end{enumerate}

		\item [DE]
		      \begin{enumerate}
			      \item[1.] \( ESP_{out} ,\; SELECT_4 ,\; SUB,\; Z_{in} \)
			      \item[2.] \( Z_{out},\; MAR_{in} ,\; ESP_{in} \)
			      \item[3.] \( PC_{out} ,\; MDR_{in} ,\; WRITE ,\; V_{in}\)
			      \item[4.] \( IR_{imm\_field} ,\; SELECT_V, ADD ,\; Z_{in} ,\; WMFC \)
			      \item[5.] \( Z_{out} ,\; PC_{in} ,\; END\)
		      \end{enumerate}
	\end{enumerate}
\end{exercise}

\begin{exercise}
	Descrivere le micro operazioni per l'istruzione:
	\begin{center}
		\texttt{RETURN}
	\end{center}
	\begin{enumerate}
		\item[F]
		      \begin{enumerate}
			      \item[1.] \( PC_{out},\; MAR_{in},\; READ ,\; SELECT_4,\; ADD,\; Z_{in}\)
			      \item[2.] \( Z_{out},\; PC_{in},\;WMFC \)
			      \item[3.] \( MDR_{out},\; IR_{in} \)
		      \end{enumerate}

		\item [DE]
		      \begin{enumerate}
			      \item[1.] \( ESP_{out} ,\; SELECT_4 ,\; ADD,\; Z_{in},\; MAR_{in},\; READ \)
			      \item[3.] \( Z_{out},\; ESP_{in},\; EMFC \)
			      \item[3.] \( MDR_{out}, PC_{in} \)
		      \end{enumerate}
	\end{enumerate}
\end{exercise}

\begin{exercise}
	Descrivere le micro operazioni per l'istruzione:
	\begin{center}
		\texttt{CALL (\%EAX, \%EBX)}
	\end{center}
	Viene fatta la call all'indirizzo ottenuto sommando EBX a EAX

	\begin{enumerate}
		\item[F]
		      \begin{enumerate}
			      \item[1.] \( PC_{out},\; MAR_{in},\; READ ,\; SELECT_4,\; ADD,\; Z_{in}\)
			      \item[2.] \( Z_{out},\; PC_{in},\;WMFC \)
			      \item[3.] \( MDR_{out},\; IR_{in} \)
		      \end{enumerate}

		\item [DE]
		      \begin{enumerate}
			      \item[1.] \( ESP_{out} ,\; SELECT_4 ,\; SUB,\; Z_{in} \)
			      \item[2.] \( Z_{out},\; MAR_{in} ,\; ESP_{in} \)
			      \item[6.] \( PC_{out} ,\; MDR_{in} ,\; WRITE \)
			      \item[3.] \( EAX_{out} ,\; V_{in} \)
			      \item[4.] \( EBX_{out},\; SELECT_V,\; ADD ,\; Z_{in}, WMFC \)
			      \item[5.] \( Z_{out} ,\; PC_{in} ,\; END\)
		      \end{enumerate}
	\end{enumerate}
\end{exercise}

\section{Dispositivi di input e output}
\begin{figure}[H]
	\centering
	\begin{tikzpicture}
		% CPU
		\node[draw, rectangle, minimum width=2cm, minimum height=1.5cm] (cpu) at (0, 0) {\textbf{CPU}};
		% Memoria
		\node[draw, rectangle, align=center, minimum width=2cm, minimum height=1.5cm] (memory) at (4, 0) {\textbf{Memoria}\\\footnotesize Dati\\\footnotesize Istruzioni};

		% Bus
		\draw (-2,-2) -- (6.5,-2) node[right] {Bus};
		\draw[<->] (cpu) -- ++(0,-2);
		\draw[<->] (memory) -- ++(0,-2);

		% Input/Output below bus
		\node[draw, rectangle, minimum width=0.7cm, minimum height=0.7cm] (io) at (2, -3) {\textbf{I/O}};
		\draw[<->] (io) -- (2,-2);

		% Keyboard and mouse below I/O
		\node (keyboard) at (1, -4) {Tastiera};
		\node (mouse) at (3, -4) {Mouse};
		\draw[->] (keyboard) -- (io);
		\draw[->] (mouse) -- (io);
	\end{tikzpicture}
	\caption{Schema di un sistema con dispositivi di input e output}
\end{figure}

\noindent Per poter ottenere un'interazione con l'utente è necessario avere dei dispositivi
di input e output e a loro volta devono essere codificati per far corrispondere
l'intenzione dell'utente con l'azione del computer. La strutture del microcontrollore
input/output è composto da:
\begin{itemize}
	\item \textbf{Dato}: contiene i dati da inviare o ricevere
	\item \textbf{Stato}: contiene lo stato del dispositivo
	\item \textbf{MC}: contiene il microcontrollore del dispositivo
	\item \textbf{IntA/D}: contiene l'interfaccia di analogico/digitale
\end{itemize}
\begin{figure}[H]
	\centering
	\begin{tikzpicture}
		\draw (0,0) rectangle (4,4);
		\draw (0.5,2.5) rectangle (1.8,3.5) node[midway] {Dato};
		\draw (2.2,2.5) rectangle (3.5,3.5) node[midway] {Stato};
		\draw (1.5,1) rectangle (2.5,2) node[midway] {MC};
		\draw (0,0) rectangle (1,1) node[midway, scale=0.7] {IntA/D};
		\node at (4,0) [above left, scale=0.7] {I/O};
	\end{tikzpicture}
	\caption{Struttura del microcontrollore input/output}
\end{figure}

\noindent La CPU accede ai valori dei registri di input/output tramite degli indirizzi
che vengono riservati in un intervallo di memoria. Gli indirizzi di \texttt{Dato} e
\texttt{Stato} sono:
\begin{itemize}
	\item \texttt{IND DATA KEY} (Dato)
	\item \texttt{IND STATUS KEY} (Stato)
\end{itemize}
Questi indirizzi sono assegnati in fase di progettazione del sistema e sono fissi,
ma si possono anche cambiare in certe architetture.

\vspace{1em}
\noindent Ogni bit nel registro \texttt{status} ha un preciso significato, ad esempio
se vale 0 significa che nessun tasto è stato premuto, se vale 1 significa che un tasto
è stato premuto.

\vspace{1em}
\noindent Un esempio in assembly è il seguente:
\begin{lstlisting}[language={[x86masm]Assembler}]
 TEST_KEY:
  MOVL IND_STATUS_KEY, %EAX ; Carica lo stato della tastiera nel registro EAX
  CMPL $0, %EAX ; Compara il valore di EAX con 0
  JE TEST_KEY ; Se EAX = 0 allora salta a TEST_KEY
  MOV IND_DATA_KEY, %EBX ; Carica il tasto premuto nel registro EBX
  MOV %EBX, INDC ; Carica il tasto premuto nel registro C
\end{lstlisting}
\noindent La verifica di un dispositivo di input/output è un'operazione che viene detta
\textbf{polling}.

\vspace{1em}
\noindent Ogni volta che si vuole leggere un dato da un dispositivo di input/output si deve
effettuare una \textbf{SVC} (Supervisor Call) che permette di richiamare del pezzo
di codice al livello del sistema operativo che permette di effettuare diverse operazioni.

\subsection{Ottimizzazione}
Ogni operazione di lettura effettuata con il bus richiede circa 10 cicli di clock.
\begin{lstlisting}[language={[x86masm]Assembler}]
 TEST_KEY:
  MOVL IND_STATUS_KEY, %EAX ; 1 Read 1 Read Bus
  CMPL $0, %EAX ; 1 Read
  JE TEST_KEY ; 1 Read
  MOV IND_DATA_KEY, %EBX 
  MOV %EBX, INDC 
\end{lstlisting}
\noindent In totale si avranno \( 10 + 3 \) cicli di clock \( \approx 10 \). Con una
frequenza di \( 10GHz \) si avranno \( 10^9 clock/sec \). Visto che un umano può premere
un tasto al massimo 10 volte al secondo, si può dire che la frequenza di lettura è
troppo alta, quindi si sprecano cicli di clock e non può essere gestito in polling.

\subsection{Interrupt}
Al posto di fare polling, cioè la CPU che controlla continuamente lo stato del dispositivo,
si può utilizzare un \textbf{interrupt} che è un segnale hardware che interrompe il normale
flusso di esecuzione del programma solo quando il dispositivo è pronto. La CPU
\textbf{prima di ogni fetch} controlla se c'è qualche richiesta di interrupt.
\begin{figure}[H]
	\centering
	\begin{tikzpicture}
		\draw (0,0) rectangle (2,2) node[midway] {CPU};
		\draw[latex-] (2,1.5) -- ++(4,0) node[right, scale=0.7] {BC};
		\draw[-latex] (2,1) -- ++(4,0) node[right, scale=0.7] {BD};
		\draw[-latex] (2,0.5) -- ++(4,0) node[right, scale=0.7] {BI};

		\node[draw, rectangle, minimum width=0.5cm, minimum height=0.5cm]
		(io1) at (2.8,-1) {I/O};
		\node[draw, rectangle, minimum width=0.5cm, minimum height=0.5cm]
		(io2) at (4.5,-1) {I/O};
		\node at (5.5,-1) {$\ldots$};

		\draw[-latex] (io1) -- (2.8,1.5);
		\draw[-latex] (io2) -- (4.5,1.5);
		\draw[-latex] (io1) -- (io2);

		\draw[-latex] (1,0) -- ++(0,-1) node[below, scale=0.7] {INTACK} |- (io1);
	\end{tikzpicture}
\end{figure}

\noindent Esiste un bit \( \overline{INTERRUPT} \) che
vale 1 solo quando c'è una \textbf{interrupt request}. Ogni interrupt ha un valore
che contiene un pezzo di codice chiamato \textbf{Interrupt Service Routine (ISR)}
che viene passato alla CPU attraverso il \texttt{INTACK} (Interrupt Acknowledge).
Le ISR sono gestite dal sistema operativo e tutto l'insieme viene chiamato \textbf{Device Driver}.
Ogni dispositivo input/output ha interrupt con valori diversi.

\vspace{1em}
\noindent Siccome l'esecuzione di un interrupt può modificare i registri della CPU può esserci
qualche conflitto con dei programmi già in esecuzione, quindi c'è bisogno di un meccanismo
per eseguire l'ISR senza che vengano modificati i registri della CPU. Questo viene
effettuato dal dispositivo input/output che salva il valore dei registri \texttt{PSW} e
\texttt{PC} ed eventuali altri registri salvaldoli nello stack prima di eseguire l'ISR.

\subsection{DMA (Direct Memory Access)}
Per trasferire grandi quantità di dati da un dispositivo di input/output alla memoria
non conviene utilizzare degli interrupt perchè sarebbe uno spreco di risorse. Si utilizza
il DMA che è un dispositivo che permette di trasferire dati dalla memoria al dispositivo
di input/output senza passare per la CPU.


\begin{figure}[H]
	\centering
	\begin{tikzpicture}
		% CPU
		\node[draw, rectangle, minimum width=2cm, minimum height=1.5cm] (cpu) at (0, 0) {\textbf{CPU}};
		% Memoria
		\node[draw, rectangle, align=center, minimum width=2cm, minimum height=1.5cm] (memory) at (4, 0) {\textbf{Memoria}\\\footnotesize Dati\\\footnotesize Istruzioni};

		% Bus
		\draw (-2,-2) -- (6.5,-2) node[right] {Bus};
		\draw[latex-latex] (cpu) -- ++(0,-2);
		\draw[latex-latex] (memory) -- ++(0,-2);

		% Input/Output below bus
		\node[draw, rectangle, minimum width=0.7cm, minimum height=0.7cm] (dma) at (2, -3) {\textbf{DMA}};
		\draw[latex-latex] (dma) -- (2,-2);

	\end{tikzpicture}
	\caption{Schema di un sistema con DMA}
\end{figure}

\begin{figure}[H]
	\centering
	\begin{tikzpicture}
		\draw (0,0) rectangle (4,4);
		\draw (0.5,2.5) rectangle (1.8,3.5) node[midway] {Data};
		\draw (2.2,2.5) rectangle (3.5,3.5) node[midway] {Status};

		\node[draw, rectangle, minimum width=0.5cm, minimum height=0.5cm] (mem)
		at (1.1,1.7) {MEM};
		\node[draw, rectangle, minimum width=0.5cm, minimum height=0.5cm] (cpu)
		at (2.9,1.7) {CPU};

		\draw[latex-latex] (mem) -- (cpu);

		\draw (0,0) rectangle (1,1) node[midway, scale=0.7] {A/D};
		\node at (4,0) [above left, scale=0.7] {DMA};
	\end{tikzpicture}
	\caption{Struttura del DMA}
\end{figure}


\subsection{Bus}
Il bus è una linea di comunicazione che collegana i vari componenti di un sistema
informatico. Vengono gestiti direttamente dalla CPU che quando non lo usa lo assegna ad
altri componenti.

\subsubsection{Bus Sincrono}
Il segnale di clock è presente. Questo tipo di bus
non viene mai realizzato perchè rallenta il sistema. Vengono invece utilizzati
soltanto per collegare i componenti all'interno di un chip. Il segnale di clock
può anche avere un ritardo, quindi non è detto che tutti i componenti ricevano
il segnale di clock nello stesso momento.

\subsubsection{Bus Asincrono}
Il segnale di clock non è presente. Ciò permette di
adattare dinamicamente la velocità di trasmissione dei dati in base alla
velocità di trasmissione dei componenti.

\begin{figure}[H]
	\centering
	\begin{tikzpicture}
		\draw (0,0) rectangle (2,2) node[midway] {CPU};
		\draw[latex-] (2,1.5) -- ++(4,0) node[right, scale=0.7] {\( \overline{BBSY} \) };
		\draw[latex-] (2,0.5) -- ++(4,0) node[right, scale=0.7] {\( \overline{BR} \) };

		\node[draw, rectangle, minimum width=0.5cm, minimum height=0.5cm]
		(dma1) at (2.8,-1) {\( DMA_1 \) };
		\node[draw, rectangle, minimum width=0.5cm, minimum height=0.5cm]
		(dma2) at (5,-1) {\( DMA_2 \)};
		\node at (6,-1) {$\ldots$};

		\draw[latex-latex] (2.5,1.5) -- ++(0,-2.2);
		\draw[latex-] (3.1,0.5) -- ++(0,-1.2);

		\draw[latex-latex] (4.7,1.5) -- ++(0,-2.2);
		\draw[latex-] (5.3,0.5) -- ++(0,-1.2);

		\draw[-latex] (dma1) -- (dma2) node[midway, below, scale=0.9] {\( BG_2 \) };

		\draw[-latex] (1,0) -- ++(0,-1) |- (dma1) node[midway, below right, scale=0.9]
			{\( BG_1 \) };
	\end{tikzpicture}
	\caption{Schema di un sistema con bus}
\end{figure}

\noindent I segnali di controllo del bus sono:
\begin{itemize}
	\item \( \overline{BBSY} \) (Bus Busy): quando vale 0 indica che il bus è occupato
	\item \( \overline{BR} \) (Bus Request): quando vale 0 indica che il dispositivo vuole
	      utilizzare il bus
	\item \( BG_1 \) (Bus Grant): indica che il bus è assegnato al DMA1
	\item \( BG_2 \) (Bus Grant): indica che il bus è assegnato al DMA2
\end{itemize}

\begin{figure}[H]
	\begin{center}
		\begin{tikzpicture}[scale=0.8]
			\draw [->] (0,0) -- (12,0) node[right] {t};
			\draw (0,0) -- (0,8) node[above] {};
			\draw [gray!50, ultra thin, help lines, ystep=10] (0,0) grid (12,8);

			\draw [blue, ultra thick] plot coordinates { (0,8) (1,8) (1,8) (2,8) (2,7) (3,7) (3,7) (4,7) (4,7) (5,7) (5,7) (6,7) (6,7) (7,7) (7,7) (8.5,7) (8.5,8) (9,8) (12,8) };
			\draw [magenta, ultra thick] plot coordinates { (0,5) (1,5) (1,5) (2,5) (2,5) (3,5) (3,6) (4,6) (4,6) (5,6) (5,6) (6,6) (6,6) (7,6) (7,6) (8,6) (8,6) (9,6) (9,6) (10,6) (10,5) (11,5) (11,5) (12,5) (12,5) };
			\draw [red, ultra thick] plot coordinates { (0,3) (2,3) (2,3) (3.5,3) (3.5,4) (10.5,4) (10.5,3) (12,3)  };
			\draw [orange, ultra thick] plot coordinates { (0,1) (8,1) (8,2) (9,2) (9,1) (12,1) };

			\draw[thick, opacity=0.3] (8,8) -- (8,0) node[below right, opacity=1] {BUS non usato};
			\draw[thick, opacity=0.3] (9,8) -- (9,0);

			\node[blue, anchor=east] at (0,7) {\( \overline{BR} \) };
			\node[magenta, anchor=east] at (0,5) {\( BG_1 \) };
			\node[red, anchor=east] at (0,3) {\( BG_2 \) };
			\node[orange, anchor=east] at (0,1) {\( \overline{BBSY} \) };
		\end{tikzpicture}
	\end{center}
	\caption{Segnali di controllo DMA}
\end{figure}

\noindent Il \( DMA_2 \) vuole utilizzare il bus, che però è già in uso dalla CPU, quindi
mette a 0 il \( \overline{BR} \) e aspetta che il bus venga liberato.
Quando la CPU libera il BUS vede la request del \( DMA_2 \) e mette a 0 il \( BG_1 \) e
il \( BG_2 \).
Il \( \overline{BBSY} \) viene messo a 0 quando il bus è occupato e quando viene liberato
viene messo a 1 mettendo a 1 il \( \overline{BR} \) e resettando a 0 il \( BG_1 \) e \( BG_2 \).

\vspace{1em}
\noindent In questo modo si riduce al minimo il tempo in cui il BUS \textbf{non} è
utilizzato.

\section{Multitasking (multiprocesso)}
Il multitasking è la capacità di un sistema operativo di eseguire più
processi contemporaneamente e questa è una caratteristica che sta alla base di tutti
i calcolatori moderni.

\begin{figure}[H]
	\begin{define}
		Il concetto di \textbf{programma} è diverso da un \textbf{processo}. Un programma è
		un file binario che contiene le istruzioni da eseguire, mentre un processo è un
		programma in esecuzione.
	\end{define}
\end{figure}

\noindent Per permettere che più processi vengano eseguiti contemporaneamente si
ricorre al concetto di \textbf{time sharing}
\begin{figure}[H]
	\begin{center}
		\begin{tikzpicture}[scale=0.8]
			\draw [->] (0,0) -- (10,0) node[right] {t};
			\draw (0,0) -- (0,6) node[above] {};
			\draw [gray!50, ultra thin, help lines, ystep=10] (0,0) grid (4,6);
			\draw [gray!50, ultra thin, help lines, ystep=10, xshift=-15] (4.5,0) grid (10,6);

			\draw [magenta, ultra thick] plot coordinates { (0,5) (1,5) };
			\draw [magenta, ultra thick] plot coordinates { (3,5) (4,5) };
			\draw [magenta, ultra thick] plot coordinates { (6.5,5) (7.5,5) };

			\draw [red, ultra thick] plot coordinates { (1,3) (2,3) };
			\draw [red, ultra thick] plot coordinates { (4,3) (4.5,3) };
			\draw [red, ultra thick] plot coordinates { (5.5,3) (6.5,3) };
			\draw [red, ultra thick] plot coordinates { (8.5,3) (9.5,3) };

			\draw [orange, ultra thick] plot coordinates { (2,1) (3,1) };
			\draw [orange, ultra thick] plot coordinates { (4.5,1) (5.5,1) };
			\draw [orange, ultra thick] plot coordinates { (7.5,1) (8.5,1) };

			\node[magenta, anchor=east] at (0,5) {\( p_1 \) };
			\node[red, anchor=east] at (0,3) {\( p_2 \) };
			\node[orange, anchor=east] at (0,1) {\( p_3 \) };

			\node[scale=0.6] at (4.1,3.45) (svc) {SVC};
			\draw[-latex] (svc) -- (4.5,3);

			\draw (0,-0.2) -- ++(0,-0.2) -- ++(1,0) node[below, midway, scale=0.7, align=center]
			{quanto\\di tempo} -- ++(0,0.2);
		\end{tikzpicture}
	\end{center}
	\caption{Time sharing tra i processi}
\end{figure}
\noindent Il quanto di tempo è stato messo a \( 1ms \) perchè è il tempo minimo per cui un
umano non percepisce il cambio di processo. I processi vengono eseguiti per poco tempo,
ma così frequentemente che sembra che vengano eseguiti contemporaneamente.

\vspace{1em}
\noindent Se un processo in esecuzione esegue una supervisor call (SVC) il processo viene
immediatamente interrotto e viene eseguita la SVC. Questo perchè finchè la SVC verrà
eseguita si perderebbero migliaia di quanti di tempo.

\subsection{Kernel}
La parte del sistema operativo che
gestisce i processi si chiama \textbf{kernel} e lo fa dialogando direttamente con la CPU.

\begin{figure}[H]
	\centering
	\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=3cm,
			thick,main node/.style={circle,draw,font=\sffamily\Large\bfseries}]

		\node[main node] (1) {\footnotesize \( Exec_u \) };
		\node[main node] (2) [below of=1] {\footnotesize \( Exec_s \) };
		\node[main node] (3) [below of=2] {\footnotesize Attesa};
		\node[main node] (4) [right of=3] {\footnotesize Pronto};

		\path[every node/.style={font=\sffamily\small}]
		(1) edge [bend right, align=center] node[left] {SVC\\ (int sw)} (2)
		(2) edge [bend right] node {} (3)
		(2) edge [bend right] node[right] {Iret} (1)
		(3) edge [bend right] node[midway, below] {Evento} (4)
		(4) edge [loop right] node {\( \begin{array}{c}
					p_1    \\
					p_2    \\
					\vdots \\
					p_n
				\end{array} \) } (4)
		(2) edge [bend left] node[right] {Preemption} (4);
	\end{tikzpicture}
	\caption{Flusso di esecuzione delle istruzioni}
\end{figure}

\noindent La chiamata di una SVC porta l'esecuzione dalla modalità utente (\( E_u \) )
alla modalità supervisor (\( E_s \) ). Questo perchè la SVC può accedere a tutte le
parti del sistema operativo e quindi deve avere i permessi necessari. Nell'architettura
x86 gli SVC sono degli interrupt chiamati \textbf{Software Interrupt}. L'istruzione
assembly è la seguente:
\begin{lstlisting}[language={[x86masm]Assembler}]
 INT $0x80 ; Numero dell'interrupt
\end{lstlisting}

\noindent La \textbf{preemption} è l'interruzione di un processo in esecuzione per
eseguire un altro processo. Questo avviene quando un processo è stato eseguito per
un tempo maggiore del quanto di tempo.

\subsubsection{Scheduler}
È una delle operazioni principali del sistema operativo. La CPU conta i cicli di clock
che sono stati destinati ad un processo, in questo modo si può sapere che frazione del
quanto di tempo è stata impiegata direttamente per il processo e non per eseguire gli
interrupt. Per sapere quanto tempo è stato impiegato per eseguire un processo si
usa il seguente comando bash:
\begin{lstlisting}[language=bash]
$ time ./programma
\end{lstlisting}
\noindent L'output è diviso in:
\begin{itemize}
	\item \textbf{User}: tempo impiegato per eseguire il programma
	\item \textbf{System}: tempo impiegato per eseguire gli interrupt
	\item \textbf{Real}: tempo reale impiegato per eseguire il programma
\end{itemize}

\vspace{1em}
\noindent Lo scheduler controlla se il tempo dedicato ad un singolo processo è maggiore
della metà di un quanto di tempo, in tal caso lo sospende e passa ad un altro processo,
altrimenti lo fa continuare. Lo scheduler quindi decide quale processo della lista dei
processi pronti deve essere eseguito. Ogni processo ha una certa priorità e lo scheduler
deve decidere quale processo eseguire in base alla priorità e al tempo di esecuzione (
tempo reale). Per modificare la priorità dei processi si utilizza i seguenti comandi bash:
\begin{lstlisting}[language=bash]
$ nice -n 10 ./programma
\end{lstlisting}
\noindent Il comando \texttt{nice} permette di modificare la priorità di un processo solo
hardware, ma non software. Per modificare la priorità software si utilizza il comando:
\begin{lstlisting}[language=bash]
$ renice -n 10 -p 1234
\end{lstlisting}

\subsection{Realtime}
Un processo può essere eseguito in tempo reale se il tempo di esecuzione è all'interno
di un certo intervallo di tempo. Ci sono 2 tipi di realtime:
\begin{itemize}
	\item \textbf{Soft Realtime}: il processo deve essere eseguito entro un certo intervallo
	      di tempo ristretto ma non troppo.
	\item \textbf{Hard Realtime}: il processo deve essere eseguito entro un certo intervallo
	      di tempo molto stretto.
\end{itemize}

\subsection{Caratteristiche di un processo}
Ogni processo ha le seguenti caratteristiche contenute in un \textbf{descrittore}:
\begin{itemize}
	\item \textbf{PID}: identificatore del processo
	\item \textbf{Proprietà}: proprietario del processo
	\item \textbf{Stato}: indica lo stato della cpu
	\item \textbf{Cache}: contiene le informazioni più utilizzate dal processo
	\item \textbf{File ID}: contiene i file aperti dal processo
\end{itemize}

\noindent Questa struttura deve essere salvata dallo scheduler quando il processo viene
sospeso e deve essere caricata quando il processo viene ripreso. Questa operazione
viene chiamata \textbf{Context Switch}.


\section{Stack}
Prendiamo in considderazione il seguente codice in C:
\begin{lstlisting}[language=C]
  int main() {
    int A;
    int B;
    int C;
    ...
    A = 5;
    B = 7;
    C = pippo(A, B);
    ...
    return;
  }

  int pippo(int x, int y) {
    int z;
    z = z * y;
    return z;
  }
\end{lstlisting}
Questo codice in C chiede alla CPU di riservare 3 locazioni di memoria per le variabili
\texttt{A}, \texttt{B} e \texttt{C}. Queste variabili verranno poi riempite da dei valori
che siano costanti o funzioni.

\vspace{1em}
Nel file binario è presente un \textbf{header} che indica come interpretare il file.
Il file binario contiene un'immagine della memoria che verrà caricata in memoria
prima di essere eseguito. Questo file binario contiene:
\begin{itemize}
	\item \textbf{Codice}: contiene le istruzioni da eseguire
	\item \textbf{Dati statici}: contiene i dati che non cambiano durante l'esecuzione,
	      come ad esempio i \texttt{\#DEFINE} o le stringhe dei print, che sono tutti dati
	      che rimangono costanti durante l'esecuzione.
	\item \textbf{Heap}: contiene i dati che vengono allocati dinamicamente durante
	      l'esecuzione del programma, ad esempio la funzione \texttt{malloc()} in C.
	\item \textbf{Stack}: contiene i dati che vengono allocati durante l'esecuzione
	      di una funzione e che vengono deallocati quando la funzione termina, ad
	      esempio il \texttt{main} o le funzioni generiche. Lo stack pointer (ESP)
	      punta alla cima dello stack e cresce verso l'alto.
	\item \textbf{Puntatori Limit e Base}: sono due registri che indicano la base
	      e il limite dello stack. Questi servono per evitare che il programma salvato in
	      memoria modifichi gli altri processi salvati in memoria nel caso in cui il
	      programma vada in \textbf{Segmentation Fault}. Se il programma va in Segmentation
	      Fault il sistema operativo lo termina tramite un interrupt.
\end{itemize}

\begin{figure}[H]
	\centering
	\begin{tikzpicture}
		\draw (0,0) rectangle (3,5);

		\draw (0,4) -- (3,4) node[midway, above, yshift=8] {Codice};
		\draw (0,3) -- (3,3) node[midway, above, yshift=8] {Dati statici};
		\draw (0,1.5) -- (3,1.5) node[midway, above, yshift=13] {Heap};
		\node at (1.5,0.75) {Stack};

		\draw[latex-] (3,0) -- ++(0.5,0) node[right] {ESP};
		\draw[latex-] (0,0) -- ++(-0.5,0) node[left] {LIMIT};
		\draw[latex-] (0,5) -- ++(-0.5,0) node[left] {BASE};
	\end{tikzpicture}
	\caption{Struttura di un file binario}
\end{figure}

\noindent Lo stack è stato posizionato in basso perchè cresce verso l'alto, infatti
se viene superato il limite dello stack la memoria rimanente viene posizionata
al posto dello heap e di tutti i dati presenti al di sopra.

\vspace{1em}
\noindent Prima di usare qualsiasi registro bisogna salvarlo all'interno dello stack, in
modo da poterlo ripristinare alla fine dell'esecuzione. Questo viene fatto attraverso
il comando asm:
\begin{lstlisting}[language={[x86masm]Assembler}]
  PUSHL %EBP
\end{lstlisting}

\noindent Lo stack del programma in C scritto sopra è il seguente:

\begin{figure}[H]
	\centering
	\begin{tikzpicture}
		\draw (0,0) rectangle (3,5) node[above left, xshift=-26] {Stack};

		\draw (0,0.3) -- (3,0.3) node[midway, below, scale=0.6] {info (PC OS)};
		\draw (0,0.6) -- (3,0.6) node[midway, below, scale=0.6] {A = 5};
		\draw (0,0.9) -- (3,0.9) node[midway, below, scale=0.6] {B = 7};
		\draw (0,1.2) -- (3,1.2) node[midway, below, scale=0.6] {C};
		\draw (0,1.5) -- (3,1.5) node[midway, below, scale=0.6] {RETURN = 35};
		\draw (0,1.8) -- (3,1.8) node[midway, below, scale=0.6] {5};
		\draw (0,2.1) -- (3,2.1) node[midway, below, scale=0.6] {7};
		\draw (0,2.4) -- (3,2.4) node[midway, below, scale=0.6] {PC};
		\draw (0,2.7) -- (3,2.7) node[midway, below, scale=0.6] {\( EBP_{pippo} \) };
		\draw (0,3) -- (3,3) node[midway, below, scale=0.6] {x = 5};
		\draw (0,3.3) -- (3,3.3) node[midway, below, scale=0.6] {y = 7};
		\draw (0,3.6) -- (3,3.6) node[midway, below, scale=0.6] {z = 35};
		\draw (0,3.9) -- (3,3.9) node[midway, below, scale=0.6] {EAX};

		\draw[latex-] (3,3.6) -- ++(0.5,0) node[right] {ESP};
		\draw[latex-] (0,0.3) -- ++(-0.5,0) node[left] {EBP};
		\draw[latex-] (0,2.55) -- ++(-0.5,0) node[left] {\( EBP_{pippo} \) };
	\end{tikzpicture}
	\caption{Stack con variabili}
\end{figure}

\noindent Di seguito il codice assembly per la gestione dello stack:

\begin{lstlisting}[language={[x86masm]Assembler}]
  pippo:
  PUSHL %EBP
  MOVL %ESP, %EBP
  SUBL $12, %ESP
  PUSHL %EAX
  MOVL $12(%EBP), %EAX
  MOVL %EAX, -4(%EBP)
  ...
  MOVL %EAX, $16(%EBP)

  POPL %EAX
  ADDL $12, %ESP
  POPL %EBP
  RET ; Considera il valore in cima allo stack come PC


  PUSHL %EBP
  MOVL %ESP, %EBP
  SUBL $12, %ESP
  MOVL $5, $-4(%EBP)
  MOVL $7, $-8(%EBP)
  SUBL $4, %ESP
  MOVL $-4(%EBP), %EAX
  PUSHL %EAX
  MOVL $-8(%EBP), %EAX
  PUSHL %EAX
  CALL pippo

  ADDL $8, %ESP
  POPL %EAX
  MOVL %EAX, $-12(%EBP)
  ...

\end{lstlisting}

\section{Struttura della memoria}
\begin{figure}[H]
	\centering
	\begin{tikzpicture}[scale=0.9]
		% Vertical array b7
		\node[draw, rectangle, minimum width=1cm, minimum height=1cm] (b7) at (0,0) {};

		\node[draw, rectangle, minimum width=1cm, minimum height=1cm] (b7-2) at (0,-2.5) {};
		\draw (b7-2.west) -- ++(-0.5,0) node[above right] {}
		(b7-2.east) -- ++(0.5,0);

		\node at (0,-4.3) {\( \vdots \)};

		\node[draw, rectangle, minimum width=1cm, minimum height=1cm] (b7-15) at (0,-6) {};
		\draw (b7-15.west) -- ++(-0.5,0) node[above right] {}
		(b7-15.east) -- ++(0.5,0);

		\draw
		(b7.west) -- ++(-0.5,0) node[above right] {\( b_7 \) }
		-- ++(0,-7.8) -- ++(0.5,0) -- ++(0,-0.73)
    (b7.east) -- ++(0.5,0) node[above, midway] {\( b'_7 \) } -- ++(0,-7.8) -- ++(-0.5,0) -- ++(0,-0.73);

		% cls b7
		\node[draw, rectangle, minimum width=1cm, minimum height=1cm, align=center, scale=0.7]
		(cls1) at (0,-9) {Circuito di\\lettura e\\scrittura};
		\node[yshift=5, xshift=4] at (cls1.west) (cls1-iw1) {};
		\node[yshift=-5, xshift=4] at (cls1.west) (cls1-iw2) {};
		\node[xshift=-8, yshift=4] at (cls1.south) (cls1-is1) {};
		\node[xshift=8, yshift=4] at (cls1.south) (cls1-is2) {};
		\node[xshift=0, yshift=-7] at (cls1.south) (cls1-isc) {};
		\draw (cls1-iw1) -- ++(-0.5,0) node[left] {\( R/\bar{w} \) } ;
		\draw (cls1-iw2) -- ++(-0.5,0) node[left] {cs} ;
		\draw[latex-] (cls1-is1) -- ++(0,-0.5) -- ++(0.55,0);
		\draw[latex-latex] (cls1-isc) -- ++(0,-0.8);
		\draw[-latex] (cls1-is2) -- ++(0,-0.5);

		% Vertical array b6
		\node[draw, rectangle, minimum width=1cm, minimum height=1cm] (b6) at (2.5,0) {};

		\node[draw, rectangle, minimum width=1cm, minimum height=1cm] (b6-2) at (2.5,-2.5) {};
		\draw (b6-2.west) -- ++(-0.5,0) node[above right] {}
		(b6-2.east) -- ++(0.5,0);

		\node at (2.5,-4.3) {\( \vdots \)};

		\node[draw, rectangle, minimum width=1cm, minimum height=1cm] (b6-15) at (2.5,-6) {};
		\draw (b6-15.west) -- ++(-0.5,0) node[above right] {}
		(b6-15.east) -- ++(0.5,0);

		\draw
		(b6.west) -- ++(-0.5,0) node[above right] {\( b_6 \) }
		-- ++(0,-7.8) -- ++(0.5,0) -- ++(0,-0.73)
		(b6.east) -- ++(0.5,0) node[above, midway] {\( b'_6 \) } -- ++(0,-7.8) -- ++(-0.5,0) -- ++(0,-0.73);

		% cls b6
		\node[draw, rectangle, minimum width=1cm, minimum height=1cm, align=center, scale=0.7]
		(cls2) at (2.5,-9) {Circuito di\\lettura e\\scrittura};
		\node[xshift=-8, yshift=4] at (cls2.south) (cls2-is1) {};
		\node[xshift=8, yshift=4] at (cls2.south) (cls2-is2) {};
		\node[xshift=0, yshift=-7] at (cls2.south) (cls2-isc) {};
		\draw[latex-] (cls2-is1) -- ++(0,-0.5) -- ++(0.55,0);
		\draw[latex-latex] (cls2-isc) -- ++(0,-0.8);
		\draw[-latex] (cls2-is2) -- ++(0,-0.5);


		\node at (4.3,0) {\( \ldots \)};


		% Vertical array b0
		\node[draw, rectangle, minimum width=1cm, minimum height=1cm] (b0) at (6,0) {};

		\node[draw, rectangle, minimum width=1cm, minimum height=1cm] (b0-2) at (6,-2.5) {};
		\draw (b0-2.west) -- ++(-0.5,0) node[above right] {}
		(b0-2.east) -- ++(0.5,0);

		\node at (6,-4.3) {\( \vdots \)};

		\node[draw, rectangle, minimum width=1cm, minimum height=1cm] (b0-15) at (6,-6) {};
		\draw (b0-15.west) -- ++(-0.5,0) node[above right] {}
		(b0-15.east) -- ++(0.5,0);

		\draw
		(b0.west) -- ++(-0.5,0) node[above right] {\( b_0 \) }
		-- ++(0,-7.8) -- ++(0.5,0) -- ++(0,-0.73)
		(b0.east) -- ++(0.5,0) node[above, midway] {\( b'_0 \) } -- ++(0,-7.8) -- ++(-0.5,0) -- ++(0,-0.73);

		% cls b0
		\node[draw, rectangle, minimum width=1cm, minimum height=1cm, align=center, scale=0.7]
		(cls3) at (6,-9) {Circuito di\\lettura e\\scrittura};
		\node[xshift=-8, yshift=4] at (cls3.south) (cls3-is1) {};
		\node[xshift=8, yshift=4] at (cls3.south) (cls3-is2) {};
		\node[xshift=0, yshift=-7] at (cls3.south) (cls3-isc) {};
		\draw[latex-] (cls3-is1) -- ++(0,-0.5) -- ++(0.55,0);
		\draw[latex-latex] (cls3-isc) -- ++(0,-0.8);
		\draw[-latex] (cls3-is2) -- ++(0,-0.5);


		% Decoder 4 bit
		\node[draw, rectangle, minimum width=1cm, minimum height=3cm, align=center]
		(dec) at (-4,-3) {Decoder\\a 4 bit};
		\node[yshift=30, xshift=-4] at (dec.east) (d-p0) {};
		\node[yshift=15, xshift=-4] at (dec.east) (d-p1) {};
		\node[yshift=-5, xshift=10] at (dec.east) {\( \vdots \) };
		\node[yshift=-30, xshift=-4] at (dec.east) (d-p15) {};

		\node[xshift=4, yshift=24] at (dec.west) (d-i0) {};
		\node[xshift=4, yshift=9] at (dec.west) (d-i1) {};
		\node[xshift=4, yshift=-9] at (dec.west) (d-i2) {};
		\node[xshift=4, yshift=-24] at (dec.west) (d-i3) {};

		\draw[latex-] (d-i0) -- ++(-0.8,0) node[left] {\( i_0 \)};
		\draw[latex-] (d-i1) -- ++(-0.8,0) node[left] {\( i_1 \)};
		\draw[latex-] (d-i2) -- ++(-0.8,0) node[left] {\( i_2 \)};
		\draw[latex-] (d-i3) -- ++(-0.8,0) node[left] {\( i_3 \)};



		% b0 to decoder
		\draw (b0.south) -- ++(0,-0.5) -- ++(-8.5,0) |- (d-p0) node[above right, xshift=5] {\( p_0 \) }
		(b6.south) -- ++(0,-0.5)
		(b7.south) -- ++(0,-0.5);

		% b0-2 to decoder
		\draw (b0-2.south) -- ++(0,-0.5) -- ++(-8.5,0) |- (d-p1) node[above right, xshift=5] {\( p_1 \) }
		(b6-2.south) -- ++(0,-0.5)
		(b7-2.south) -- ++(0,-0.5);

		% b0-15 to decoder
		\draw (b0-15.south) -- ++(0,-0.5) -- ++(-8.5,0) |- (d-p15) node[above right, xshift=5] {\( p_{15} \) }
		(b6-15.south) -- ++(0,-0.5)
		(b7-15.south) -- ++(0,-0.5);
	\end{tikzpicture}
\end{figure}

Una memoria è compattata in un chip con diversi pin con compiti diversi:
\begin{itemize}
	\item \textbf{8 Pin dati}: permettono di leggere o scrivere i dati
	\item \textbf{4 Pin indirizzi}: permettono di selezionare la cella di memoria
	\item \textbf{2 Pin controllo}: permettono di controllare la memoria
  \item \textbf{2 pin di alimentazione}: permettono di alimentare la memoria
\end{itemize}

\subsection{Static RAM (SRAM)}
La SRAM è una memoria statica, ovvero non ha bisogno di essere rinfrescata
per mantenere i dati. Questo tipo di memoria è più veloce, ma occupa più spazio
ed è più costosa.

\noindent Ogni singola cella è strutturata in questo modo:

\begin{figure}[H]
  \centering
  \begin{circuitikz}
    \draw (0,0) to[short, *-] ++(0.5,0) node[nmos, anchor=D, rotate=90] (nmos1) {}
      (nmos1.S) to[short,-*] ++(0.5,0) node {}
      to[short] ++(0,1) -- ++(0.5,0) node[not port, anchor=in, scale=0.7, yscale=0.7] (not1) {}
      (not1.out) to[short] ++(0.5,0) to[short, -*] ++(0,-1)
      to[short] ++(0,-1) to[short] ++(-0.5,0) node[not port, anchor=in, rotate=180, scale=0.7, yscale=0.7] (not2) {}
      (not2.out) to[short] ++(-0.5,0) to[short] ++(0,1)
      (4.5,0) -- ++(0.5,0) node[nmos, anchor=D, rotate=90] (nmos2) {}
      (nmos2.S) to[short,-*] ++(0.5,0) node {}
      (nmos1.G) to[short, -*] ++(0,-1)
      (nmos2.G) to[short, -*] ++(0,-1)
      ;

    % labels
    \node at (nmos1.G) [right] {\( T_1 \) };
    \node at (nmos2.G) [right] {\( T_2 \) };

    % b line
    \draw (0,-2.5) -- (0,2) node[above] {\( b \) line};
    % b' line
    \draw (7.05,-2.5) -- (7.05,2) node[above] {\( b' \) line};
    % p line
    \draw (-0.5,-2) -- (7.5,-2) node[above right] {\( p \) line};
  \end{circuitikz}
  \caption{Struttura di una cella di memoria}
\end{figure}

\noindent Considerando che la porta NOT è costruita nel seguente modo:

\begin{figure}[H]
	\begin{center}
		\begin{circuitikz}
			\node (Vcc) at (-1,0.3) {\( V_{cc} \) };
			\node (Vcc) at (1,0.3) {\( 3V \) };
			\draw (-1,0) -- (0,0) to[short,-*] ++(0,0) node[left] {}
			(1,0) -- (0,0);
			\draw (0,0) node[pmos, anchor=S] (pmos) {}
			(pmos.G) to[short] ++(0,0) node[left] {}
			(pmos.D) to[short] ++(0,0) node[left] {}
			(pmos.D) -- ++(0,0) to[short,-*] (0,-1.6) node[left] {}
			node[nmos,anchor=D] (nmos) {}
			(nmos.G) to[short] ++(0,0) node[left] {}
			(nmos.S) node[ground] {};
			\draw (-2, -1.6) node[above] {\( x \) } to[short,-*] (-0.99,-1.6) node[left] {}
			(pmos.G) -- ++(0,0) to[short,-*] (-0.99,-1.6) node[left] {}
			(0,-1.6) -- ++(0,0) to[short] (1.2,-1.6) node[above] {O}
			(nmos.G) -- ++(0,0) to[short] (-0.99,-1.6) node[left] {};
			\node (0V) at (0.6,-3.5) {\( 0V \) };
		\end{circuitikz}
	\end{center}
    \caption{Circuito di negazione}
\end{figure}

\noindent La struttura della cella di memoria si può espandere ulteriormente in questo
modo:
\begin{figure}[H]
  \centering
  \begin{circuitikz}
    \draw (0,0) to[short, *-] ++(0.5,0) node[nmos, anchor=D, rotate=90] (nmos1) {}
      (nmos1.S) to[short,-*] ++(0.5,0) node {}
      node[pmos, anchor=S, rotate=180] (pmos1) {}
      (pmos1.D) to[short] ++(3,0)
      node[pmos, anchor=S, rotate=0] (pmos2) {}
      (pmos2.D) node[nmos, anchor=D, rotate=0] (nmos3) {}
      (nmos3.S) to[short, -*] ++(-1.5,0) node[ground] (gnd) {}
      (gnd) to[short] ++(-1.5,0) node[nmos, anchor=D, rotate=180] (nmos4) {}

      (pmos1.S) -- (nmos3.G)
      (pmos2.D) -- (nmos4.G)

      (pmos2.G) to[short, -*] (3.3,-0.28)
      (pmos1.G) to[short, -*] (4.75,-0.28)
      
      (pmos2.D) to[short, *-] ++(0.5,0) node[nmos, anchor=D, rotate=90] (nmos2) {}
      (nmos2.S) to[short,-*] ++(0.5,0) node {}
      (nmos1.G) to[short, -*] ++(0,-1)
      (nmos2.G) to[short, -*] ++(0,-1)
      ;

    % labels
    \node at (nmos1.G) [right] {\( T_1 \) };
    \node at (nmos2.G) [right] {\( T_2 \) };
    \node at (nmos3.G) [below] {\( T_4 \) };
    \node at (nmos4.G) [below] {\( T_3 \) };
    \node at (pmos1.G) [above] {\( T_5 \) };
    \node at (pmos2.G) [above] {\( T_6 \) };

    % b line
    \draw (0,-3) -- (0,2) node[above] {\( b \) line};
    % b' line
    \draw (8.08,-3) -- (8.08,2) node[above] {\( b' \) line};
    % p line
    \draw (-0.5,-2.5) -- (8.5,-2.5) node[above right] {\( p \) line};
  \end{circuitikz}
  \caption{Struttura di una cella di memoria}
\end{figure}

\subsection{Dynamic RAM (DRAM)}
I condensatori permettono di mantenere una carica elettrica per un certo
periodo di tempo, questa carica però si degrada nel tempo. Per mantenere la carica
si deve rinfrescare ogni condensatore per ripristinare la carica. Questo rinfresco
però riduce la velocità della memoria. Visto che la DRAM occupa meno spazio rispetto
alla SRAM, è più lenta, ma è più economica e può essere fatta più capiente.

\begin{example}
\[
	1Kbit = 32 \times 32 = 2^5 \times 2^5
\]
Si avrà una SRAM che sarà una matrice da \( m \) bit \( 32 \times 32 \)

\begin{figure}[H]
	\centering
	\begin{tikzpicture}
		\node[draw, rectangle, minimum width=4cm, minimum height=4cm, align=center]
		(mat) at (0,0) {Matrice di\\celle da\\\( n \) bit\\\\32x32};

		% decoder 5 bit
		\node[draw, rectangle, minimum width=1cm, minimum height=4cm, align=center]
		(dec) at (-4,0) {Decoder\\a 5 bit};

		\draw[-latex] (-3.25,1.5) node[above right] {$p_0$} -- ++(1.25,0);
		\draw[-latex] (-3.25,1) node[above right] {$p_1$} -- ++(1.25,0);
		\node at (-2.6,0) {\( \vdots \)};
		\draw[-latex] (-3.25,-1.5) node[above right] {$p_{31}$} -- ++(1.25,0);

		% inputs 0 to 4
		\draw[latex-] (-4.75,1.1) -- ++(-1,0) node[left] {\( r_0 \)};
		\draw[latex-] (-4.75,0.6) -- ++(-1,0) node[left] {\( r_1 \)};
		\draw[latex-] (-4.75,0.1) -- ++(-1,0) node[left] {\( r_2 \)};
		\draw[latex-] (-4.75,-0.4) -- ++(-1,0) node[left] {\( r_3 \)};
		\draw[latex-] (-4.75,-0.9) -- ++(-1,0) node[left] {\( r_4 \)};

		\node[draw, rectangle, minimum width=0.5cm, minimum height=0.5cm] (rw1) at (-1.5,-2.8) {};
		\draw (-1.65,-2.55) -- ++(0,0.55)
		(-1.35,-2.55) -- ++(0,0.55);

		\node[draw, rectangle, minimum width=0.5cm, minimum height=0.5cm] (rw2) at (-0.5,-2.8) {};
		\draw (-0.65,-2.55) -- ++(0,0.55)
		(-0.35,-2.55) -- ++(0,0.55);

		\node at (0.5,-2.8) {\( \underset{\times 32}{\ldots}\)};

		\node[draw, rectangle, minimum width=0.5cm, minimum height=0.5cm] (rw32) at (1.5,-2.8) {};
		\draw (1.35,-2.55) -- ++(0,0.55)
		(1.65,-2.55) -- ++(0,0.55);

		\node[draw, rectangle, minimum width=5.5cm, minimum height=1cm, align=center, scale=0.7]
		(mul) at (0,-4.3) {Multiplatore\\(mux + demux)\\a 5 bit di\\selezione};

		\draw[latex-latex] (rw1.south) -- ++(0,-0.6);
		\draw[latex-latex] (rw2.south) -- ++(0,-0.6);
		\draw[latex-latex] (rw32.south) -- ++(0,-0.6);

		\draw[latex-] (-1.9,-3.8) -- ++(-3.9,0) node[left] {\( c_0 \) };
		\draw[latex-] (-1.9,-4.05) -- ++(-3.9,0) node[left] {\( c_1 \) };
		\draw[latex-] (-1.9,-4.3) -- ++(-3.9,0) node[left] {\( c_2 \) };
		\draw[latex-] (-1.9,-4.55) -- ++(-3.9,0) node[left] {\( c_3 \) };
		\draw[latex-] (-1.9,-4.8) -- ++(-3.9,0) node[left] {\( c_4 \) };

		\draw [thick, decorate,decoration={brace,amplitude=10pt},yshift=2pt]
		(-6.3,-1.2) -- (-6.3,1.3) node [black,midway,xshift=-30pt,align=center]
		{Indirizzi\\di riga};

		\draw [thick, decorate,decoration={brace,amplitude=10pt},yshift=2pt]
		(-6.3,-5) -- (-6.3,-3.7) node [black,midway,xshift=-31pt,align=center]
		{Indirizzi\\di colonna};

		\draw [thick, decorate,decoration={brace,amplitude=10pt},yshift=2pt]
		(-8.4,-5) -- (-8.4,1.3) node [black,midway,xshift=-16pt,align=center]
		{I};

		\draw[latex-latex] (-1,-4.9) -- ++(0,-0.8) node[midway, left] {I/O};
		\draw[latex-] (0.3,-4.9) -- ++(0,-0.8) node[midway, left] {\( R/\bar{w} \) };
		\draw[latex-] (1,-4.9) -- ++(0,-0.8) node[midway, left] {cs};
	\end{tikzpicture}
\end{figure}

\noindent Mediante gli indirizzi di riga e di colonna si può scegliere esattamente la
cella desiderata.
\end{example}

\subsection{Syncronous DRAM (SDRAM)}
La SDRAM è una DRAM sincrona, ovvero sincronizzata con il clock della CPU. Questo
permette di avere una maggiore velocità di trasferimento dei dati.

\begin{example}
\[
	256Mbit \;\; 32Mbit \times 8 \quad \text{celle } 16K \times 16K
\]
Ogni riga ha 16384 bit divisi in 2048 byte. Sono presenti 2 segnali:
\begin{itemize}
	\item \textbf{\( \overline{RAS} \) (Row Address Strobe)}: permette di selezionare la riga
	\item \textbf{\( \overline{CAS} \) (Column Address Strobe)}: permette di selezionare la colonna
\end{itemize}

\begin{figure}[H]
	\centering
	\begin{tikzpicture}
		\node[draw, rectangle, minimum width=4cm, minimum height=4cm, align=center]
		(mat) at (0,0) {16384 righe\\da 2048 byte};

		% decoder 5 bit
		\node[draw, rectangle, minimum width=1cm, minimum height=4cm, align=center]
		(dec) at (-4,0) {Decoder\\di riga};

		\draw[-latex] (-3.25,1.5) node[above right] {} -- ++(1.25,0);
		\draw[-latex] (-3.25,1) node[above right] {} -- ++(1.25,0);
		\node at (-2.6,0) {\( \vdots \)};
		\draw[-latex] (-3.25,-1.5) node[above right] {} -- ++(1.25,0);

		% inputs 0 to 4
		\draw[latex-] (-4.75,0.1) -- ++(-1,0)
		node[left, draw, rectangle, minimum width=1cm, minimum height=1cm, align=center]
		(regR) {Registro\\indirizzo\\riga};

		\node[draw, rectangle, minimum width=0.5cm, minimum height=0.5cm] (rw1) at (-1.5,-2.8) {};
		\draw (-1.65,-2.55) -- ++(0,0.55)
		(-1.35,-2.55) -- ++(0,0.55);

		\node[draw, rectangle, minimum width=0.5cm, minimum height=0.5cm] (rw2) at (-0.5,-2.8) {};
		\draw (-0.65,-2.55) -- ++(0,0.55)
		(-0.35,-2.55) -- ++(0,0.55);

		\node at (0.5,-2.8) {\( \ldots \)};

		\node[draw, rectangle, minimum width=0.5cm, minimum height=0.5cm] (rw32) at (1.5,-2.8) {};
		\draw (1.35,-2.55) -- ++(0,0.55)
		(1.65,-2.55) -- ++(0,0.55);

		\node[draw, rectangle, minimum width=5.5cm, minimum height=1cm, align=center, scale=0.7]
		(mul) at (0,-4.3) {Decoder di colonna};

		\draw[latex-latex] (rw1.south) -- ++(0,-0.85);
		\draw[latex-latex] (rw2.south) -- ++(0,-0.85);
		\draw[latex-latex] (rw32.south) -- ++(0,-0.85);

		\draw[latex-] (-1.9,-4.3) -- ++(-1,0)
		node[left, draw, rectangle, minimum width=1cm, minimum height=1cm, align=center]
		(regC) {Registro\\indirizzo\\colonna};

		\draw[latex-latex] (-1,-4.65) -- ++(0,-0.8) node[midway, left] {I/O};
		\draw[latex-] (0.3,-4.65) -- ++(0,-0.8) node[midway, left] {\( R/\bar{w} \) };
		\draw[latex-] (1,-4.65) -- ++(0,-0.8) node[midway, left] {cs};

		\draw[latex-] (regR.north) -- ++(0,0.5) -- ++(-1,0) node[midway, above] {\( \overline{RAS} \)};
		\draw[latex-] (regC.south) -- ++(0,-0.5) -- ++(-1,0) node[midway, below] {\( \overline{CAS} \)};

		\node at (-8.8,-2.5) (j) {};
		\draw[latex-] (regR.west) -- ++(-0.5,0) |- (j);
		\draw[latex-] (regC.west) -- ++(-3.35,0) |- (j);

		% bit labels
		\draw (-8.5,-2.6) -- ++(0.2,0.2) node[above, xshift=-2, scale=0.7] {14};
		\draw (-7.9,-1.4) -- ++(0.2,0.2) node[right, yshift=-2, scale=0.7] {14};
		\draw (-5.4,0) -- ++(0.2,0.2) node[above, xshift=-2, scale=0.7] {14};
		\draw (-5.4,-4.4) -- ++(0.2,0.2) node[above, xshift=-2, scale=0.7] {11};
		\draw (-2.6,-4.4) -- ++(0.2,0.2) node[above, xshift=-2, scale=0.7] {11};
	\end{tikzpicture}
\end{figure}

\noindent Al primo ciclo di clock viene attivato il segnale \( \overline{RAS} \) selezionando
la riga, al secondo ciclo di clock viene attivato il segnale \( \overline{CAS} \) selezionando
la colonna. In questo modo non servono \( 14 + 11 \) bit, ma ne bastano 14; si sacrifica
il ritardo per guadagnare area.
\end{example}
\vspace{1em}
\noindent La SDRAM è molto efficiente in lettura, perchè una volta impostati i segnali
di riga e colonna, i dati vengono letti in sequenza senza dover cambiare i segnali, come
mostrato nel grafico seguente:

\begin{figure}[H]
	\begin{center}
		\begin{tikzpicture}[scale=1]
			\draw [->] (0,0) -- (7.5,0) node[right] {t};
			\draw (0,0) -- (0,6) node[above] {};
      \foreach \x in {0,0.5,...,7.5}
      \draw[gray!50, ultra thin, help lines] (\x,0) -- (\x,6);

			\draw [blue, ultra thick] plot coordinates { (0,5.5) (0.5,5.5) (0.5,6) (1,6) (1,5.5) (1.5,5.5) (1.5,6) (2,6) (2,5.5) (2.5,5.5) (2.5,6) (3,6) (3,5.5) (3.5,5.5) (3.5,6) (4,6) (4,5.5) (4.5,5.5) (4.5,6) (5,6) (5,5.5) (5.5,5.5) (5.5,6) (6,6) (6,5.5) (6.5,5.5) (6.5,6) (7,6) (7,5.5) (7.5,5.5)};
      \draw [magenta, ultra thick] plot coordinates { (0,5) (0.5,5) (0.5,4.5) (1.5,4.5) (1.5,5) (7.5,5)};
			\draw [red, ultra thick] plot coordinates { (0,4) (2.5,4) (2.5,3.5) (3.5,3.5) (3.5,4) (7.5,4)};
			\draw [orange, ultra thick] plot coordinates { (0,2.75) (0.5,2.75) (0.75,3) (1.25,3) (1.5,2.75) (2.5,2.75) (2.75,3) (3.25,3) (3.5,2.75) (7.5,2.75)};
			\draw [orange, ultra thick] plot coordinates { (0.5,2.75) (0.75,2.5) (1.25,2.5) (1.5,2.75) (2.5,2.75) (2.75,2.5) (3.25,2.5) (3.5,2.75)};
      \draw [green, ultra thick] plot coordinates { (0,1.75) (4.5,1.75) (4.75,2) (5.25,2) (5.5,1.75) (5.75,2) (6.25,2) (6.5,1.75) (6.75,2) (7.25,2) (7.5,1.75) (7.5,1.75)};
      \draw [green, ultra thick] plot coordinates { (4.5,1.75) (4.75,1.5) (5.25,1.5) (5.5,1.75) (5.75,1.5) (6.25,1.5) (6.5,1.75) (6.75,1.5) (7.25,1.5) (7.5,1.75)};
      \draw [cyan, ultra thick] plot coordinates { (0,0.5) (0.5,0.5) (0.5,1) (1,1) (1.5,1) (1.5,0.5) (2.5,0.5) (2.5,1) (3.5,1) (3.5,0.5) (7.5,0.5) };

			\node[blue, anchor=east] at (0,5.75) {CLK};
      \node[magenta, anchor=east] at (0,4.75) {\( \overline{RAS} \) };
      \node[red, anchor=east] at (0,3.75) {\( \overline{CAS} \) };
			\node[orange, anchor=east] at (0,2.75) {Indirizzo};
      \node[green, anchor=east] at (0,1.75) {Dati};
      \node[cyan, anchor=east] at (0,0.75) {\( R/\bar{w} \) };

      \node[scale=0.65] at (5, 1.75) {\textbf{Dato1}};
      \node[scale=0.65] at (6, 1.75) {\textbf{Dato2}};
      \node[scale=0.65] at (7, 1.75) {\textbf{Dato3}};
		\end{tikzpicture}
	\end{center}
	\caption{Segnali di controllo SDRAM}
\end{figure}

\subsection{Caratteristiche}
I dispositivi moderni hanno più di un banco di memoria, questo però rende più complesso
il controllo della memoria. Di conseguenza la distanza dalla CPU alla memoria gioca
un ruolo importante. La seguente tabella mostra le caratteristiche di alcune memorie
ordinate in base alla distanza dalla CPU

\begin{table}[H]
  \centering
  \scalebox{0.83}{
    \begin{tabular}{|c|c|c|c|c|c|}
      \hline
      \textbf{CPU} & \textbf{Tecnologia} & \textbf{Accesso} & \makecell{\textbf{Velocità}\\$\begin{bmatrix} s \end{bmatrix} $} & \makecell{\textbf{Dimensione}\\$\begin{bmatrix} B \end{bmatrix} $} & \makecell{\textbf{Costo}\\$\begin{bmatrix} \text{€}/B \end{bmatrix} $} \\
      \hline
      \textbf{Registri} & \makecell{CMOS\\Elettronica\\Volatile} & Data path & \( 10^{-9} \)  & \( 10^4 \)  & \( 10^{-3} \)  \\
      \hline
      \textbf{Cache} & \makecell{Statica\\Elettronica\\Volatile} & Associativo & \( 10^{-8} \)  & \( 10^7 \)  & \( 10^{-6} \)  \\
      \hline
      \textbf{RAM} & \makecell{Dinamica\\Elettronica\\Volatile} & Casuale & \( 10^{-7} \)  & \( 10^{12} \)  & \( 10^{-8} \)  \\
      \hline
      \textbf{SSD} & \makecell{Elettronica\\Elettronica Flash\\Non volatile} & \makecell{Casuale\\a blocchi} & \( 10^{-5} \)  & \( 10^{10} \)  & \( 10^{-10} \)  \\
      \hline
      \hline
      \textbf{Hard Disk} & \makecell{Magnetica meccanica\\Non volatile} & Diretto & \( 10^{-3} \)  & \( 10^{13} \)  & \( 10^{-11} \)  \\
      \hline
      \textbf{CD/DVD} & Ottica & Diretto & \( 10^{-1} \)  & \makecell{\( 10^{10} \)\\fino a\\\( 10^{11} \)  } & \( 10^{-9} \)  \\
      \hline
      \textbf{Nastri DAT} & Magnetica & Sequenziale & \( 10^0 \)  & \makecell{\( 10^9 \)\\fino a\\\( 10^{11} \) } & \( 10^{-9} \)  \\
      \hline
    \end{tabular}
  }
\end{table}

\begin{itemize}
  \item \textbf{SSD}: Solid State Drive
  \item \textbf{Memoria Elettronica Flash}: È nata con le SIM card, è molto veloce
    e nel tempo è stata utilizzata per realizzare le USB. I droganti del silicio che formano
    le celle di memoria non sono fissi, ma si possono muovere permettendo di modificare
    il silicio. Lo svantaggio è l'isteresi (si può tornare allo stato di origine, ma non sarà
    mai perfettamente uguale a ciò che si aveva in partenza), ovvero la memoria non può essere sovrascritta
    più di un certo numero di volte. All'inizio questo valore era di giorni, per aumentarlo
    si è pensato di distribuire le scritture uniformemente su tutta la memoria per far 
    durare di più la memoria. La memoria flash è circolare e si scrive su un blocco (unità
    minima di lettura e scrittura). Il blocco letto viene copiato in un buffer, cioè una
    memoria RAM. In scrittura invece si scrive prima nel buffer e poi si scrive sul primo
    blocco libero.

    \noindent MTBF (Mean Time Between Failure) è il tempo medio per cui un dispositivo si guasta.
    Quando l'MTBF viene superato, la probabilità di guasto aumenta esponenzialmente.
  \item \textbf{Nastri DAT}: (Digital Audio Tape) è un supporto di memorizzazione
    di dati digitali su nastro magnetico
  \item \textbf{RAM}: La memoria ram è "casuale", cioè la velocità di accesso è costante
    indipendentemente dalla posizione del dato.

  \item \textbf{Cache}: La cache è associativa, cioè il dato è associato ad un indirizzo
    e non ad una posizione, è più veloce, ma bisogna controllare se il dato è presente
    nella cache, se non lo è si verifica una \textbf{cache miss}.
  \item \textbf{Hard disk}: I dati vengono letti in blocchi da 512 byte. Il disco viene 
    letto da una testina con una spira che ne legge la corrente inferita dalla carica
    magnetica del disco, la testina si muove su un braccio che si muove su un asse.
    Questo sistema però è molto fragile, perchè se la testina non è ad una distanza 
    corretta dal disco, si può danneggiare il disco. Il tempo di lettura viene descritto
    dalla seguente formula:
    \[
      T_{HD} = T_{seek} + T_{\omega} + T_{B}
    \] 
    Dove \( T_{seek} \) è il tempo di ricerca, \( T_{\omega} \) è il tempo di rotazione
    e \( T_{B} \) è il tempo di trasferimento del blocco.

    \vspace{1em}
    \textbf{FAT} (File Allocation Table) è una tabella (localizzata nel cerchio più esterno)
    che contiene le informazioni
    sui file presenti nel disco, come la dimensione, la posizione, le directory, ecc. 
    Ogni sistema operativo ha la sua FAT, ma la più famosa è la FAT32.

    \vspace{1em}
    \noindent \textbf{INODE} contiene un puntatore alla posizione del blocco successivo.
    Tutti i blocchi sono collegati da un'unica catena di blocchi liberi. Quando un blocco
    viene utilizzato viene tolto dalla catena di blocchi liberi e viene aggiunto ad
    un file. Quando un file viene cancellato vengono tolti i blocchi relativi a quel file
    e vengono aggiunti alla catena di blocchi liberi.

    \vspace{1em}
    \noindent \textbf{Defrag} è un'operazione che serve a riordinare i blocchi in modo
    che siano tutti vicini tra loro, in modo da ridurre il tempo di accesso.

    \vspace{1em}
    \noindent I dischi moderni sono più di uno e sono in una pila, inoltre vengono
    scritti su entrambi i lati (quindi 2 testine) e quando i dischi sono fermi le
    vengono posizionate in una posizione di sicurezza.

  \item \textbf{CD}: Sono nati per la musica con 700mb di spazio, ma poi sono stati utilizzati per i dati.
    La lettura viene effettuata da un laser che viene riflesso su uno specchietto che
    può ruotare in modo da riflettere il laser su tutte le parti possibili del disco.
    Per creare uno 0 si effettuavano dei veri e propri buchi nel dusco. Il CD è composto
    da una traccia unica che si sviluppa a spirale. All'inizio c'è il nome dei brani (massimo 13)
    e di seguito i brani. In seguito i CD sono anche stati utilizzati per distribuire i
    software.

    \vspace{1em}
    \noindent \textbf{WORM} (Write Once Read Many) è un CD che può essere scritto una sola
    volta e letto più volte. La scrittura viene fatta da un laser più potente che crea
    una cavità nel disco.

    \vspace{1em}
    \noindent Successivamente il CD si è evoluto per poter scrivere e cancellare i dati,
    nasce così il \textbf{DVD}. È presente un gel all'interno del disco che cambia il colore in
    base al colore del laser. Per scrivere si usa una luce rossa e una blu per l'1 e lo 0.
    Per leggere si usa una luce bianca che riflette il colore assunto dal gel all'interno 
    del disco.

    \vspace{1em}
    \noindent Aumentando l'area dei DVD a 10GB si riesce a memorizzare interi film su di
    essi.
\end{itemize}

\begin{figure}[H]
  \centering
  \begin{tikzpicture}[scale=0.7]
    \draw[yscale=0.1] (0,30) arc (180:0:7);
    \draw[->, yscale=0.1] (14,30) arc (0:-170:7);

    \draw (0,0) rectangle (2,2) node[midway] {Blocco};
    \draw (2,0) rectangle (4,2) node[midway] {};
    \draw (4,0) rectangle (6,2) node[midway] {};
    \draw (6,0) rectangle (8,2) node[midway] {};
    \draw (8,0) rectangle (10,2) node[midway] {};
    \draw (10,0) rectangle (12,2) node[midway] {};
    \draw (12,0) rectangle (14,2) node[midway] {};

    \node[draw, rectangle, minimum width=1cm, minimum height=1cm] (buffer) at (9,-2) {Buffer};
    \draw[-latex] (5,0) -- (buffer.west);
    \draw[-latex] (buffer.east) -- (13, 0);
    \node at (buffer.south) [below] {RAM};
  \end{tikzpicture}
  \caption{Struttura della memoria flash}
\end{figure}


\subsection{Gerarchia della memoria}
Il principio di località dice che se si accede ad un dato, è probabile che
si acceda a dati vicini e si divide in:
\begin{itemize}
  \item \textbf{Spaziale}: Se al tempo \( t_j \) accedo alla cella di memoria \( M_i \) succede
    che se considero un intervallo della memoria \( \Delta M_i \) accederò a tutte le celle per
    un certo tempo \( \Delta t \):
    \[
    t_j \; M_i \to M_i + \Delta M \to t_j + \Delta t
    \] 

  \item \textbf{Temporale}: Se accedo ad una certa cella \( m_i \) al tempo \( t_j \) succede
    che se considero un intervallo di tempo \( \Delta t \) accederò ad un intorno di celle
    \( \Delta M_i \):
    \[
    M_i \; t_j \to t_j + \Delta t \; M_i + \Delta M
    \] 
\end{itemize}

\begin{figure}[H]
  \centering
  \begin{tikzpicture}[scale=0.8]
    \draw (0,0) -- (10,0) node[below right] {$t$};
    \draw (0,0) -- (0,5) node[above left] {$t_{acc}$};

    \node at (0,1.6) [left] {Cache};
    \node at (0,3.2) [left] {RAM};

    \draw[red] (0,3.2) -- (1,3.2) -- (1,1.6) -- (4,1.6) -- (4,3.2) -- (4.5,3.2) -- (4.5,1.6) -- (7,1.6) -- (7,3.2) -- (8,3.2) -- (8,1.6) -- (10,1.6);

    \node at (10,1.6) [right] {\( 95\% \) HIT};
    \node at (10,3.2) [right] {\( 5\% \) MISS};
  \end{tikzpicture}
\end{figure}

\noindent La probabilità di trovare un dato in cache (\textbf{cache hit}) è del \( \approx 95\% \),
la probabilità di non trovarlo (\textbf{cache miss}) è del \( \approx 5\% \).

\vspace{1em}
\noindent Più ci si allontana dalla CPU, più la memoria è grande, ma più è lenta, questa
viene chiamato \textbf{gerarchia di memoria} per il principio di località.

\section{Cache}
Nella maggior parte delle architettura la cache fa parte del microprocessore stesso.
Avere una cache è fondamentale per portare il CPI (Clock Per Instruction) a 1.
Consideriamo una dimensione della cache ragionevole di \( 4MB \) e una dimensione
della ram di \( 4GB \). Definiamo ora la dimensione di una "pagina" di \( 1KB \), la
lettura si fa pagina per pagina perchè per il principio di località si è praticamente
certi che se si accede ad una cella si accederà anche a celle vicine. La parola è
la dimensione minima di lettura nella ram, in questo caso è di \( 1B \) 
\[
\#dim \text{ cache} = 4MB
\] 
\[
\#dim \text{ RAM} = 4GB
\] 
\[
\#dim \text{ pagina} = 1KB
\] 
\[
\#dim \text{ parola} = 1B
\] 
\[
\#dim \text{ pagine RAM} = \frac{4GB}{1KB} = 4M
\] 
\[
\#dim \text{ pagine Cache} = \frac{4MB}{1KB} = 4K
\] 

\begin{figure}[H]
  \centering
  \begin{tikzpicture}
    \draw (0,0) rectangle (4,5);
    \node at (2,0) [below] {Cache};

    \draw (4,4.5) -- (0,4.5) node[above left] {0};
    \draw (4,4) -- (0,4) node[above left] {1};
    \draw (4,3.5) -- (0,3.5) node[above left] {2};
    \draw (4,3) -- (0,3) node[above left] {3};
    \draw (4,2.5) -- (0,2.5) node[above left] {4};

    \draw (4,0.5) -- (0,0.5) node[below left] {4K-1};

    \draw[latex-latex] (4,2) -- (5,2);

    \draw (5,-2) rectangle (9,5);
    \node at (7,-2) [below] {RAM};

    \draw (9,4.5) -- (5,4.5) node[above left] {0};
    \draw (9,4) -- (5,4) node[above left] {1};
    \draw (9,3.5) -- (5,3.5) node[above left] {2};
    \draw (9,3) -- (5,3) node[above left] {3};
    \draw (9,2.5) -- (5,2.5) node[above left] {4};

    \draw (9,-1.5) -- (5,-1.5) node[below left] {4M-1};

    \node at (7,3.5) [above] {Dato1};
    \node at (2,3) [above] {Dato1};

    \node at (9,5) [right, scale=0.6] {0};
    \node at (9,4.5) [right, scale=0.6] {1023};

  \end{tikzpicture}
\end{figure}

\noindent La CPU per cercare una parola di memoria deve cercare in cache, se la trova si avrà una
cache hit e allora la
ottiene molto in fretta, altrimenti si avrà una cache miss e si dovrà cercare in RAM.

\noindent Quando avviene una cache miss la CPU deve controllare se il dato in cache che
stava cercando è stato modificato prima di sovrascrivaerlo.

\subsection{Indirizzamento della cache}
Ci sono più modi per organizzare la cache e sono:
\begin{itemize}
  \item Diretto
  \item Set-Associativo (tutte le cache reali sono set-associative)
  \item Associativo
\end{itemize}

\subsubsection{Diretto}
Nel caso di cache diretta si ha che ogni blocco di memoria è associato ad una sola
cella di cache. Viene confrontato l'indirizzo della cache con una lista di etichette
e se l'etichetta è uguale a quella in cui è stato salvato il dato si ha una cache hit.
La lista di etichette contiene tutte le pagine in cache.

\noindent La cache diretta equivale ad avere una cache set-associativa con 4K set.
\begin{figure}[H]
  \centering
  \begin{tikzpicture}
    \draw (-1,0) rectangle (5,1) node[below right, align=center] {Indirizzo\\RAM};
    \node at (2,1) [above] {32};
    \draw (3.5,1) -- (3.5,0);
    \draw (1,1) -- (1,0);

    \draw (1,-3) rectangle (5,-2) node[below right, align=center] {Indirizzo\\Cache};
    \node at (2.5,-2) [above] {22};
    \draw (3.5,-2) -- (3.5,-3);

    \node at (4.2,0.5) {Parola};
    \node at (4.2,0.5) [below, yshift=-15] (parola1) {10};
    \node at (4.2,-2.5) {Parola};
    \node at (4.2,-2.5) [below, yshift=-15] {10};

    \node at (2.3,0.5) {Pagina};
    \node at (2.3,0.5) [below, yshift=-15] {12};
    \node at (2.3,-2.5) {Pagina};
    \node at (2.3,-2.5) [below, yshift=-15] {12};

    \node at (0,0.5) {Etichetta};
    \node at (0,0.5) [below, yshift=-15] (etichetta) {10};

    \node[draw, rectangle, minimum width=1cm, minimum height=1cm, align=center] (vetichetta) at (-2,-2.5) {Vettore di\\etichette};

    \draw[-latex] (etichetta) -- (vetichetta.north);
    \draw[-latex] (vetichetta.east) -- (1,-2.5);

    \draw[-latex] (parola1) -- (4.2,-2);
  \end{tikzpicture}
\end{figure}

\subsubsection{Set-Associativo}
\[
dim \text{ set}= 4
\] 
\[
\# \text{ set cache} = \frac{\# \text{ pagine cache}}{\text{dim set}} = \frac{4K}{4} = 1K
\] 
In questo caso si ha che ogni blocco di memoria può essere associato ad una cella di
cache appartenente ad un set di cache.

\begin{figure}[H]
  \centering
  \begin{tikzpicture}
    \draw (0,0) rectangle (4,5);
    \node at (2,0) [below] {Cache};

    \draw (4,4.5) -- (0,4.5) node[above left] {0};
    \draw (4,4) -- (0,4) node[above left] {1};
    \draw (4,3.5) -- (0,3.5) node[above left] {2};
    \draw (4,3) -- (0,3) node[above left] {3};
    \draw (4,2.5) -- (0,2.5) node[above left] {4};

    \draw (4,0.5) -- (0,0.5) node[below left] {4K-1};

    \draw[latex-latex] (4,2) -- (5,2);

    \draw (5,-2) rectangle (9,5);
    \node at (7,-2) [below] {RAM};

    \draw (9,4.5) -- (5,4.5) node[above left] {0};
    \draw (9,4) -- (5,4) node[above left] {1};
    \draw (9,3.5) -- (5,3.5) node[above left] {2};
    \draw (9,3) -- (5,3) node[above left] {3};
    \draw (9,2.5) -- (5,2.5) node[above left] {4};

    \draw (9,-1.5) -- (5,-1.5) node[below left] {4M-1};

    \node at (7,3.5) [above] {Dato1};
    \node at (2,3) [above] {Dato1};

    \node at (9,5) [right, scale=0.6] {0};
    \node at (9,4.5) [right, scale=0.6] {1023};

    \draw [decorate,decoration={brace,amplitude=10pt,raise=4pt},yshift=0pt]
    (-0.2,3) -- (-0.2,5) node [black,midway,xshift=-1cm] {Set 0};
    \draw [decorate,decoration={brace,amplitude=10pt,raise=4pt},yshift=0pt]
    (-0.2,1) -- (-0.2,3) node [black,midway,xshift=-1cm] {Set 1};

  \end{tikzpicture}
\end{figure}

\noindent Il campo set indica in che set di cache si trova il dato, poi viene
confrontata l'etichetta con le 4 etichette contenute nel set. Se l'etichetta 
è uguale a quella in cui è stato salvato il dato si ha una cache hit, altrimenti
si ha una cache miss.

\begin{figure}[H]
  \centering
  \begin{tikzpicture}
    \draw (-1,0) rectangle (5,1) node[below right, align=center] {Indirizzo\\RAM};
    \node at (2,1) [above] {32};
    \draw (3.5,1) -- (3.5,0);
    \draw (2,1) -- (2,0);

    \draw (1,-3) rectangle (5,-2) node[below right, align=center] {Indirizzo\\Cache};
    \node at (2.5,-2) [above] {22};
    \draw (3.5,-2) -- (3.5,-3);

    \node at (4.2,0.5) {Parola};
    \node at (4.2,0.5) [below, yshift=-15] (parola1) {10};
    \node at (4.2,-2.5) {Parola};
    \node at (4.2,-2.5) [below, yshift=-15] {10};

    \node at (2.8,0.5) {Set};
    \node at (2.8,0.5) [below, yshift=-15] (set) {10};
    \node at (2.3,-2.5) {Pagina};
    \node at (2.3,-2.5) [below, yshift=-15] {12};

    \node at (0.5,0.5) {Etichetta};
    \node at (0.5,0.5) [below, yshift=-15] (etichetta) {12};

    \node[draw, rectangle, minimum width=1cm, minimum height=1cm, align=center] (vetichetta) at (-2,-2.5) {Vettore di\\etichette};

    \draw[-latex] (etichetta) -- (vetichetta.north);
    \draw[-latex] (set) -- (vetichetta.north);
    \draw[-latex] (vetichetta.east) -- (1,-2.5);

    \draw[-latex] (parola1) -- (4.2,-2);
  \end{tikzpicture}
\end{figure}

\subsubsection{Associativo}
Nel caso di cache associativa si ha che ogni blocco di memoria può essere associato
ad una qualsiasi cella di cache. Il vettore di etichette è ordinato in modo che
ogni cella di cache abbia un'etichetta associata.

\noindent Una cache associativa equivale ad una cache set-associativa con un solo set. 
\begin{figure}[H]
  \centering
  \begin{tikzpicture}
    \draw (-1,0) rectangle (5,1) node[below right, align=center] {Indirizzo\\RAM};
    \node at (2,1) [above] {32};
    \draw (3.5,1) -- (3.5,0);

    \draw (1,-3) rectangle (5,-2) node[below right, align=center] {Indirizzo\\Cache};
    \node at (2.5,-2) [above] {22};
    \draw (3.5,-2) -- (3.5,-3);

    \node at (4.2,0.5) {Parola};
    \node at (4.2,0.5) [below, yshift=-15] (parola1) {10};
    \node at (4.2,-2.5) {Parola};
    \node at (4.2,-2.5) [below, yshift=-15] {10};

    \node at (2.3,-2.5) {Pagina};
    \node at (2.3,-2.5) [below, yshift=-15] {12};

    \node at (1,0.5) {Etichetta};
    \node at (1,0.5) [below, yshift=-15] (etichetta) {22};

    \node[draw, rectangle, minimum width=1cm, minimum height=1cm, align=center] (vetichetta) at (-2,-2.5) {Vettore di\\etichette};

    \draw[-latex] (etichetta) -- (vetichetta.north);
    \draw[-latex] (vetichetta.east) -- (1,-2.5);

    \draw[-latex] (parola1) -- (4.2,-2);
  \end{tikzpicture}
\end{figure}

\subsection{Rimpiazzamento}
Quando si ha una cache miss si deve rimpiazzare un blocco di memoria con un altro, ma
bisogna prima controllare se il dato da rimpiazzare serve ancora o no.
Le due tecniche di dimpiazzamento più comuni sono:
\begin{itemize}
  \item \textbf{LRU (Least Recently Used)}: Si rimpiazza il blocco più vecchio (tecnica più utilizzata)

    \vspace{1em}
    \noindent Non funziona nel caso in cui si ha un programma che ha il codice in una sola
    pagina (1024). Questo programma fa un ciclo 1024 volte e accede ad un vettore di caratteri (1B)
    che contiene 3098 caratteri. Considerando una cache con 4 pagine:
    \begin{figure}[H]
      \centering
      \begin{tikzpicture}
        \draw (0,0) rectangle (3,4);

        \draw (3,3) -- (0,3) node[above left, yshift=5] {0};
        \draw (3,2) -- (0,2) node[above left, yshift=5] {1};
        \draw (3,1) -- (0,1) node[above left, yshift=5] {2};
        \draw (3,0) -- (0,0) node[above left, yshift=5] {3};

        \node at (1.5,3.5) {Codice};
        \node at (1.5,2.5) {\( \cancel{Vet0} \) Vet3 };
        \node at (1.5,1.5) {\( \cancel{Vet1} \) Vet0 };
        \node at (1.5,0.5) {\( \cancel{Vet2} \) Vet1 };
      \end{tikzpicture}
    \end{figure}

    \noindent Con LRU viene cancellato il vettore necessario ad ogni ciclo e quindi
    si avranno \( 4 \cdot 1024 \). Con MRU si avranno soltanto \( 4 + 1023 \) 
  \item \textbf{MRU (Most Recently Used)}: Si rimpiazza il blocco più recente
\end{itemize}
Per ogni pagina c'è un contatore che incrementa ogni volta che passa un ciclo di clock
e viene azzerato quando si accede alla pagina.

\subsection{Gestione}
\begin{itemize}
  \item Rilocazione
  \item Paginazione
  \item Memoria virtuale
\end{itemize}
Queste funzioni fanno si che la memoria appaia come uno spazio infinito ad un processo:

\subsubsection{Rilocazione}
\begin{figure}[H]
  \centering
  \begin{tikzpicture}
    \draw (0,0) rectangle (3,4);

    \draw (3,3) -- (0,3);
    \draw (3,2) -- (0,2);
    \draw (3,1) -- (0,1);

    \node at (1.5,3.5) {Codice};
    \node[align=center] at (1.5,2.5) {Dati\\statici};
    \node[align=center] at (1.5,1.5) {Dati\\dinamici};
    \node at (1.5,0.5) {Stack};
    \node at (1.5,-0.5) {Processo};

    \node at (3.5,2) {\( \Rightarrow \) };



    \draw (4,-2) rectangle (7,4);
    \node at (5.5,-2.5) {RAM};
    \node at (4,4) [left] {0};
    \node at (4,-2) [left] {4G-1};

    \draw (4,2) -- (7,2) node[right, scale=0.7] (idx) {10423} node[midway, above, scale=0.7] {Processo};
    \node[draw, rectangle, minimum width=1cm, minimum height=1cm, scale=0.8] (base) at (8.5,2) {Base};

    \draw (4,0) -- (7,0) node[right, scale=0.7] (idx2) {10423};
    \node[draw, rectangle, minimum width=1cm, minimum height=1cm, scale=0.8] (limit) at (8.5,0) {Limit};

    \draw[-latex] (idx) -- (base.west);
    \draw[-latex] (idx2) -- (limit.west);
  \end{tikzpicture}
\end{figure}
c'è bisogno di un meccanismo per trasformare un indirizzo logico (di un processo) in
un indirizzo fisico (della RAM). Questo meccanismo è la rilocazione e si divide in 2
tipi:
\begin{itemize}
  \item \textbf{Rilocazione statica}:
    Il compilatore quando compila non può sapere in che zona della memoria viene
    caricato il processo, quindi l'unica cosa che può dire è l'inizio di ogni sezione
    del processo, ad esempio il codice inizia all'indirizzo 0, ecc...

    \noindent Questa rilocazione prende l'indirizzo logico 0 e gli somma l'indirizzo
    fisico in cui inizia il codice, ad esempio 10423. 

  \item \textbf{Rilocazione dinamica}:
    Prima di inserire l'indirizzo logico nel MAR si somma a quel valore ciò che si trova in un
    registro chiamato \textbf{base} che contiene l'indirizzo fisico in cui inizia il processo.
    È anche presente un registro chiamato \textbf{limit} che contiene la dimensione del processo
    e questo viene usato per controllare che \textbf{base} non sia maggiore di \textbf{limit}.
    Se questo controllo fallisce si ha un errore di segmentation fault. Se il processo
    vuole accedere ad un indirizzo fisico preciso lo deve fare tramite una syscall.
\end{itemize}

\noindent Ci sono però dei problemi, ad esempio quando un processo finisce viene liberato lo spazio
che occupava e quando bisogna mettere in esecuzione un altro processo nello stesso spazio
di quello vecchio, si ha un problema perchè il nuovo processo potrebbe non essere della
stessa dimensione di quello vecchio, per cui potrebbe sovrapporsi ad un altro processo.
Bisogna anche considerare i dati dinamici, cioè ad ogni malloc viene ingrandito lo spazio
in memoria ingrandendo così il \texttt{limit}. Per risolvere questi problemi si usa la
paginazione.

\subsubsection{Paginazione}
La memoria RAM è un insieme di pagine e dei processi possono essere caricati in pagine
diverse.
\begin{figure}[H]
  \centering
  \begin{tikzpicture}
    \draw (0,0) rectangle (3,6);
    \node at (1.5,-0.5) {RAM};

    \draw (0,5.5) -- (3,5.5) node[above right, scale=0.7, yshift=2] {0};
    \draw (0,5) -- (3,5) node[above right, scale=0.7, yshift=2] {1};
    \draw (0,4.5) -- (3,4.5) node[above right, scale=0.7, yshift=2] {2};
    \draw (0,4) -- (3,4) node[above right, scale=0.7, yshift=2] {3};
    \draw (0,3.5) -- (3,3.5) node[above right, scale=0.7, yshift=2] {4};
    \draw (0,3) -- (3,3) node[above right, scale=0.7, yshift=2] {5};
    \draw (0,2.5) -- (3,2.5) node[above right, scale=0.7, yshift=2] {6};
    \draw (0,2) -- (3,2) node[above right, scale=0.7, yshift=2] {7};
    \draw (0,0.5) -- (3,0.5) node[above right, scale=0.7, yshift=2] {4M-1};

    \node at (0,5.75) [left, scale=0.9] {\( P_0 \) };
    \node at (0,5.25) [left, scale=0.9] {\( P_2 \) };
    \node at (0,4.75) [left, scale=0.9] {\( P_1 \) };
    \node at (0,4.25) [left, scale=0.9] {\( P_0 \) };
    \node at (0,3.75) [left, scale=0.9] {\( P_1 \) };
    \node at (0,3.25) [left, scale=0.9] {\( P_2 \) };
    \node at (0,2.75) [left, scale=0.9] {\( P_1 \) };
    \node at (0,2.25) [left, scale=0.9] {\( P_1 \) };
  \end{tikzpicture}
\end{figure}
\noindent Con un meccanismo di paginazione dopo aver sommato \texttt{base} e averlo controllato
con \texttt{limit} si ha ancora un indirizzo logico che dovrà essere tradotto in un
indirizzo fisico corrispondente alla pagina in cui si trova il processo. 

\begin{figure}[H]
  \centering
  \begin{tikzpicture}
    \draw (-1,0) rectangle (5,1) node[below right, align=center] {Indirizzo\\Logico};
    \node at (2,1) [above] {32};
    \draw (3.5,1) -- (3.5,0);

    \draw (-1,-3) rectangle (5,-2) node[below right, align=center] {Indirizzo\\Fisico};
    \node at (2,-2) [above] {32};
    \draw (3.5,-2) -- (3.5,-3);

    \node at (4.2,0.5) {Parola};
    \node at (4.2,0.5) [below, yshift=-15] (parola1) {10};
    \node at (4.2,-2.5) {Parola};
    \node at (4.2,-2.5) [below, yshift=-15] {10};

    \node at (1.3,0.5) {Pagina Logica};
    \node at (1.3,0.5) [below, yshift=-15] {22};
    \node at (1.3,-2.5) {Pagina Fisica};
    \node at (1.3,-2.5) [below, yshift=-15] {22};


    \draw[-latex] (parola1) -- (4.2,-2);
  \end{tikzpicture}
\end{figure}
\noindent La pagina logica (quella in cui si trova il processo) viene mappata in una pagina fisica
(quella in cui si trova il processo in RAM) attraverso una \textbf{tabella delle pagine}.
Questa tabella è una tabella con lunghezza il numero di pagine logiche e ogni cella
contiene l'indirizzo fisico della pagina corrispondente.

\begin{figure}[H]
  \centering
  \begin{tikzpicture}
    \draw (0,0) rectangle (3,4);

    \node[above left, scale=0.8] at (0,4) {Pagina logica};
    \node[above, scale=0.8] at (1.5,4) {Pagina fisica};

    \draw (3,3.5) -- (0,3.5) node[above left, scale=0.7, yshift=3] {0};
    \draw (3,3) -- (0,3) node[above left, scale=0.7, yshift=3] {1};
    \draw (3,2.5) -- (0,2.5) node[above left, scale=0.7, yshift=3] {2};
    \draw (3,2) -- (0,2) node[above left, scale=0.7, yshift=3] {3};
    \draw (3,1.5) -- (0,1.5) node[above left, scale=0.7, yshift=3] {4};
    \draw (3,1) -- (0,1) node[above left, scale=0.7, yshift=3] {5};
    \draw (3,0.5) -- (0,0.5) node[above left, scale=0.7, yshift=3] {6};
    \draw (3,0) -- (0,0) node[above left, scale=0.7, yshift=3] {\( \ldots \)};

    \node at (1.5,3.75) {};
    \node at (1.5,3.25) {1042};
    \node at (1.5,2.75) {};
    \node at (1.5,2.25) {57};
    \node at (1.5,1.75) {6};
    \node at (1.5,1.25) {};
    \node at (1.5,0.75) {4};
    \node at (1.5,0.25) {};
  \end{tikzpicture}
\end{figure}

\noindent È utile avere tutta la tabella soltanto nel caso in cui venga usata tutta la
memoria, che per il principio di località non è possibile. Per questo motivo questa
tabella si trova interamente nella RAM siccome è grande 12MB e ne viene caricata
soltanto una parte nella CPU. Se la CPU non trova la pagina che sta cercando all'
interno della tabella caricata in CPU la va a cercare in cache (o in RAM).

\subsubsection{Memoria virtuale}
Ogni processo ha un numero minimo di pagine necessario per poter essere eseguito senza interruzione,
questo numero è detto \textbf{working set}.

\begin{figure}[H]
  \centering
  \begin{tikzpicture}
    \draw (0,0) -- (8,0) node[right] {\# Pagine};
    \draw (0,0) -- (0,6) node[left] {t exec};
    

    \foreach \x in {1,2,3,4,5,6,7}
      \draw (\x,0.1) -- (\x,-0.1) node[below] {\x};

    \draw [red, smooth, ultra thick] plot coordinates
      { (0.7,6) (1,5) (2,3) (3,2) (4,1.5) (5,1.3) (6,1.25) (7,1.25)};

    \draw [blue, thin] (6,0) -- (6,5.5) node[above] {Working set};
  \end{tikzpicture}
\end{figure}
\noindent Si avrà un numero di pagine di memoria per cui il tempo di esecuzione è minimo.
Si dovrà quindi tenere in memoria soltanto il working set di ogni processo, il resto
della memoria si troverà in un disco rigido in uno spazio riservato al sistema operativo
chiamato \textbf{swap space} che consente di "salvare" le pagine di memoria che non
sono nel working set per ripristinarle quando servono.

\vspace{1em}
\noindent Se la CPU richiede una pagina che non si trova in cache e neanche in RAM, allora
viene presa dal disco e messa in una delle pagine libere della RAM. In questo modo
al processo viene permesso di usare (quasi) tutto lo spazio di memoria che vuole.

\section{Pipeline}
Possiamo dividere il processo di esecuzione in 4 fasi:
\begin{table}[H]
  \begin{center}
    \begin{tabular}{c|cc}
      \textbf{Fase} & \textbf{Memoria} & \textbf{Clock} \\
      \hline
      Fetch & 1 & 1 \\
      Decode & $0-1$ & 1 \\
      Execute & 0 & 1 \\
      Write B. & $0-1$ & 1 \\
      \hline
      Totale & $1-3$ & 4 
    \end{tabular}
  \end{center}
\end{table}

\begin{itemize}
  \item \textbf{Fetch}: Ha un circuito di somma a parte, per permettere di sommare in
    un ciclo di clock è necessario avere dei registri flip-flop al posto di registri
    latch.
  \item \textbf{Decode}: Prende dalla memoria i parametri per l'operazione da fare. Se
    i dati al posto di essere nei registri sono in memoria bisogna accedere alla
    memoria e quindi si avranno 0 cicli di memoria se il dato non è presente in memoria,
    1 se è presente.
  \item \textbf{Execute}: Esegue l'operazione richiesta. Sicuramente non si avranno
    accessi alla memoria. La fase exec impiega 1 ciclo di clock se e solo se si ha
    un'operazione aritmetica che prende dei dati da 2 registri e li mette in un terzo
    registro. Con un solo bus non si può raggiungere un ciclo di clock perchè visto che
    si può trasferire un solo dato alla volta bisogna fare più cicli di clock per trasferire
    più dati. Se invece avessimo 3 bus per fare i calcoli sarebbe possibile fare l'exec
    in un solo ciclo di clock.
  \item \textbf{Write Back}: Siccome l'accesso a memoria richiede circa 10 cicli di clock bisogna
    ridurre il numero di accessi alla memoria, questo si fa sfruttando la cache. Un altro
    modo per ridurre i cicli di memoria è di impedire che ci siano cicli di memoria
    in Write quando ci sono già stati in Decode e viceversa. Si dovranno avere istruzioni
    che facciano massimo 1 accesso alla memoria. Di conseguenza al posto di avere
    come totale $1-3$ cicli di memoria si avranno $1-2$:
    \begin{table}[H]
      \begin{center}
        \begin{tabular}{c|cc}
          \textbf{Fase} & \textbf{Memoria} & \textbf{Clock} \\
          \hline
          Fetch & 1 & 1 \\
          Decode & $0-1$ & 1 \\
          Execute & 0 & 1 \\
          Write B. & $0-1$ & 1 \\
          \hline
          Totale & $1-2$ & 4 
        \end{tabular}
      \end{center}
    \end{table}

    \noindent Supponendo che la chache-hit sia al 100\% si avrà un totale di
    $5-6$ cicli di clock.
\end{itemize}

Per ottimizzare ancora di più il CPI si sfrutta il concetto di \textbf{Pipeline}.

\subsection{Concetto di pipeline}
La pipeline può essere vista come un vero e proprio sistema di tubi, come ad esempio il
trasporto del gas che ci impiega un po' per arrivare a destinazione, ma una volta
arrivato il gas arriva in continuazione.

\vspace{1em}
\noindent Se applichiamo questo concetto alla CPU possiamo vedere le fasi della cpu
in più stati:
\begin{figure}[H]
  \centering
  \begin{tikzpicture}[scale=0.8]
    % F-D-E-W Cycle
    \draw (0,0) rectangle (1.5,1.5) node[midway, scale=0.8] {Fetch};
    \draw (3.5,0) rectangle (5,1.5) node[midway, scale=0.8] {Decode};
    \draw (7,0) rectangle (8.5,1.5) node[midway, scale=0.8] {Execute};
    \draw (10.5,0) rectangle (12,1.5) node[midway, scale=0.8] {Write};
    
    % Tmp registers
    \draw (2,2) rectangle (3,-0.5);
    \draw (5.5,2) rectangle (6.5,-0.5);
    \draw (9,2) rectangle (10,-0.5);

    \draw (2,1.375) -- (3,1.375) node[midway, above, scale=0.7] {IR}; 
    \draw (2,0.75) -- (3,0.75) node[midway, above, scale=0.7] {PC}; 

    \draw (5.5,1.375) -- (6.5,1.375) node[midway, above, scale=0.7] {OP1}; 
    \draw (5.5,0.75) -- (6.5,0.75) node[midway, above, scale=0.7] {OP2}; 
    \draw (5.5,0.125) -- (6.5,0.125) node[midway, above, scale=0.7] {OP3};
    \node at (6,-0.5) [above, scale=0.7] {PSW};

    \draw (9,1.375) -- (10,1.375) node[midway, above, scale=0.7] {Ris};
    \draw (9,0.75) -- (10,0.75) node[midway, above, scale=0.7] {PSW};

    % Arrows
    \draw[-latex] (1.5,0.75) -- ++(0.5,0);
    \draw[-latex] (3,0.75) -- ++(0.5,0);
    \draw[-latex] (5,0.75) -- ++(0.5,0);
    \draw[-latex] (6.5,0.75) -- ++(0.5,0);
    \draw[-latex] (8.5,0.75) -- ++(0.5,0);
    \draw[-latex] (10,0.75) -- ++(0.5,0);

    \draw[-latex] (11.25, 0) -- ++(0,-2) |- (5,-2.5);
    \draw[latex-] (4.25, 0) -- ++(0,-2);
    \draw[latex-] (0.75, 0) -- ++(0,-2);

    % Main reg
    \draw (0,-3) rectangle (5,-2) node[midway, scale=0.8] {REG};

    % Other
    \node[draw, rectangle, minimum width=1cm, minimum height=1cm, scale=0.8, align=center]
      (cacheIst) at (0.75,3) {Cache\\istruzioni};
    \draw[-latex] (cacheIst.south) -- (0.75,1.5);

    \node[draw, rectangle, minimum width=1cm, minimum height=1cm, scale=0.8, align=center]
      (cacheDat) at (4.25,3) {Cache\\dati};
    \draw[-latex] (cacheDat.south) -- (4.25,1.5);

    \draw[-latex] (11.25,1.5) -- ++(0,1) |- (cacheDat);
  \end{tikzpicture}
\end{figure}
\noindent Ogni stato della pipeline lavorerà sulla copia dei registri messi a disposizione
agli stati. Nel momento in cui una serie di istruzioni arriva alla pipeline si avrà che
al primo ciclo di clock verrà eseguita la fase di Fetch della prima, al secondo la Fetch
della seconda e la decode della prima e così via. In questo modo in un ciclo di clock
si processano più istruzioni alla volta, di conseguenza alla fine della pipeline
si avrà un CPI minore.

\subsection{Stallo}
Può succedere che durante l'esecuzione ci sia uno stato che va in stallo. Se ad esmpio
si ha una compare e una jump di seguito, la jump non può essere eseguita finchè la
compare non ha finito di eseguire. In questo caso si ha uno stallo che crea una
\textbf{bolla} cioè uno stato che vuole lavorare non può e quindi si creano delle
\textbf{dipendenze} tra le istruzioni.

\subsection{Ottimizzazione}
Per far tendere il CPI a 1 bisogna avere una pipeline efficiente.

\vspace{1em}
\noindent Le dipendenze possono essere di più tipi e si risolvono nel seguente modo:
\begin{itemize}
  \item \textbf{Istruzioni}:
    Si possono "allontanare" le istruzioni dipendenti riordinandole
    mantenendo però il senso del programma. I microprocessori moderni riordinano
    automaticamente le istruzioni per evitare stallo caricandole in blocco e
    riordinandole in modo da evitare stallo.
  \item \textbf{Salti condizionali}: Siccome non si sa quale ramo della condizione
    verrà eseguito si può fare \textbf{predizione di salto}. La predizione di salto
    viene fatta attraverso un circuito chiamato \textbf{crystal ball}. Finchè non si
    arriva alla write back i dati non vengono modificati, quindi per predirre il salto
    viene fatta partire la fetch mentre l'istruzione di salto aspetta la compare e
    se il compare è falso si butta via la fetch appena fatta e si fa ripartire la
    fetch non appena finisce la compare. Se il compare è vero si continua con la fetch
    fatta risparmiando così CPI.

    \vspace{1em}
    \noindent Ci sono metodi più efficienti per fare la predizione di salto, infatti alcuni
    salti hanno una probabilità maggiore di essere veri rispetto ad altri. Per questo
    motivo si considera che un salto sia vero. Se invece il salto è falso si usa
    l'output precedentemente salvato per decidere se fare la fetch o meno.
\end{itemize}

\begin{table}[H]
  \centering
  \resizebox{\columnwidth}{!}{%
    \begin{tabular}{|c|c|c|c|c|c|c|c|c|c|c|c|c|}
      \hline
      Istruzione & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 & 10 & 11 & 12 \\
      \hline
      movl \%eax \%eax & F & D & E & W & & & & & F & D & E & W \\
      \hline
      addl \$4, \%ecx & & F & D & E & W & & & & & F & D & E \\
      \hline 
      subl \$1, \%ebx & & & F & D & D & E & W & & & & F & D \\
      \hline
      cmpl \%eax, \%ecx & & & & \footnotesize{NOP} & F & D & E & W & & & & \\
      \hline
      jz init & & & & & & F & D & D & D & E & W & \\
      \hline
    \end{tabular}%
  }
\end{table}

\noindent Nell'istruzione subl al 4 ciclo di clock il registro \%ebx non è
ancora pronto, quindi si aspetta 1 ciclo di clock finchè non è pronto. Per
capire quanto un registro è pronto è presente un flag che segna se un certo
registro è stabile o se è ancora in esecuzione.

\[
  CPI_{medio} = \frac{11}{5} \approx 2.2
\] 
\[
\Downarrow
\] 
\[
  CPI_{medio} = \frac{11 - \overbrace{4}^{\text{ist. per riempire pipeline}}}{5} \approx 1.4
\] 
\[
\Downarrow
\] 
\[
  CPI_{medio} = \frac{12-4}{6} \approx 1.35
\] 
L'ultimo CPI calcolato è dopo aver fatto tutte le branch dei jmp.

\section{RISC (Reduced Instruction Set Computer)}
Il tempo di esecuzione di un programma è dato da:
\[
  T_{cpu} = N_{istr} \cdot CPI_{m} \cdot \frac{1}{f_{clk}}
\] 
La cosa negativa è che i 3 fattori sono collegati, quindi non ci si può concentrare
per minimizzarne uno alla volta.
\begin{itemize}
  \item \( f_{clk} \): 
    \begin{itemize}
      \item 
        Non si può aumentare a piacere perchè nella CPU è presente
        un datapath con un cammino critico che fissa il tempo di clock.
      \item La pipeline permette di aumentare \( f_{clk} \) ma non
        è possibile aumentare all'infinito il numero di stadi della pipeline.
      \item L'ISA (Instruction Set Architecture) è un altro fattore che
        influenza \( f_{clk} \) perchè se si ha un'ISA complessa si avrà
        un \( f_{clk} \) più basso. Il legame tra il set di istruzioni
        e frequenza di clock è estremamente stretto.
    \end{itemize}
  \item \( N_{istr} \):
    \begin{itemize}
      \item In base all'ISA si avrà un numero diverso di istruzioni per uno
        stesso programma. Se si volesse ridurre il numero di istruzioni da
        un programma compilato bisognerebbe creare un ISA con istruzioni più
        complesse. Questo però portava il CPI a salire e le frequenze a scendere.
      \item 2 Professori della Stanford University Hennessey e Patterson
        hanno raccolto diversi programmi in svariati linguaggi e hanno notato
        che il 90\% delle istruzioni avevano 2 o 3 operandi, quindi espressioni
        semplici. I cicli erano singoli, quindi non c'erano cicli dentro cicli.
        Gli if erano al massimo a 2 innestazioni. Nonostante tutta la complessità
        il codice viene scritto in modo semplice e spesso quando le istruzioni
        sono semplici il codice è scritto meglio. I professori si sono accorti
        che indipendentemente dai compilatori e dagli ISA la maggior parte
        dell'assembly aveva istruzioni semplici. Si aveva il 90\% di istruzioni
        semplici e il 10\% complicate. Hanno inventato il RISC (Reduced Instruction Set Computer)
        e si è iniziato a chiamare gli altri processori CISC (Complex Instruction Set Computer).

        \noindent Siccome a Stanford c'era una fonderia di silicio i 2 professori
        hanno creato il primo processore RISC chiamato DLX. Con questo microprocessore
        mostrarono con i dati alla mano che la loro idea era giusta.

        \noindent Successivamente il MIPS diventò il primo microprocessore RISC
        commerciale
    \end{itemize}
\end{itemize}

\subsection{Caratteristiche del RISC}
\begin{itemize}
  \item Istruzioni semplici
  \item Pochi metodi di indirizzamento
  \item Pipeline bilanciata dovuta alle istruzioni semplici
    \begin{itemize}
      \item Abbatte il CPI facendolo tendere a 1
      \item Aumenta la frequenza di clock
    \end{itemize}
\end{itemize}

\subsection{Alcuni processori RISC}
\begin{itemize}
  \item Intel
    \begin{itemize}
      \item 80386: 60-80 MHz
      \item Pentiun: 90 MHz
      \item P6: 200 MHz
    \end{itemize}
  \item MIPS: 100 MHz
  \item Motorola IBM
    \begin{itemize}
      \item PowerPC: 200 MHz poi fino a 600 MHz
    \end{itemize}
  \item DEC
    \begin{itemize}
      \item Alpha: 600 MHz
    \end{itemize}
  \item SUN
    \begin{itemize}
      \item SPARC
    \end{itemize}
\end{itemize}

Quando intel creò le istruzioni 80x86 per passarle al processore P6 si utilizza
un \textbf{pre fetcher} che traduce le istruzioni 80x86 in istruzioni RISC.
Questo sistema permetteva di avere un processore CISC ma con le prestazioni di
un RISC. Dopo questa invenzione intel inventò il microprocessore Pentium.

\section{Evoluzione dei calcolatori}
\begin{itemize}
  \item Anni '90:

    \noindent La rivoluzione RISC ha portato ad un aumento delle prestazioni
    e ha raggiunto l'obiettivo di avere un CPI uguale a 1. Nonostante questo
    si è continuato a cercare di aumentare le prestazioni.
    \begin{itemize}
      \item L'utente percepisce soltanto il tempo di elaborazione: \( T_{cpu} \),
        quindi bisogna diminuire il tempo di esecuzione.

      \item Il gestore del sistema (gestisce un pc per più utenti) percepisce
        le prestazioni in un altro modo. Esiste un livello minimo del tempo
        di esecuzione di un processo oltre il quale non cambia la percezione
        delle prestazioni. Il gestore però vuole che il tempo di esecuzione
        sia uguale per tutti gli utenti, quindi:
        \[
         \frac{\text{n° processi}}{\text{unità di tempo}}
        \] 
        il gestore vuole avere il maggior numero di processi per unità di tempo.

    \end{itemize}
    \vspace{1em}
    \noindent Per aumentare le prestazioni sono nate le CPU \textbf{superscalari}
    che hanno un \( CPI_{m} < 1 \). PowerPC è stato il primo a scendere sotto
    l'1 dedicando una pipeline per l'esecuzione di interi e una per i float
    riuscendo così ad eseguire 2 operazioni in 1 ciclo di clock e quindi
    \( CPI_{m} = 0.5 \). Separando le pipeline si possono anche avere più segnali
    di clock e quindi il cammino critico sarà quello della ALU intera.

    \begin{figure}[H]
      \centering
      \begin{tikzpicture}[scale=0.7]
        % Pre fetch
        \draw (-4, -0.4) rectangle (-2, 1.6) node[midway, align=center] (pref) {Pre\\fetch};

        \draw[-latex] (-2,0.6) -- (0,2.1);
        \draw[-latex] (-2,0.6) -- (0,-1.0);

        \begin{scope}[shift={(0,1.5)}, scale=0.8]
            % F-D-E-W Cycle
            \draw (0,0) rectangle (1.5,1.5) node[midway, scale=0.8] (pipeline1) {};
            \draw (3.5,0) rectangle (5,1.5) node[midway, scale=0.8] {};
            \draw (7,0) rectangle (8.5,1.5) node[midway, scale=0.8] {};
            \draw (10.5,0) rectangle (12,1.5) node[midway, scale=0.8] {};

            % Tmp registers
            \draw (2,2) rectangle (3,-0.5);
            \draw (5.5,2) rectangle (6.5,-0.5);
            \draw (9,2) rectangle (10,-0.5);

            \draw[transparent] (2,1.375) -- (3,1.375) node[midway, above, scale=0.7] {}; 
            \draw[transparent] (2,0.75) -- (3,0.75) node[midway, above, scale=0.7] {}; 

            \draw[transparent] (5.5,1.375) -- (6.5,1.375) node[midway, above, scale=0.7] {}; 
            \draw[transparent] (5.5,0.75) -- (6.5,0.75) node[midway, above, scale=0.7] {}; 
            \draw[transparent] (5.5,0.125) -- (6.5,0.125) node[midway, above, scale=0.7] {};
            \node at (6,-0.5) [above, scale=0.7] {};

            \draw[transparent] (9,1.375) -- (10,1.375) node[midway, above, scale=0.7] {};
            \draw[transparent] (9,0.75) -- (10,0.75) node[midway, above, scale=0.7] {};

            % ALU
            \begin{scope}[shift={(15,-3.75)}, scale=1.5, rotate=90]
              \draw (2.7,0.5) -- (3.3,0.5) -- (3.5,1.5) -- (3.2,1.5) -- (3,1.2) -- (2.8,1.5) -- (2.5,1.5) -- cycle;
              \node[above, scale=0.6] at (3,0.5) (alu) {};
            \end{scope}
            \node[right, align=center, scale=0.8, xshift=5, yshift=-2] at (alu) {Interi};

            % Arrows
            \draw[-latex] (1.5,0.75) -- ++(0.5,0);
            \draw[-latex] (3,0.75) -- ++(0.5,0);
            \draw[-latex] (5,0.75) -- ++(0.5,0);
            \draw[-latex] (6.5,0.75) -- ++(0.5,0);
            \draw[-latex] (8.5,0.75) -- ++(0.5,0);
            \draw[-latex] (10,0.75) -- ++(0.5,0);
        \end{scope}

        \begin{scope}[shift={(0,-1.5)}, scale=0.8]
            % F-D-E-W Cycle
            \draw (0,0) rectangle (1.5,1.5) node[midway, scale=0.8] (pipeline2) {};
            \draw (3.5,0) rectangle (5,1.5) node[midway, scale=0.8] {};
            \draw (7,0) rectangle (8.5,1.5) node[midway, scale=0.8] {};
            \draw (10.5,0) rectangle (12,1.5) node[midway, scale=0.8] {};

            % Tmp registers
            \draw (2,2) rectangle (3,-0.5);
            \draw (5.5,2) rectangle (6.5,-0.5);
            \draw (9,2) rectangle (10,-0.5);

            \draw[transparent] (2,1.375) -- (3,1.375) node[midway, above, scale=0.7] {}; 
            \draw[transparent] (2,0.75) -- (3,0.75) node[midway, above, scale=0.7] {}; 

            \draw[transparent] (5.5,1.375) -- (6.5,1.375) node[midway, above, scale=0.7] {}; 
            \draw[transparent] (5.5,0.75) -- (6.5,0.75) node[midway, above, scale=0.7] {}; 
            \draw[transparent] (5.5,0.125) -- (6.5,0.125) node[midway, above, scale=0.7] {};
            \node at (6,-0.5) [above, scale=0.7] {};

            \draw[transparent] (9,1.375) -- (10,1.375) node[midway, above, scale=0.7] {};
            \draw[transparent] (9,0.75) -- (10,0.75) node[midway, above, scale=0.7] {};

            % ALU
            \begin{scope}[shift={(15,-3.75)}, scale=1.5, rotate=90]
              \draw (2.7,0.5) -- (3.3,0.5) -- (3.5,1.5) -- (3.2,1.5) -- (3,1.2) -- (2.8,1.5) -- (2.5,1.5) -- cycle;
              \node[above, scale=0.6] at (3,0.5) (alu2) {};
            \end{scope}
            \node[right, align=center, scale=0.8, xshift=5, yshift=-2] at (alu2) {Virgola\\mobile};

            % Arrows
            \draw[-latex] (1.5,0.75) -- ++(0.5,0);
            \draw[-latex] (3,0.75) -- ++(0.5,0);
            \draw[-latex] (5,0.75) -- ++(0.5,0);
            \draw[-latex] (6.5,0.75) -- ++(0.5,0);
            \draw[-latex] (8.5,0.75) -- ++(0.5,0);
            \draw[-latex] (10,0.75) -- ++(0.5,0);
        \end{scope}
      \end{tikzpicture}
    \end{figure}
    \vspace{1em}
    \noindent Successivamente sono state aggiunte più pipeline all'unità di
    prefetch, il problema però è che le dipendenze possono accadere tra più
    pipeline diverse.
    
    \vspace{1em}
    \noindent Successivamente nacque il \textbf{VLIW} (Very Long Instruction Word)
    che permetteva di avere più istruzioni in un'unica istruzione. Questo è possibile
    utilizzando un registro da 256 bit che contiene più istruzioni (8 istruzioni) tutte
    svolte in parallelo. Aggiungere un registro troppo grande può creare problemi
    con le dipendenze tra le istruzioni.
    \begin{figure}[H]
      \centering
      \begin{tikzpicture}
        % Pre fetch
        \node[draw, rectangle, minimum width=1.5cm, minimum height=1.5cm, scale=1.0, align=center]
          (pref) at (-1.5,0) (pref) {Pre\\fetch};

        \draw[-latex] (pref.east) -- (0,0);

        \begin{scope}[shift={(0,-0.6)}, scale=0.8]
          % F-D-E-W Cycle
          \draw (0,0) rectangle (1.5,1.5) node[midway, scale=0.8] (pipeline2) {};
          \draw (3.5,0) rectangle (5,1.5) node[midway, scale=0.8] {};
          \draw (7,0) rectangle (8.5,1.5) node[midway, scale=0.8] {};
          \draw (10.5,0) rectangle (12,1.5) node[midway, scale=0.8] {};

          % Tmp registers
          \draw (2,2) rectangle (3,-0.5);
          \draw (5.5,2) rectangle (6.5,-0.5);
          \draw (9,2) rectangle (10,-0.5);

          \draw (2,1.375) -- (3,1.375) node[midway, above right, scale=0.5] {64}; 
          \draw (2,0.75) -- (3,0.75) node[midway, above right, scale=0.5] {64}; 
          \draw (2,0.125) -- (3,0.125) node[midway, above right, scale=0.5] {64};
          \node at (2.5,-0.5) [above right, scale=0.5] {64};
          \node at (2.25,-0.5) [below right, scale=0.7] {256};

          \draw (5.5,1.375) -- (6.5,1.375) node[midway, above right, scale=0.5] {64}; 
          \draw (5.5,0.75) -- (6.5,0.75) node[midway, above right, scale=0.5] {64}; 
          \draw (5.5,0.125) -- (6.5,0.125) node[midway, above right, scale=0.5] {64};
          \node at (6,-0.5) [above right, scale=0.5] {64};
          \node at (5.75,-0.5) [below right, scale=0.7] {256};

          \draw (9,1.375) -- (10,1.375) node[midway, above right, scale=0.5] {64};
          \draw (9,0.75) -- (10,0.75) node[midway, above right, scale=0.5] {64};
          \draw (9,0.125) -- (10,0.125) node[midway, above right, scale=0.5] {64};
          \node at (9.5,-0.5) [above right, scale=0.5] {64};
          \node at (9.25,-0.5) [below right, scale=0.7] {256};

          % Arrows
          \draw[-latex] (1.5,0.75) -- ++(0.5,0);
          \draw[-latex] (3,0.75) -- ++(0.5,0);
          \draw[-latex] (5,0.75) -- ++(0.5,0);
          \draw[-latex] (6.5,0.75) -- ++(0.5,0);
          \draw[-latex] (8.5,0.75) -- ++(0.5,0);
          \draw[-latex] (10,0.75) -- ++(0.5,0);
        \end{scope}
      \end{tikzpicture}
    \end{figure}

    \vspace{1em}
    \noindent Successivamente si tentò di implementare il parallelismo e sono
    nati i calcolatori vettoriali che permettevano di eseguire operazioni in
    parallelo grazie a più ALU. Il computer vettoriale più famoso era il
    Thinking Machine che aveva più CPU che lavoravano in parallelo scrivendo
    il risultato in un'unica memoria condivisa.
    \begin{figure}[H]
      \centering
      \begin{tikzpicture}
        \node[draw, rectangle, minimum width=1.5cm, minimum height=1.5cm, scale=1.0, align=center]
          (pref) at (0,-0.5) (pref) {Pre\\fetch};

        \node[draw, rectangle, minimum width=0.5cm, minimum height=0.5cm, scale=1.0, align=center]
          (pref) at (2,1) (cpu1) {};
        \node[draw, rectangle, minimum width=0.5cm, minimum height=0.5cm, scale=1.0, align=center]
          (pref) at (2,0) (cpu2) {};
        \node[draw, rectangle, minimum width=0.5cm, minimum height=0.5cm, scale=1.0, align=center]
          (pref) at (2,-1) (cpu3) {};
        \node[draw, rectangle, minimum width=0.5cm, minimum height=0.5cm, scale=1.0, align=center]
          (pref) at (2,-2) (cpu4) {};
        
        \node[below, scale=0.7] at (cpu4.south) {CPU};

        \node[draw, rectangle, minimum width=1.5cm, minimum height=3.5cm, scale=1.0, align=center]
          (pref) at (4,-0.5) (mem) {Memoria};

        % Arrows
        \draw[-latex] (pref.east) -- (cpu1.west);
        \draw[-latex] (pref.east) -- (cpu2.west);
        \draw[-latex] (pref.east) -- (cpu3.west);
        \draw[-latex] (pref.east) -- (cpu4.west);

        \draw[-latex] (cpu1.east) -- (mem.west);
        \draw[-latex] (cpu2.east) -- (mem.west);
        \draw[-latex] (cpu3.east) -- (mem.west);
        \draw[-latex] (cpu4.east) -- (mem.west);

        \draw (2.3, 1.5) -- ++(0,0.2) -- ++(0.8,0) node[midway, scale=0.7, above, align=center]
          {Matrice di\\interconnessioni} -- ++(0,-0.2);
      \end{tikzpicture}
    \end{figure}

    \noindent Questo sistema però scomparve
    per la legge di \textbf{Amdahl} che dice che la prestazione totale
    è data da:
    \[
      P_{T_1} = U_1 \cdot  P_1 + U_2 \cdot  P_2 + \ldots + U_k \cdot  P_k
    \]
    Che sarebbe la somma delle moltiplicazioni del tempo di utilizzo del componente moltiplicato
    per la sua prestazione. Se si aumentano le prestazioni del secondo componente
    di 100 volote si ha:
    \[
      P_{T_2} = U_1 \cdot P_1 + 100 \cdot U_2 \cdot P_2 + \ldots + U_k \cdot P_k
    \] 
    e lo speedup è:
    \[
      S = \frac{P_{T_2}}{P_{T_1}}
    \] 
    Il miglioramento dipende dalla percentuale di utilizzo di quel componente, quiundi
    se viene usato poco la prestazione non migliora molto. Quindi se la percentuale
    di paralelizzazione dell'intero sistema è più bassa del 90\% non si ha un
    miglioramento significativo perchè rimane una parte sequenziale.

    \vspace{1em}
    \noindent L'idea dei calcolatori vettoriali è fallita, quindi si è passati
    a parallelizzare i processi (task) riducendo il tempo totale di esecuzione dei
    processi. Sono nati quindi i \textbf{Multiprocessori}

    \begin{figure}[H]
      \centering
      \begin{tikzpicture}
        \draw (0,0) -- (7,0);

        \draw (0.5,1) rectangle (1.5,2) node[midway, scale=0.8] {\( CPU_1 \) };
        \draw (0.5,2) rectangle (1.5,2.5) node[midway, scale=0.8] {\( cache_1 \) };
        \draw[latex-latex] (1,1) -- (1,0);

        \draw (2,1) rectangle (3,2) node[midway, scale=0.8] {\( CPU_2 \) };
        \draw (2,2) rectangle (3,2.5) node[midway, scale=0.8] {\( cache_2 \) };
        \draw[latex-latex] (2.5,1) -- (2.5,0);

        \draw (3.5,1) rectangle (4.5,2) node[midway, scale=0.8] {\( CPU_3 \) };
        \draw (3.5,2) rectangle (4.5,2.5) node[midway, scale=0.8] {\( cache_3 \) };
        \draw[latex-latex] (4,1) -- (4,0);

        \draw (5.5,1) rectangle (6.5,2) node[midway, scale=0.8] {Mem};
        \draw (5.5,2) rectangle (6.5,2.5) node[midway, scale=0.8] {pagine};
        \draw[latex-latex] (6,1) -- (6,0);

        \draw (1.4,-1) rectangle (2.0,-1.6) node[midway, scale=0.8] {I/O};
        \draw[latex-latex] (1.7,0) -- (1.7,-1);

        \draw (2.9,-1) rectangle (3.5,-1.6) node[midway, scale=0.8] {I/O};
        \draw[latex-latex] (3.2,0) -- (3.2,-1);

        \draw (4.4,-1) rectangle (5.0,-1.6) node[midway, scale=0.8] {I/O};
        \draw[latex-latex] (4.7,0) -- (4.7,-1);
      \end{tikzpicture}
    \end{figure}

    \noindent Siccome ogni CPU ha una cache diversa e la memoria è condivisa tra le CPU
    allora le pagine della memoria possono trovarsi in cache diverse e questo
    crea il problema della \textbf{coerenza della cache}. Si può risolvere
    in diversi modi, ma l'algoritmo migliore è quello di \textbf{Snoopy} (ficcanaso) che
    continua a monitorare il bus e tutte le volte che vede un indirizzo si salva
    questa informazione. Si avrà quindi una tabella aggiuntiva che contiene
    l'indirizzo e il processore che lo ha in cache. Se una CPU vuole una pagina
    che si trova nella cache di un'altra CPU deve chiedere di inserirla in memoria
    perchè potrebbe essere non aggiornata.

    \vspace{1em}
    \noindent Avere più CPU però non sempre migliora le prestazioni, questo perchè
    si ha un solo bus e quindi si ha un collo di bottiglia. A 4 CPU si arriva
    alle prestazioni massime.

    \begin{figure}[H]
      \centering
      \begin{tikzpicture}
        \draw (0,0) -- (8,0) node[right] {\# CPU};
        \draw (0,0) -- (0,6) node[left] {Prestazione};


        \foreach \x in {1,2,3,4,5,6,7}
        \draw (\x,0.1) -- (\x,-0.1) node[below] {\x};

        \draw [red, smooth, ultra thick] plot coordinates
          { (0,0) (1,0.7) (2,1.25) (3,1.6) (4,1.8) (5,1.85) (8,1.85) };

        \draw (0,0) -- (6,6);

        \draw [red, thin, dashed] (4,0) -- (4,1.8);
        \draw [red, thin, dashed] (0,1.8) -- (4,1.8);
      \end{tikzpicture}
    \end{figure}

    \noindent Si potrebbe aumentare il numero di bus, ma questo aumenterebbe i costi e la
    complessità del sistema.

    \begin{figure}[H]
      \centering
      \begin{tikzpicture}
        \draw (0,0) -- (7,0);
        \draw (0,-2.5) -- (7,-2.5);

        \draw (0.5,1) rectangle (1.5,2) node[midway, scale=0.8] {\( CPU_1 \) };
        \draw (0.5,2) rectangle (1.5,2.5) node[midway, scale=0.8] {\( cache_1 \) };
        \draw[latex-latex, xshift=7] (1,1) -- (1,0);
        \draw[-latex, xshift=-7] (1,1) -- (1,-2.5);

        \draw (2,1) rectangle (3,2) node[midway, scale=0.8] {\( CPU_2 \) };
        \draw (2,2) rectangle (3,2.5) node[midway, scale=0.8] {\( cache_2 \) };
        \draw[latex-latex, xshift=7] (2.5,1) -- (2.5,0);
        \draw[-latex, xshift=-7] (2.5,1) -- (2.5,-2.5);

        \draw (3.5,1) rectangle (4.5,2) node[midway, scale=0.8] {\( CPU_3 \) };
        \draw (3.5,2) rectangle (4.5,2.5) node[midway, scale=0.8] {\( cache_3 \) };
        \draw[latex-latex, xshift=7] (4,1) -- (4,0);
        \draw[-latex, xshift=-7] (4,1) -- (4,-2.5);

        \draw (5.5,1) rectangle (6.5,2) node[midway, scale=0.8] {Mem};
        \draw (5.5,2) rectangle (6.5,2.5) node[midway, scale=0.8] {pagine};
        \draw[latex-latex] (6,1) -- (6,0);

        \draw (1.4,-1) rectangle (2.0,-1.6) node[midway, scale=0.8] {I/O};
        \draw[latex-latex] (1.7,0) -- (1.7,-1);
        \draw[latex-latex] (1.7,-2.5) -- (1.7,-1.6);

        \draw (2.9,-1) rectangle (3.5,-1.6) node[midway, scale=0.8] {I/O};
        \draw[latex-latex] (3.2,0) -- (3.2,-1);
        \draw[latex-latex] (3.2,-2.5) -- (3.2,-1.6);

        \draw (4.4,-1) rectangle (5.0,-1.6) node[midway, scale=0.8] {I/O};
        \draw[latex-latex] (4.7,0) -- (4.7,-1);
        \draw[latex-latex] (4.7,-2.5) -- (4.7,-1.6);
      \end{tikzpicture}
    \end{figure}

  \item Anni 2000:

    \vspace{1em}
    \noindent Nacquero i Network Chip (N.C) con più chip (multicore) in cui ogni chip aveva una cache
    condivisa e ci si poteva accedere in parallelo.
    \begin{figure}[H]
      \centering
      \begin{tikzpicture}
        \draw (0,0) rectangle (8,8);

        \draw (6,8) -- (6,0);
        \node at (7,4) {Cache};

        \draw (0.5,0.5) rectangle (1.5,1.5);
        \node at (1.4,1) (core1) {};
        \node at (6.1,1) (cache1) {};

        \draw (0.5,2) rectangle (1.5,3);
        \node at (1.4,2.5) (core2) {};
        \node at (6.1,2.5) (cache2) {};

        \draw (0.5,3.5) rectangle (1.5,4.5);
        \node at (1.4,4) (core3) {};
        \node at (6.1,4) (cache3) {};

        \draw (0.5,5) rectangle (1.5,6);
        \node at (1.4,5.5) (core4) {};
        \node at (6.1,5.5) (cache4) {};

        \draw (0.5,6.5) rectangle (1.5,7.5);
        \node at (1.4,7) (core5) {};
        \node at (6.1,7) (cache5) {};

        \draw[-latex] (core1) -- (cache1);
        \draw[-latex] (core1) -- (cache2);
        \draw[-latex] (core1) -- (cache3);
        \draw[-latex] (core1) -- (cache4);
        \draw[-latex] (core1) -- (cache5);

        \draw[-latex] (core2) -- (cache1);
        \draw[-latex] (core2) -- (cache2);
        \draw[-latex] (core2) -- (cache3);
        \draw[-latex] (core2) -- (cache4);
        \draw[-latex] (core2) -- (cache5);

        \draw[-latex] (core3) -- (cache1);
        \draw[-latex] (core3) -- (cache2);
        \draw[-latex] (core3) -- (cache3);
        \draw[-latex] (core3) -- (cache4);
        \draw[-latex] (core3) -- (cache5);

        \draw[-latex] (core4) -- (cache1);
        \draw[-latex] (core4) -- (cache2);
        \draw[-latex] (core4) -- (cache3);
        \draw[-latex] (core4) -- (cache4);
        \draw[-latex] (core4) -- (cache5);

        \draw[-latex] (core5) -- (cache1);
        \draw[-latex] (core5) -- (cache2);
        \draw[-latex] (core5) -- (cache3);
        \draw[-latex] (core5) -- (cache4);
        \draw[-latex] (core5) -- (cache5);

        \node[below, align=center] at (4,0) {CPU\\Multicore};
      \end{tikzpicture}
    \end{figure}

    \vspace{1em}
    \noindent Con l'arrivo di applicazioni multimediali e real-time nacque la
    GPU (Graphics Processing Unit) che permetteva di fare calcoli molto semplici
    in parallelo. La GPU è composta da migliaia di piccoli processori che eseguono
    operazioni elementari e la memoria video viene salvata all'interno del chip
    (in memory computation) per eliminare la necessità del bus.

    \vspace{1em}
    \noindent Per aumentare la complessità nacque la GPGPU (General Purpose GPU)
    che permette di fare calcoli più complessi con la GPU. Questo permette di
    scrivere un programma in cui la parte sequenziale viene eseguita dalla CPU
    e la parte parallelizzabile viene eseguita in parallelo sulla GPU.

    \vspace{1em}
    \noindent Con l'avvento dell'intelligenza artificiale basata sui dati si
    è passati ad usare la GPGPU per costruire le reti neurali.
\end{itemize}

\end{document}
