\documentclass[a4paper]{article}
\usepackage{import}
\input{../../../preamble.sty}

\begin{document}

\input{title.tex}

\tableofcontents
\pagebreak

% Info:
% Libri: Sommerdille - Ingegneria del Software
%        Larman - Applicare UML e i Pattern
% Esame: Il risultato finale è la media dei 2 voti tra Ingegneria
%        e programmazione 2.
%        L'esame consiste in un esame orale concentrato su un
%        progetto da discutere, più alcune domande sulla teoria.
%        Il progetto è da scegliere fra 3 proposti dal docente.
%        Il progetto riguarda il progetto e lo sviluppo di un
%        software, bisogna anche implementare un sistema di
%        memorizzazione sulla memoria di massa (fare anche i test). 
%        Il progetto deve essere svolto in gruppi da 2 o 3 persone.
\section{Introduzione}
\subsection{Cos'è l'ingegneria del software?}
L'ingegneria del software è un insieme di metodologie, teorie, metodi e strumenti, che
guidano nello sviluppo di software \textbf{professionale} in modo che esso fornisca
le funzionalità richieste, sia performante e mantenibile, affidabile e usabile. Il
\textbf{software} non è solo il programma e l'eseguibile, ma anche \textbf{la 
documentazione associata}. Le attività principale dell'ingegneria del software sono:
\begin{itemize}
  \item \textbf{Specifica del software}: Il cliente e l'ingegnere del software definiscono
  le funzionalità e i vincoli del software da produrre.
  \item \textbf{Sviluppo}: Il software viene progettato e implementato.
  \item \textbf{Validazione}: Il software viene verificato per
    assicurarsi che soddisfi i requisiti forniti dal cliente.
  \item \textbf{Evoluzione}: Il software viene modificato per adattarlo a nuovi
    requisiti del cliente o del mercato. 
\end{itemize}

\subsubsection{Economia}
Il software spesso costa più dell'hardware, e il costo è più legato alla manutenzione che
allo sviluppo. Quindi l'ingegneria del software è importante per ridurre i costi di
manutenzione.

\subsubsection{Fallimento dei progetti}
I progetti spesso falliscono per la \textbf{crescente complessità del sistema}: nuove 
tecniche di sviluppo e nuove tecnologie rendono i sistemi sempre più complessi, e quindi 
più difficili da mantenere.

\subsection{Prodotti software}
\subsubsection{Prodotti generici}
Sono prodotti che vengono pubblicizzati e venduti a qualsiasi cliente che ne faccia 
richiesta. La specifica è di proprietà del produttore e le decisioni sulle modifiche
sono prese dai produttori.

\subsubsection{Prodotti personalizzati}
Sono prodotti che vengono commissionati da clienti specifici per soddisfare le loro
necessità. La specifica è di proprietà del cliente dopo una contrattazione con il
produttore e le decisioni sulle modifiche sono prese dal cliente.

\subsection{Etica dell'ingegneria del software}
Progettare software richiede ulteriori responsabilità rispetto alla semplice applicazione
delle abilità tecniche. Gli ingegneri si devono comportare in modo etico e responsabile
e ciò implica più del semplice seguire la legge, bisogna infatti seguire un insieme di
principi moralmente corretti.

I problemi principali della responsabilità morale sono:
\begin{itemize}
  \item \textbf{Confidenzialità}: gli ingegneri dovrebbero rispettare la confidenzialità
    delle informazioni fornite dai clienti o da altri a prescindere dal fatto che sia
    stato firmato un contratto di confidenzialità

  \item \textbf{Competenza}: gli ingegneri non dovrebbero rappresentare in modo negativo
    il loro livello di competenza e non dovrebbero accettare volutamente incarichi che
    vanno oltre le loro competenze

  \item \textbf{Diritti di proprietà intellettuale}: gli ingegneri dovrebbero essere a
    conoscenza delle leggi che governano l'utilizzo delle proprietà intellettuali, come
    brevetti, copyright, ecc...e dovrebbero assicurarsi che la proprietà intellettuale
    dei datori di lavoro e dei clienti sia protetta 

  \item \textbf{Utilizzo sbagliato dei computer}: gli ingegneri non dovrebbero utilizzare
    i computer per attività immorali, illegali o malevoli
\end{itemize}

\subsubsection{Codice etico ACM/IEEE}
Società professionali hanno creato un codice etico da rispettare per tutti i membri
di queste società. Questo codice contiene 8 principi relativi al comportamento e alle
decisioni degli ingegneri:
\begin{itemize}
    \item \textbf{Pubblico:} Gli ingegneri del software devono agire in modo coerente con
      l'interesse pubblico.
    \item \textbf{Cliente e datore di lavoro:} Gli ingegneri del software devono agire 
      in modo da tutelare al meglio gli interessi del loro cliente e datore di lavoro, 
      in coerenza con l'interesse pubblico.
    \item \textbf{Prodotto:} Gli ingegneri del software devono garantire che i loro 
      prodotti e le relative modifiche soddisfino i più alti standard professionali 
      possibili.
    \item \textbf{Giudizio:} Gli ingegneri del software devono mantenere integrità e 
      indipendenza nel loro giudizio professionale.
    \item \textbf{Gestione:} I manager e i leader nell'ingegneria del software devono
      aderire e promuovere un approccio etico alla gestione dello sviluppo e della 
      manutenzione del software.
    \item \textbf{Professione:} Gli ingegneri del software devono promuovere l'integrità
      e la reputazione della professione in coerenza con l'interesse pubblico.
    \item \textbf{Colleghi:} Gli ingegneri del software devono essere equi e solidali 
      con i loro colleghi.
    \item \textbf{Se stessi:} Gli ingegneri del software devono partecipare a un
      apprendimento continuo riguardante la pratica della loro professione e promuovere
      un approccio etico alla pratica professionale.
\end{itemize}

\subsubsection{Esempi}
Alcuni esempi di dilemmi etici sono:
\begin{itemize}
  \item Disaccordo di principio con le politiche imposte dai superiori
  \item Il datore di lavoro si comporta in modo non etico e rilascia un sistema
    che può essere dannoso per la sicurezza senza finire la fase di test del sistema
  \item Partecipazione nello sviluppo di armi militari o di sistemi nucleari
\end{itemize}

\subsubsection{Casi di studio}
Prendiamo ad esempio i seguenti casi da studiare:
\begin{itemize}
  \item \textit{Pompa di insulina personale}: un sistema embedded in una pompa di insulina
    utilizzata dai diabetici per controllare l'insulina nel sangue

    \vspace{1em}
    \noindent
    In base ad un sensore del sangue il sistem calcola la quantità di insulina da iniettare.
    Il calcolo è basato sul cambiamento dei livelli di glucosio nel sangue. Questi dati
    vengono inviati ad una micro-pompa che invia la dose corretta di insulina.

    Questo è un sistema \textbf{safety-critical} perchè bassi livelli di glucosio nel
    sangue possono portare a effetti negativi della salute.

    I requisiti del sistema sono:
    \begin{itemize}
      \item Iniettare insulina quando richiesto
      \item Deve, in modo affidabile e corretto, iniettare la quantità corretta di insulina
      \item Il sistema deve essere progettato e implementato per far si che il sistema
        soddisfi \textbf{sempre} i requisiti
    \end{itemize}

  \item \textit{Un sistema di gestione di cartelle cliniche per pazienti con problemi di
    salute mentale}:
    Mentcare, un sistema utilizzato per mantenere cartelle cliniche per pazienti con
    problemi di salute mentale

    \vspace{1em}
    \noindent
    La maggior parte dei pazienti non ha bisogno di essere ricoverata, ma ha bisogno di
    specialisti che li seguono. Questo sistema permette ai pazienti di avere un accesso
    diretto ai loro dati in locale e di poterli condividere con i loro medici.

    Gli obiettivi sono:
    \begin{itemize}
      \item Supportare le attività di trattamento dei pazienti
      \item Generare informazioni che permettono ai medici di valutare il trattamento
        e di fare diagnosi
      \item Monitorare i progressi dei pazienti
      \item Amministrare le cartelle cliniche
    \end{itemize}
    I problemi principali sono:
    \begin{itemize}
      \item Privacy dei dati confidenziali
      \item Sicurezza dei pazienti, che potrebbero avere comportamenti pericolosi verso
        se stessi o verso altri.
    \end{itemize}

  \item \textit{Stazione del meteo}: un sistema che colleziona dati sul meteo in aree remote

    \vspace{1em}
    \noindent
    Le stazioni raccolgono dati da un insieme di sensori che periodicamente misurano 
    temperatura, pressione, quantità di radiazione solare, quantità di pioggia, velocità 
    e direzione del vento.

    Queste stazioni sono responsabili di raccogliere e trasmettere i dati a un centro di
    controllo dopo un'iniziale processamento. Queste stazioni possono comunicare tramite
    i satelliti tra di loro per creare dei report sui principali problemi.

    Il centro di controllo raccoglie i dati da tutte le stazioni, li analizza e li processa
    e li archivia.

    I requisiti del sistema sono:
    \begin{itemize}
      \item Monitorare i sensori, l'hardware dell'energia e della comunicazione e riportare
        i problemi al centro di controllo

      \item Monitorare il sistema di energia assicurando che le batterie siano ricaricate
        quando le condizioni ambientali lo permettono e che i generatori siano spenti
        durante conditioni pericolose

      \item Supportare una reconfigurazione dinamica che permette di rimpiazzare parti del
        software con delle nuove versioni e di sostituire i sensori danneggiati
    \end{itemize}

  \item \textit{iLearn}: un sistema che agevola lo studio

    \vspace{1em}
    \noindent
    iLearn è un sistema che contiene strumenti e applicazioni general-purpose progettati
    per supportare l'apprendimento. Gli strumenti presenti nel sistema sono scelti dai
    docenti e dagli studenti. Alcuni esempi di applicazioni sono:
    \begin{itemize}
      \item Fogli di calcolo
      \item Strumenti di presentazione
      \item Strumenti di consegna e gestione dei compiti ed esami
    \end{itemize}

    Questo sistema è di tipo service-oriented, cioè è composto da un insieme di servizi
    che possono essere combinati per creare un sistema unico e configurabile, questo
    permette di aggiornare il sistema in modo incrementale ogni volta che sono necessari
    nuovi servizi.

    I requisiti del sistema sono:
    \begin{itemize}
      \item Servizi di utilità generale che forniscono funzionalità di base indipendenti
        dalle applicazioni e che potrebbero essere utilizzati da altri servizi nel sistema

      \item Servizi applicativi che mettono a disposizione applicazioni specifiche e 
        contenuto educazionale

      \item Servizi di configurazione che servono ad adattare un ambiente con un insieme
        specifico di applicazioni e definiscono in che modo i servizi sono condivisi tra
        professori, studenti e genitori
    \end{itemize}
\end{itemize}

\subsection{Caratteristiche di un buon software}
\begin{itemize}
  \item \textbf{Mantenibilità}: la facilità con cui il software può essere modificato
  per correggere difetti, migliorare le prestazioni o adattarlo a cambiamenti.


  \item \textbf{Affidabilità e sicurezza}: la capacità del software di svolgere le sue
  funzioni in modo corretto. I malfunzionamenti non devono causare danni fisici o economici.
  Utenti malintenzionati non devono poter violare la sicurezza del sistema.
  
  \item \textbf{Efficienza}: il software non deve sprecare risorse (CPU, memoria, ecc).

  \item \textbf{Accettabilità}: il software deve essere accettato dagli utenti per i quali
  è stato progettato.
\end{itemize}

\subsection{Problemi che influenzano il software}
\begin{itemize}
  \item \textbf{Eterogeneità}:
    I sistemi devono sempre di più operare in modo distribuito, e quindi devono essere in grado
    di comunicare con sistemi diversi. Oppure bisogna garantire che il software funzioni su
    piattaforme diverse.

  \item 
    \textbf{Cambiamento sociale o del business}:
    Il software deve essere in grado di adattarsi a cambiamenti sociali o organizzativi
    nelle aziende.

  \item 
    \textbf{Sicurezza e fiducia}:
    Siccome il software fa parte della vita di tutti i giorni è essenziale che ci sia
    fiducia nel software.

  \item 
    \textbf{Scalabilità}:
    Il software deve essere sviluppato a più scale, cioè soluzione che funziona in piccolo
    deve adattarsi anche a grandi scale senza rischiare di fallire.
\end{itemize}

\subsection{Tipi di applicazione}
Ci sono diversi tipi di sistemi software e non c'è un insieme universale di tecniche
applicabili a tutti i sistemi. Quindi i metodi e gli strumenti utilizzati dipendono
dal tipo di applicazione che si deve sviluppare, dalle richieste dei clienti
e dalle competenze degli sviluppatori. I principali tipi di applicazione sono:
\begin{itemize}
  \item 
    \textbf{Applicazioni stand-alone}:
    Sono applicazioni che si eseguono su un singolo computer locale e includono le
    funzionalità necessarie per l'utente.

  \item 
    \textbf{Applicazioni interattive transaction-based}:
    Sono applicazioni che sono eseguite su un computer in remoto e sono accessibili
    dagli utenti dai propri computer. Queste includono le applicazioni web come
    gli e-commerce.

  \item 
    \textbf{Sistemi embedded}:
    Sono applicazioni che controllano e gestiscono dispositivi hardware. Questi sistemi
    sono i più numerosi.

  \item 
    \textbf{Sistemi batch}:
    Questi sistemi elaborano grandi quantità di dati per produrre un output.

  \item 
    \textbf{Sistemi di intrattenimento}:
    Questi sistemi sono per uso personale e servono ad intrattenere l'utente.

  \item 
    \textbf{Sistemi di modellazione e simulazione}:
    Questi sistemi sono sviluppati da scienziati per modallare processi fisici o situazioni
    che includono tanti oggetti separati che interagiscono tra di loro.

  \item 
    \textbf{Sistemi di collezione di dati (o IOT)}:
    Questi sitemi raccolgono dati da sensori e li inviano ad un sistema centrale per
    l'elaborazione.

  \item 
    \textbf{Sistemi di sistemi}:
    Questi sistemi sono composti da più sistemi software che collaborano tra di loro.
\end{itemize}



\subsection{Principi fondamentali}
\begin{itemize}
  \item I sistemi devono essere sviluppati utilizzando un processo strutturato e ben
    pensato.
  \item L'affidabilità e la performance sono importanti per ogni tipo di software.
  \item Capire e gestire i requisiti del software è essenziale.
  \item Dove appropriato si dovrebbe riutilizzare software che è già stato sviluppato
    al posto di svilupparne uno da zero.
\end{itemize}

\section{Processi del software}
I \textbf{processi} del software sono un insieme di attività strutturate che sono necessarie
per sviluppare un sistema software. Ci sono diversi tipi di processi, ma tutti coinvolgono
le seguenti attività:
\begin{itemize}
  \item \textbf{Specificazione}
  \item \textbf{Sviluppo}
  \item \textbf{Design e implementazione}
  \item \textbf{Validazione}
  \item \textbf{Evoluzione}
\end{itemize}
Un modello di processo software è una rappresentazione astratta di un processo da un punto
di vista particolare.

Per descrivere e discutere i processi di solito si parla delle attività all'interno di
questi processi e dell'ordine in cui queste attività vengono svolte. Alcune descrizioni
possono anche includere:
\begin{itemize}
  \item \textbf{Prodotti}: cioè i risultati di un'attività.
  \item \textbf{Ruoli}: cioè le responsabilità di un individuo o di un gruppo.
  \item \textbf{Pre e post condizioni}: cioè le condizioni che devono essere soddisfatte
    prima e dopo un'attività.
\end{itemize}
Alcuni esempi di processi sono:
\begin{itemize}
  \item \textbf{Processi plan-driven}: sono processi dove tutte le attività sono pianificate
    in anticipo e tutti i progressi sono misurati rispetto al piano.
  \item \textbf{Processi agili}: sono processi in cui la pianificazione è incrementale ed
    è più facile adattarsi ai cambiamenti.
\end{itemize}
Nel pratico si utilizza un approccio ibrido tra i due.

\subsection{Modelli di processo}
\begin{itemize}
  \item \textbf{Modello a cascata}: è un modello plan-driven con fasi di specificazione e
    di sviluppo distinte e separate
  \item \textbf{Modello incrementale}: la specifica, lo sviluppo e la validazione sono
    intercalate. Può essere plan-driven o agile.
  \item \textbf{Integrazione e configurazione}: i sistemi sono sviluppati da componenti
    già esistenti e configurabili.
\end{itemize}
Nel pratico, sistemi molto grandi sono sviluppati utilizzando un processo che incorpora
elementi di tutti e tre i modelli.

\subsubsection{Modello a cascata}
\begin{figure}[H]
  \centering
  \begin{tikzpicture}[
    node distance=0.4cm and 0cm,
    every node/.style={draw,rectangle,align=center,scale=0.8,rounded corners=1mm},
    ]
    \node (1) {Definizione dei\\requisiti};
    \node[below right=of 1]
      (2) {Design del sistema\\e del software};
    \node[below right=of 2]
      (3) {Implementazione e\\unit testing};
    \node[below right=of 3]
      (4) {Integrazione e\\testing del sistema};
    \node[below right=of 4]
      (5) {Operazione e\\manutenzione};

    \draw[->] (1) -| (2);
    \draw[->] (2) -| (3);
    \draw[->] (3) -| (4);
    \draw[->] (4) -| (5);

    \draw (5) -- (1.south |- 52,52 |- 5.west);
    \draw[<-] (4.south) -- (4.south |- 52,52 |- 5.west);
    \draw[<-] (3.south) -- (3.south |- 52,52 |- 5.west);
    \draw[<-] (2.south) -- (2.south |- 52,52 |- 5.west);
    \draw[<-] (1.south) -- (1.south |- 52,52 |- 5.west);
  \end{tikzpicture}
  \caption{Modello a cascata}
\end{figure}

\noindent
Le diverse fasi del modello a cascata sono:
\begin{itemize}
  \item Analisi e definizione dei requisiti
  \item Design del sistema e del software
  \item Implementazione e unit testing
  \item Integrazione e testing del sistema
  \item Operazione e manutenzione
\end{itemize}

\noindent
Il vantaggio del modello a cascata è la partizione inflessibile del progetto in fasi 
distinte rende difficile rispondere ai cambiamenti dei requisiti, quindi questo modello 
è adatto solo per progetti dove i requisiti sono ben definiti e i cambiamenti rimangono 
limitati. Però pochi progetti soddisfano queste condizioni.

\vspace{1em}
\noindent
Questo modello è più utilizzato in sistemi molto grandi e sviluppati da molte persone.
In quelle circostanze la natura plan-driven di questo modello è utile per coordinare
il lavoro.

\subsubsection{Modello incrementale}
\begin{figure}[H]
  \centering
  \begin{tikzpicture}
    \node[draw,rectangle,align=center]
      (outline) {Descrizione\\dell'outline};

    \node[fill,fill opacity=0.2,rectangle,align=center,minimum width=3cm,
      minimum height=4.5cm]
      (box1) [right=of outline] {};
    \node[above,at={(box1.north)},align=center] {Attività\\concorrenti};

    \draw[->] (outline) -- (box1);

    \node[
      draw=black,fill=white,rectangle,align=center,at={(box1.north)},yshift=-0.8cm,
      minimum width=2.3cm,minimum height=0.8cm,rounded corners
      ]
      (specification) {Specificazione};

    \node[
      draw=black,fill=white,rectangle,align=center,at={(box1)},minimum width=2.3cm,
      minimum height=0.8cm,rounded corners
      ]
      (development) {Sviluppo};

    \node[
      draw=black,fill=white,rectangle,align=center,at={(box1.south)},yshift=0.8cm,
      minimum width=2.3cm, minimum height=0.8cm,rounded corners
      ]
      (validation) {Validazione};

    \draw[<->] (specification) -- (development);
    \draw[<->] (development) -- (validation);

    \node[fill,fill opacity=0.2,rectangle,align=center,minimum width=3cm,
      minimum height=4.5cm]
      (box2) [right=of box1] {};

    \node[
      draw=black,fill=white,rectangle,align=center,at={(box2.north)},yshift=-0.8cm,
      minimum width=2.3cm,minimum height=0.8cm
      ]
      (init) {Versione\\iniziale};

    \node[
      draw=black,fill=white,rectangle,align=center,at={(box2)},minimum width=2.3cm,
      minimum height=0.8cm,shift={(0.1cm,-0.2cm)}
      ]
      (offset1) {};
    \node[
      draw=black,fill=white,rectangle,align=center,at={(offset1)},minimum width=2.3cm,
      minimum height=0.8cm,shift={(-0.1cm,0.1cm)}
      ]
      (offset2) {};
    \node[
      draw=black,fill=white,rectangle,align=center,at={(offset2)},minimum width=2.3cm,
      minimum height=0.8cm,shift={(-0.1cm,0.15cm)}
      ]
      (intermediate) {Versioni\\intermedie};

    \node[
      draw=black,fill=white,rectangle,align=center,at={(box2.south)},yshift=0.8cm,
      minimum width=2.3cm, minimum height=0.8cm
      ]
      (final) {Versione\\finale};

    \draw[<->] (specification) -- (init);
    \draw[<->] (development) -- (intermediate);
    \draw[->] (validation) -- (final);
  \end{tikzpicture}
  \caption{Modello incrementale}
\end{figure}
\noindent
I vantaggi del modello incrementale sono:
\begin{itemize}
  \item Il costo del cambiamento dei requisiti è ridotto e la quantità di analisi e
    documentazione da rifare è molto meno rispetto al modello a cascata.

  \item È più facile ottenere un feedback dagli utenti sul lavoro svolto.

  \item È possibile consegnare software utile più velocemente al cliente.
\end{itemize}
Gli svantaggi del modello incrementale sono:
\begin{itemize}
  \item Il processo non è visibile, cioè è difficile valutare il progresso. I manager
    hanno bisogno di costanti "deliverables", cioè risultati intermedi, per misurare
    il progresso e non sempre è poco costoso produrre documenti che riflettono lo stato
    di ogni versione del software.

  \item La struttura del sistema tende a decadere con l'aggiunta di nuovi incrementi.
    A meno che il tempo e i soldi non vengano spesi per il refactor e il miglioramento
    del software, i cambiamenti regolari tenderanno a corrompere la struttura del sistema
    e quindi incorporare nuovi cambiamenti diventerà sempre più difficile e costoso.
\end{itemize}

\subsubsection{Modello a integrazione e configurazione}
Questo modello si basa sulla realizzazione di sistemi integrati tramite componenti
software già esistenti e configurabili. Il riutilizzo è l'approccio standard per
creare molti tipi di sistemi.

I tipi di software riutilizzabile sono:
\begin{itemize}
  \item Applicazioni o sistemi stand-alone (a volte chiamati COTS, Commercial Off-The-Shelf)
    che sono configurati per essere utilizzati in un certo ambiente
    
  \item Collezioni di oggetti o librerie che sono sviluppati come pacchetti per 
    l'integrazione con vari framework

  \item Servizi web sviluppati secondo standard che permettono l'interazione tramite
    internet
\end{itemize}
Le attività principali di questo modello sono:
\begin{itemize}
  \item Specificazione dei requisiti
  \item Ricerca e analisi del software riutilizzabile
  \item Adattamento dei requisiti
  \item Configurazione del sistema
  \item Adattamento e integrazione dei componenti
\end{itemize}
I vantaggi di questo modello sono:
\begin{itemize}
  \item Riduzione dei costi e del rischio siccome meno software è sviluppato da zero
    
  \item Deployment più veloce
\end{itemize}
Gli svantaggi sono:
\begin{itemize}
  \item È inevitabile fare compromessi per i requisiti, quindi i sistemi potrebbero non
    essere più ciò che aveva richiesto il cliente

  \item Perdita di controllo sull'evoluzione dei componenti riutilizzati
\end{itemize}

\subsection{Attività dei processi}
I processi software reali sono sequenze interconnesse di attività tecniche, collaborative
e manageriali con l'obiettivo di specificare, progettare, implementare e testare un
sistema software. Questi quattro processi base sono organizzati in modo differente
in processi di sviluppo diversi.

\subsubsection{Specificazione}
Il processo di stabilire che processi sono richiesti e quali sono i vincoli sull'operazione
e lo sviluppo del sistema è chiamato \textbf{specificazione del software} e consiste in:
\begin{itemize}
  \item \textbf{Ricavo e analisi dei requisiti}: cosa vogliono o cosa si aspettano
    gli utenti interessati dal sistema

  \item \textbf{Specifica dei requisiti}: definizione formale dei requisiti del sistemao

  \item \textbf{Validazione dei requisiti}: verifica che i requisiti siano completi e
    consistenti
\end{itemize}

\subsubsection{Design}
Questo processo consiste nella conversione delle specifiche del sistema in un sistema
eseguibile e consiste in:
\begin{itemize}
  \item \textbf{Design del software}: progettazione di una struttura software che
    realizzi i requisiti del sistema

  \item \textbf{Implementazione}: traduzione del design in un programma eseguibile
\end{itemize}
Queste attività sono interconnesse e spesso si intrecciano.
\begin{figure}[H]
  \centering
  \begin{tikzpicture}

    % Box 1 ------------------------------------------------------------------------------
    \node[fill,fill opacity=0.2,rectangle,align=center,minimum width=9.5cm,
      minimum height=2cm]
      (box1) {};

    \node[above right,at={(box1.north west)},align=center] {Design inputs};

    \node[
      draw=black,fill=white,rectangle,align=center,at={(box1)},minimum width=2.7cm,
      minimum height=1.2cm,xshift=-3cm
      ]
      (info) {Informazioni\\della piattaforma};

    \node[
      draw=black,fill=white,rectangle,align=center,at={(box1)},minimum width=2.7cm,
      minimum height=1.2cm
      ]
      (requirements) {Specifica\\dei requisiti};

    \node[
      draw=black,fill=white,rectangle,align=center,at={(box1)},minimum width=2.7cm,
      minimum height=1.2cm,xshift=3cm
      ]
      (data) {Descrizione\\dei dati};
    % Box 1 ------------------------------------------------------------------------------

    % Box 2 ------------------------------------------------------------------------------
    \node[fill,fill opacity=0.2,rectangle,align=center,minimum width=9.5cm,
      minimum height=3.8cm]
      (box2) [below=of box1] {};

    \node[above right,at={(box2.north west)},align=center] {Attività di design};

    \node[
      draw=black,fill=white,rectangle,align=center,at={(box2.north)},minimum width=2.7cm,
      minimum height=1.2cm,shift={(-3cm,-1cm)},rounded corners=6mm
      ]
      (archi) {Design\\architetturale};

    \node[
      draw=black,fill=white,rectangle,align=center,at={(box2.north)},minimum width=2.7cm,
      minimum height=1.2cm,shift={(0cm,-1cm)},rounded corners=6mm
      ]
      (interface) {Design\\dell'interfaccia};

    \node[
      draw=black,fill=white,rectangle,align=center,at={(box2.north)},minimum width=2.7cm,
      minimum height=1.2cm,shift={(3cm,-1cm)},rounded corners=6mm
      ]
      (component) {Design\\dei componenti};

    \node[
      draw=black,fill=white,rectangle,align=center,at={(box2.north)},minimum width=2.7cm,
      minimum height=1.2cm,shift={(0cm,-2.8cm)},rounded corners=6mm
      ]
      (database) {Design del database};

    \draw[->] (archi) -- (interface);
    \draw[->] (interface) -- (component);

    \draw[->] (archi) -- (database);
    \draw[->] (component) -- (database);

    \draw[->] (box1) -- (box2);
    % Box 2 ------------------------------------------------------------------------------

    % Box 3 ------------------------------------------------------------------------------
    \node[fill,fill opacity=0.2,rectangle,align=center,minimum width=12.1cm,
      minimum height=2cm]
      (box3) [below=of box2] {};

    \node[above right,at={(box3.north west)},align=center] {Design outputs};

    \node[
      draw=black,fill=white,rectangle,align=center,at={(box3)},minimum width=2.7cm,
      minimum height=1.2cm,xshift=-4.5cm
      ]
      (sysarch) {Architettura\\del sistema};

    \node[
      draw=black,fill=white,rectangle,align=center,at={(box3)},minimum width=2.7cm,
      minimum height=1.2cm,xshift=-1.5cm
      ]
      (dbspec) {Specifica\\del database};

    \node[
      draw=black,fill=white,rectangle,align=center,at={(box3)},minimum width=2.7cm,
      minimum height=1.2cm,xshift=1.5cm
      ]
      (intspec) {Specifica\\dell'interfaccia};

    \node[
      draw=black,fill=white,rectangle,align=center,at={(box3)},minimum width=2.7cm,
      minimum height=1.2cm,xshift=4.5cm
      ]
      (compspec) {Specifica\\dei componenti};

    \draw[->] (box2) -- (box3);
    % Box 3 ------------------------------------------------------------------------------
  \end{tikzpicture}
  \caption{Modello generale del processo di design}
\end{figure}

\noindent
Le principali attività di design sono:
\begin{itemize}
  \item \textbf{Design architetturale} dove si identifica la struttura complessiva del
    sistema, i componenti principali, le loro relazioni e come sono distribuiti

  \item \textbf{Design del database} dove si progettano le strutture dati del sistema e
    come esse vengono rappresentate all'interno del database

  \item \textbf{Design dell'interfaccia} dove si definiscono le interfacce tra i 
    componenti del sistema

  \item \textbf{Design e selezione dei componenti} dove si cercano componenti 
    riutilizzabili. Se non sono disponibili si progettano nuovi componenti
\end{itemize}

\subsubsection{Implementazione}
Il software è implementato sviluppando dei programmi, oppure configurando un'applicazione.
Il design e l'implementazione sono attività interconnesse per la maggior parte dei sistemi
software.

La programmazione è un'attività individuale senza alcun processo standard,
mentre invece il debugging consiste nel trovare e correggere errori nei programmi.

\subsubsection{Validazione}
La verifica e la validazione serve a dimostrare che un sistema è conforme alle specifiche
e che soddisfa i requisiti del cliente. La validazione consiste nel controllare e
verificare i processi e anche nel fare \textbf{testing}.

Il testing consiste nell'esecuzione di un sistema con dei casi di test derivati dalla
specificazione dei dati reali che il software deve processare. Il testing è il l'attività
di validazione più utilizzata.
\begin{figure}[H]
  \centering
  \begin{tikzpicture}
    \node[draw,rectangle,align=center,rounded corners]
      (component) {Testing dei\\componenti};

    \node[draw,rectangle,align=center,rounded corners]
      (system) [right=of component] {Testing del\\sistema};

    \node[draw,rectangle,align=center,rounded corners]
      (acceptance) [right=of system] {Testing\\dell'accettazione};

    \draw[->] (component) -- (system);
    \draw[->] (system) -- (acceptance);

    \draw[->] (component.north) -- ++(0,0.5) -| (acceptance);
    \draw[->] (acceptance.south) -- ++(0,-0.5) -| (component);
  \end{tikzpicture}
  \caption{Fasi del testing}
\end{figure}

\noindent
Le principali fasi del testing sono:
\begin{itemize}
  \item \textbf{Testing dei componenti}: I singoli componenti vengono testati
    individualmente. I componenti possono essere funzioni, oggetti o gruppi coesi di
    tali entità.

  \item \textbf{Testing del sistema}: I componenti vengono integrati e il sistema
    viene testato come un'entità unica. È importare testare eventuali proprietà emergenti

  \item \textbf{Testing dell'accettazione}: Il sistema viene testato con i dati reali
    del cliente per verificare che soddisfi i requisiti del cliente
\end{itemize}

\subsubsection{Evoluzione}
Il software è flessibile e può cambiare col cambiamento dei requisiti. Anche se la linea
tra sviluppo e mantenimento è spesso sfumata, questo diventa irrilevante siccome sempre
meno sistemi software vengono sviluppati da zero.

\begin{figure}[H]
  \centering
  \begin{tikzpicture}
    \node[draw,rectangle,align=center,rounded corners]
      (requirements) {Definizione\\dei requisiti};

    \node[draw,rectangle,align=center,rounded corners]
      (assessment) [right=of requirements] {Valutazione dei\\requisiti già esistenti};

    \node[draw,rectangle,align=center,rounded corners]
      (changes) [right=of assessment] {Proposta di\\modifiche};

    \node[draw,rectangle,align=center,rounded corners]
      (modify) [right=of changes] {Modifica\\del sistema};

    \draw[->] (requirements) -- (assessment);
    \draw[->] (assessment) -- (changes);
    \draw[->] (changes) -- (modify);

    \node[draw,rectangle,align=center,rounded corners]
      (existing) [below=of assessment] {Sistemi\\già esistenti};

    \node[draw,rectangle,align=center,rounded corners]
      (new) [below=of modify] {Nuovi\\sistemi};

    \draw[->] (modify) -- (new);
    \draw[->] (existing) -- (assessment.south);

    \draw[->] (new) -- (assessment.south east);

    \draw[->] (modify.north) -- ++(0,0.5) -| (requirements);
  \end{tikzpicture}
  \caption{Evoluzione di un sistema}
\end{figure}

\subsection{Gestione dei cambiamenti}
Il cambiamento è inevitabile in tutti i grandi progetti software ed esso è dovuto da:
\begin{itemize}
  \item Cambiamenti del mercato
  \item Nuove tecnologie offrono nuove possibilità
  \item Cambiamento delle piattaforme
\end{itemize}
Il cambiamento porta a costi aggiuntivi dovuti alla necessità di rifare il lavoro
precedente più il lavoro aggiuntivo per implementare le nuove funzionalità. Per
ridurre questi costi si può \textbf{anticipare il cambiamento}, cioè includere delle
attività nel processo di sviluppo che permettano di anticipare i possibili cambiamenti
prima che avvenga il rework, ad esempio si possono sviluppare dei prototipi da mostrare
al cliente prima del prodotto finito. Oppure si può aumentare la tolleranza al cambiamento,
quindi sviluppare il software in modo che sia più facile cambiare il software in futuro.

\subsubsection{Prototipi}
Un prototipo è un'implementazione parziale del sistema che viene utilizzata per dimostrare
concetti e provare nuove opzioni di design. Un prototipo può essere utilizzato in:
\begin{itemize}
  \item Processi di specificazione dei requisiti per aiutare a scoprire i requisiti
    del sistema

  \item Processi di design per esplorare alternative di design

  \item Processi di testing per provare parti del sistema
\end{itemize}
I vantaggi della prototipazione sono:
\begin{itemize}
  \item Miglioramento nell'usabilità del sistema
  \item Un prodotto più vicino alle aspettative e alle esigenze del cliente
  \item Miglioramento della qualità del design
  \item Miglioramento della mantenibilità
  \item Riduzione dell'impegno di sviluppo
\end{itemize}
\begin{figure}[H]
  \centering
  \begin{tikzpicture}
    \node[draw,rectangle,align=center,rounded corners,minimum height=1.5cm]
      (objectives) {Definizione\\degli obiettivi\\del prototipo};

    \node[draw,rectangle,align=center,rounded corners,minimum height=1.5cm]
      (function) [right=of objectives] {Definizione delle\\funzionalità\\del prototipo};

    \node[draw,rectangle,align=center,rounded corners,minimum height=1.5cm]
      (develop) [right=of function] {Sviluppo del\\prototipo};

    \node[draw,rectangle,align=center,rounded corners,minimum height=1.5cm]
      (evaluate) [right=of develop] {Valutazione\\del prototipo};

    \draw[->] (objectives) -- (function);
    \draw[->] (function) -- (develop);
    \draw[->] (develop) -- (evaluate);

    \node[draw,rectangle,align=center]
      (plan) [below=of objectives] {Pianificazione\\del prototipo};

    \node[draw,rectangle,align=center]
      (outline) [below=of function] {Definizione\\dell'outline};

    \node[draw,rectangle,align=center]
      (execution) [below=of develop] {Esecuzione\\del prototipo};

    \node[draw,rectangle,align=center]
      (evaluation) [below=of evaluate] {Report della\\valutazione};

    \draw[->] (objectives) -- (plan);
    \draw[->] (function) -- (outline);
    \draw[->] (develop) -- (execution);
    \draw[->] (evaluate) -- (evaluation);
  \end{tikzpicture}
  \caption{Processo di sviluppo del prototipo}
\end{figure}

\noindent
Lo sviluppo di un prototipo si può basare su linguaggi e strumenti fatti apposta 
per la prototipazione. La prototipazzione consiste nel creare una versione parziale
funzionante del sistema e ciò comporta tralasciare alcune funzionalità. Il prototipo
si deve concentrare su:
\begin{itemize}
  \item Aree del prodotto che non sono ben definite o capite
  \item Tralasciare il controllo degli errori per concentrarsi sui requisiti funzionali
\end{itemize}
I prototipi dovrebbero essere scartati siccome non sono una buona base per il sistema
finale.

\subsubsection{Consegna incrementale}
Al posto di consegnare il sistema in un'unica volta già completo, si può separare lo
sviluppo e la consegna in incrementi che implementano parte delle funzionalità richieste
seguendo un ordine di priorità.
Le due fasi si compongono di:
\begin{itemize}
  \item \textbf{Sviluppo incrementale}
    \begin{itemize}
      \item Sviluppare il sistema in incrementi e validare ogni incremento prima di 
        procedere con il successivo
      \item Utilizzare l'approccio utilizzato nei metodi agili per lo sviluppo
      \item La valutazione di ogni incremento è fatta dal cliente/utente
    \end{itemize}

  \item \textbf{Consegna incrementale}
    \begin{itemize}
      \item Consegnare un incremento per permettere al cliente di utilizzarlo
      \item Il cliente può valutare l'incremento e fornire feedback
      \item Il feedback può essere utilizzato per modificare i requisiti per gli incrementi
        successivi
    \end{itemize}
\end{itemize}
I vantaggi della consegna incrementale sono:
\begin{itemize}
  \item Il feedback del cliente può essere ottenuto ad ogni incremento per migliorare
    il sistema
  \item I primi incrementi possono funzionare da prototipo
  \item Rischio più basso di fallimento del progetto
  \item I servizi con priorità più alta tendono ad essere testati di più
\end{itemize}
I problemi della consegna incrementale sono:
\begin{itemize}
  \item Molti sistemi richiedono un insieme di funzionalità comuni utilizzate da parti
    diverse del sistema, ma nella consegna incrementale la definizione dei requisiti
    avviene soltanto quando è necessario sviluppare un nuovo incremento e quindi è
    difficile identificare queste funzionalità comunie in anticipo
  \item La specifica è definita in congruenza con lo sviluppo, ma questo va contro
    il modello di molte organizzazioni
\end{itemize}

\subsection{Miglioramento dei processi}
Il miglioramento dei processi consiste nel capire processi esistenti e trovare modi
per migliorare la qualità, ridurre il costo o accelerare lo sviluppo.

Ci sono due principali approcci per il miglioramento dei processi:
\begin{itemize}
  \item \textbf{Approccio di maturità}: si concentra sul miglioramento dei processi
    e della gestione del progetto e introdurre delle buone pratiche di sviluppo software.
  \item \textbf{Approccio agile}: si concentra sullo sviluppo iterativo e sulla riduzione
    di overhead dei processi
\end{itemize}

\begin{figure}[H]
  \centering
  \begin{tikzpicture}
    \node[draw,rectangle,align=center]
      (measure) {Misurazione};

    \node[draw,rectangle,align=center]
      (analyze) [below right=of measure] {Analisi};

    \node[draw,rectangle,align=center]
      (change) [below left=of measure] {Cambiamento};

    \draw[->] (measure) -| (analyze);
    \draw[->] (analyze) -- (change);
    \draw[->] (change) |- (measure);
  \end{tikzpicture}
  \caption{Ciclo di miglioramento dei processi}
\end{figure}
Le fasi del ciclo di miglioramento dei processi sono:
\begin{itemize}
  \item \textbf{Misurazione dei processi}: si misurano i processi esistenti per capire
    come funzionano e dove ci sono problemi e questo farà da base per il miglioramento
  \item \textbf{Analisi dei processi}: si analizza il processo corrente e tutti gli
    svantaggi vengono identificati e si stila un modello che descrive il processo
    (chiamato process map)
  \item \textbf{Cambiamento dei processi}: si identificano i cambiamenti che possono
    essere fatti per migliorare i problemi individuati. Quando questi cambiamenti vengono
    introdotti, il ciclo ricomincia
\end{itemize}

\subsubsection{Misurazione dei processi}
Quando possibile bisognerebbe raccogliere dati quantitativi sui processi per utilizzarli
a monitorare il miglioramento dei processi. I dati però non devono guidare il processo
di miglioramento. Le metriche più comuni sono:
\begin{itemize}
  \item Il tempo richiesto per completare un'attività
  \item Le risorse richieste per i processi o le attività
  \item Il numero di occorrenze di un particolare evento
\end{itemize}
Il modello di maturità SEI (Software Engineering Institute) è un modello per valutare
la maturità dei processi di sviluppo software:
\begin{figure}[H]
  \centering
  \begin{tikzpicture}
    \node[draw,rectangle,align=center]
      (5) {\textit{Livello 5}\\Ottimizzazione};

    \node[draw,rectangle,align=center]
      (4) [below=of 5] {\textit{Livello 4}\\Quantitativamente\\gestito};

    \node[draw,rectangle,align=center]
      (3) [below=of 4] {\textit{Livello 3}\\Definito};

    \node[draw,rectangle,align=center]
      (2) [below=of 3] {\textit{Livello 2}\\Gestito};

    \node[draw,rectangle,align=center]
      (1) [below=of 2] {\textit{Livello 1}\\Iniziale};

    \draw[<-] (5) -- (4);
    \draw[<-] (4) -- (3);
    \draw[<-] (3) -- (2);
    \draw[<-] (2) -- (1);
  \end{tikzpicture}
  \caption{Livelli di maturità}
\end{figure}
\begin{itemize}
  \item \textbf{Iniziale}: essenzialmente incontrollato
  \item \textbf{Ripetibile}: Procedure di gestione del prodotto definite e utilizzate
  \item \textbf{Definito}: Processi di sviluppo definiti e utilizzati
  \item \textbf{Gestito}: Strategie di gestione di qualità definiti e utilizzati
  \item \textbf{Ottimizzazione}: Strategie di miglioramento dei processi definite e 
    utilizzate
\end{itemize}

\end{document}
