\documentclass[a4paper]{article}
\usepackage{import}
\input{../../../preamble.sty}

\begin{document}

\input{title.tex}

\tableofcontents
\pagebreak

% Info:
% Libri: Sommerdille - Ingegneria del Software
%        Larman - Applicare UML e i Pattern
% Esame: Il risultato finale è la media dei 2 voti tra Ingegneria
%        e programmazione 2.
%        L'esame consiste in un esame orale concentrato su un
%        progetto da discutere, più alcune domande sulla teoria.
%        Il progetto è da scegliere fra 3 proposti dal docente.
%        Il progetto riguarda il progetto e lo sviluppo di un
%        software, bisogna anche implementare un sistema di
%        memorizzazione sulla memoria di massa (fare anche i test). 
%        Il progetto deve essere svolto in gruppi da 2 o 3 persone.
\section{Introduzione}
\subsection{Cos'è l'ingegneria del software?}
L'ingegneria del software è un insieme di metodologie, teorie, metodi e strumenti, che
guidano nello sviluppo di software \textbf{professionale} in modo che esso fornisca
le funzionalità richieste, sia performante e mantenibile, affidabile e usabile. Il
\textbf{software} non è solo il programma e l'eseguibile, ma anche \textbf{la 
documentazione associata}. Le attività principale dell'ingegneria del software sono:
\begin{itemize}
  \item \textbf{Specifica del software}: Il cliente e l'ingegnere del software definiscono
  le funzionalità e i vincoli del software da produrre.
  \item \textbf{Sviluppo}: Il software viene progettato e implementato.
  \item \textbf{Validazione}: Il software viene verificato per
    assicurarsi che soddisfi i requisiti forniti dal cliente.
  \item \textbf{Evoluzione}: Il software viene modificato per adattarlo a nuovi
    requisiti del cliente o del mercato. 
\end{itemize}

\subsubsection{Economia}
Il software spesso costa più dell'hardware, e il costo è più legato alla manutenzione che
allo sviluppo. Quindi l'ingegneria del software è importante per ridurre i costi di
manutenzione.

\subsubsection{Fallimento dei progetti}
I progetti spesso falliscono per la \textbf{crescente complessità del sistema}: nuove 
tecniche di sviluppo e nuove tecnologie rendono i sistemi sempre più complessi, e quindi 
più difficili da mantenere.

\subsection{Prodotti software}
\subsubsection{Prodotti generici}
Sono prodotti che vengono pubblicizzati e venduti a qualsiasi cliente che ne faccia 
richiesta. La specifica è di proprietà del produttore e le decisioni sulle modifiche
sono prese dai produttori.

\subsubsection{Prodotti personalizzati}
Sono prodotti che vengono commissionati da clienti specifici per soddisfare le loro
necessità. La specifica è di proprietà del cliente dopo una contrattazione con il
produttore e le decisioni sulle modifiche sono prese dal cliente.

\subsection{Caratteristiche di un buon software}
\begin{itemize}
  \item \textbf{Mantenibilità}: la facilità con cui il software può essere modificato
  per correggere difetti, migliorare le prestazioni o adattarlo a cambiamenti.

  \item \textbf{Affidabilità e sicurezza}: la capacità del software di svolgere le sue
  funzioni in modo corretto. I malfunzionamenti non devono causare danni fisici o economici.
  Utenti malintenzionati non devono poter violare la sicurezza del sistema.
  
  \item \textbf{Efficienza}: il software non deve sprecare risorse (CPU, memoria, ecc).

  \item \textbf{Accettabilità}: il software deve essere accettato dagli utenti per i quali
  è stato progettato.
\end{itemize}

\subsection{Problemi che influenzano il software}
\begin{itemize}
  \item \textbf{Eterogeneità}:
    I sistemi devono sempre di più operare in modo distribuito, e quindi devono essere in grado
    di comunicare con sistemi diversi. Oppure bisogna garantire che il software funzioni su
    piattaforme diverse.

  \item 
    \textbf{Cambiamento sociale o del business}:
    Il software deve essere in grado di adattarsi a cambiamenti sociali o organizzativi
    nelle aziende.

  \item 
    \textbf{Sicurezza e fiducia}:
    Siccome il software fa parte della vita di tutti i giorni è essenziale che ci sia
    fiducia nel software.

  \item 
    \textbf{Scalabilità}:
    Il software deve essere sviluppato a più scale, cioè soluzione che funziona in piccolo
    deve adattarsi anche a grandi scale senza rischiare di fallire.
\end{itemize}

\subsection{Tipi di applicazione}
Ci sono diversi tipi di sistemi software e non c'è un insieme universale di tecniche
applicabili a tutti i sistemi. Quindi i metodi e gli strumenti utilizzati dipendono
dal tipo di applicazione che si deve sviluppare, dalle richieste dei clienti
e dalle competenze degli sviluppatori. I principali tipi di applicazione sono:
\begin{itemize}
  \item 
    \textbf{Applicazioni stand-alone}:
    Sono applicazioni che si eseguono su un singolo computer locale e includono le
    funzionalità necessarie per l'utente.

  \item 
    \textbf{Applicazioni interattive transaction-based}:
    Sono applicazioni che sono eseguite su un computer in remoto e sono accessibili
    dagli utenti dai propri computer. Queste includono le applicazioni web come
    gli e-commerce.

  \item 
    \textbf{Sistemi embedded}:
    Sono applicazioni che controllano e gestiscono dispositivi hardware. Questi sistemi
    sono i più numerosi.

  \item 
    \textbf{Sistemi batch}:
    Questi sistemi elaborano grandi quantità di dati per produrre un output.

  \item 
    \textbf{Sistemi di intrattenimento}:
    Questi sistemi sono per uso personale e servono ad intrattenere l'utente.

  \item 
    \textbf{Sistemi di modellazione e simulazione}:
    Questi sistemi sono sviluppati da scienziati per modallare processi fisici o situazioni
    che includono tanti oggetti separati che interagiscono tra di loro.

  \item 
    \textbf{Sistemi di collezione di dati (o IOT)}:
    Questi sitemi raccolgono dati da sensori e li inviano ad un sistema centrale per
    l'elaborazione.

  \item 
    \textbf{Sistemi di sistemi}:
    Questi sistemi sono composti da più sistemi software che collaborano tra di loro.
\end{itemize}



\subsection{Principi fondamentali}
\begin{itemize}
  \item I sistemi devono essere sviluppati utilizzando un processo strutturato e ben
    pensato.
  \item L'affidabilità e la performance sono importanti per ogni tipo di software.
  \item Capire e gestire i requisiti del software è essenziale.
  \item Dove appropriato si dovrebbe riutilizzare software che è già stato sviluppato
    al posto di svilupparne uno da zero.
\end{itemize}

\section{Processi del software}
I \textbf{processi} del software sono un insieme di attività strutturate che sono necessarie
per sviluppare un sistema software. Ci sono diversi tipi di processi, ma tutti coinvolgono
le seguenti attività:
\begin{itemize}
  \item \textbf{Specificazione}
  \item \textbf{Sviluppo}
  \item \textbf{Design e implementazione}
  \item \textbf{Validazione}
  \item \textbf{Evoluzione}
\end{itemize}
Un modello di processo software è una rappresentazione astratta di un processo da un punto
di vista particolare.

Per descrivere e discutere i processi di solito si parla delle attività all'interno di
questi processi e dell'ordine in cui queste attività vengono svolte. Alcune descrizioni
possono anche includere:
\begin{itemize}
  \item \textbf{Prodotti}: cioè i risultati di un'attività.
  \item \textbf{Ruoli}: cioè le responsabilità di un individuo o di un gruppo.
  \item \textbf{Pre e post condizioni}: cioè le condizioni che devono essere soddisfatte
    prima e dopo un'attività.
\end{itemize}
Alcuni esempi di processi sono:
\begin{itemize}
  \item \textbf{Processi plan-driven}: sono processi dove tutte le attività sono pianificate
    in anticipo e tutti i progressi sono misurati rispetto al piano.
  \item \textbf{Processi agili}: sono processi in cui la pianificazione è incrementale ed
    è più facile adattarsi ai cambiamenti.
\end{itemize}
Nel pratico si utilizza un approccio ibrido tra i due.

\subsection{Modelli di processo}
\begin{itemize}
  \item \textbf{Modello a cascata}: è un modello plan-driven con fasi di specificazione e
    di sviluppo distinte e separate
  \item \textbf{Modello incrementale}: la specifica, lo sviluppo e la validazione sono
    intercalate. Può essere plan-driven o agile.
  \item \textbf{Integrazione e configurazione}: i sistemi sono sviluppati da componenti
    già esistenti e configurabili.
\end{itemize}
Nel pratico, sistemi molto grandi sono sviluppati utilizzando un processo che incorpora
elementi di tutti e tre i modelli.

\subsubsection{Modello a cascata}
\begin{figure}[H]
  \centering
  \begin{tikzpicture}[
    node distance=0.4cm and 0cm,
    every node/.style={draw,rectangle,align=center,scale=0.8,rounded corners=1mm},
    ]
    \node (1) {Definizione dei\\requisiti};
    \node[below right=of 1]
      (2) {Design del sistema\\e del software};
    \node[below right=of 2]
      (3) {Implementazione e\\unit testing};
    \node[below right=of 3]
      (4) {Integrazione e\\testing del sistema};
    \node[below right=of 4]
      (5) {Operazione e\\manutenzione};

    \draw[->] (1) -| (2);
    \draw[->] (2) -| (3);
    \draw[->] (3) -| (4);
    \draw[->] (4) -| (5);

    \draw (5) -- (1.south |- 52,52 |- 5.west);
    \draw[<-] (4.south) -- (4.south |- 52,52 |- 5.west);
    \draw[<-] (3.south) -- (3.south |- 52,52 |- 5.west);
    \draw[<-] (2.south) -- (2.south |- 52,52 |- 5.west);
    \draw[<-] (1.south) -- (1.south |- 52,52 |- 5.west);
  \end{tikzpicture}
  \caption{Modello a cascata}
\end{figure}

\noindent
Le diverse fasi del modello a cascata sono:
\begin{itemize}
  \item Analisi e definizione dei requisiti
  \item Design del sistema e del software
  \item Implementazione e unit testing
  \item Integrazione e testing del sistema
  \item Operazione e manutenzione
\end{itemize}

\noindent
Il vantaggio del modello a cascata è la partizione inflessibile del progetto in fasi 
distinte rende difficile rispondere ai cambiamenti dei requisiti, quindi questo modello 
è adatto solo per progetti dove i requisiti sono ben definiti e i cambiamenti rimangono 
limitati. Però pochi progetti soddisfano queste condizioni.

\vspace{1em}
\noindent
Questo modello è più utilizzato in sistemi molto grandi e sviluppati da molte persone.
In quelle circostanze la natura plan-driven di questo modello è utile per coordinare
il lavoro.

\subsubsection{Modello incrementale}
\begin{figure}[H]
  \centering
  \begin{tikzpicture}
    \node[draw,rectangle,align=center]
      (outline) {Descrizione\\dell'outline};

    \node[fill,fill opacity=0.2,rectangle,align=center,minimum width=3cm,
      minimum height=4.5cm]
      (box1) [right=of outline] {};
    \node[above,at={(box1.north)},align=center] {Attività\\concorrenti};

    \draw[->] (outline) -- (box1);

    \node[
      draw=black,fill=white,rectangle,align=center,at={(box1.north)},yshift=-0.8cm,
      minimum width=2.3cm,minimum height=0.8cm,rounded corners
      ]
      (specification) {Specificazione};

    \node[
      draw=black,fill=white,rectangle,align=center,at={(box1)},minimum width=2.3cm,
      minimum height=0.8cm,rounded corners
      ]
      (development) {Sviluppo};

    \node[
      draw=black,fill=white,rectangle,align=center,at={(box1.south)},yshift=0.8cm,
      minimum width=2.3cm, minimum height=0.8cm,rounded corners
      ]
      (validation) {Validazione};

    \draw[<->] (specification) -- (development);
    \draw[<->] (development) -- (validation);

    \node[fill,fill opacity=0.2,rectangle,align=center,minimum width=3cm,
      minimum height=4.5cm]
      (box2) [right=of box1] {};

    \node[
      draw=black,fill=white,rectangle,align=center,at={(box2.north)},yshift=-0.8cm,
      minimum width=2.3cm,minimum height=0.8cm
      ]
      (init) {Versione\\iniziale};

    \node[
      draw=black,fill=white,rectangle,align=center,at={(box2)},minimum width=2.3cm,
      minimum height=0.8cm,shift={(0.1cm,-0.2cm)}
      ]
      (offset1) {};
    \node[
      draw=black,fill=white,rectangle,align=center,at={(offset1)},minimum width=2.3cm,
      minimum height=0.8cm,shift={(-0.1cm,0.1cm)}
      ]
      (offset2) {};
    \node[
      draw=black,fill=white,rectangle,align=center,at={(offset2)},minimum width=2.3cm,
      minimum height=0.8cm,shift={(-0.1cm,0.15cm)}
      ]
      (intermediate) {Versioni\\intermedie};

    \node[
      draw=black,fill=white,rectangle,align=center,at={(box2.south)},yshift=0.8cm,
      minimum width=2.3cm, minimum height=0.8cm
      ]
      (final) {Versione\\finale};

    \draw[<->] (specification) -- (init);
    \draw[<->] (development) -- (intermediate);
    \draw[->] (validation) -- (final);
  \end{tikzpicture}
  \caption{Modello incrementale}
\end{figure}
\noindent
I vantaggi del modello incrementale sono:
\begin{itemize}
  \item Il costo del cambiamento dei requisiti è ridotto e la quantità di analisi e
    documentazione da rifare è molto meno rispetto al modello a cascata.

  \item È più facile ottenere un feedback dagli utenti sul lavoro svolto.

  \item È possibile consegnare software utile più velocemente al cliente.
\end{itemize}
Gli svantaggi del modello incrementale sono:
\begin{itemize}
  \item Il processo non è visibile, cioè è difficile valutare il progresso. I manager
    hanno bisogno di costanti "deliverables", cioè risultati intermedi, per misurare
    il progresso e non sempre è poco costoso produrre documenti che riflettono lo stato
    di ogni versione del software.

  \item La struttura del sistema tende a decadere con l'aggiunta di nuovi incrementi.
    A meno che il tempo e i soldi non vengano spesi per il refactor e il miglioramento
    del software, i cambiamenti regolari tenderanno a corrompere la struttura del sistema
    e quindi incorporare nuovi cambiamenti diventerà sempre più difficile e costoso.
\end{itemize}

\subsubsection{Modello a integrazione e configurazione}
Questo modello si basa sulla realizzazione di sistemi integrati tramite componenti
software già esistenti e configurabili. Il riutilizzo è l'approccio standard per
creare molti tipi di sistemi.

I tipi di software riutilizzabile sono:
\begin{itemize}
  \item Applicazioni o sistemi stand-alone (a volte chiamati COTS, Commercial Off-The-Shelf)
    che sono configurati per essere utilizzati in un certo ambiente
    
  \item Collezioni di oggetti o librerie che sono sviluppati come pacchetti per 
    l'integrazione con vari framework

  \item Servizi web sviluppati secondo standard che permettono l'interazione tramite
    internet
\end{itemize}
Le attività principali di questo modello sono:
\begin{itemize}
  \item Specificazione dei requisiti
  \item Ricerca e analisi del software riutilizzabile
  \item Adattamento dei requisiti
  \item Configurazione del sistema
  \item Adattamento e integrazione dei componenti
\end{itemize}
I vantaggi di questo modello sono:
\begin{itemize}
  \item Riduzione dei costi e del rischio siccome meno software è sviluppato da zero
    
  \item Deployment più veloce
\end{itemize}
Gli svantaggi sono:
\begin{itemize}
  \item È inevitabile fare compromessi per i requisiti, quindi i sistemi potrebbero non
    essere più ciò che aveva richiesto il cliente

  \item Perdita di controllo sull'evoluzione dei componenti riutilizzati
\end{itemize}

\subsection{Attività dei processi}
I processi software reali sono sequenze interconnesse di attività tecniche, collaborative
e manageriali con l'obiettivo di specificare, progettare, implementare e testare un
sistema software. Questi quattro processi base sono organizzati in modo differente
in processi di sviluppo diversi.

\subsubsection{Specificazione}
Il processo di stabilire che processi sono richiesti e quali sono i vincoli sull'operazione
e lo sviluppo del sistema è chiamato \textbf{specificazione del software} e consiste in:
\begin{itemize}
  \item \textbf{Ricavo e analisi dei requisiti}: cosa vogliono o cosa si aspettano
    gli utenti interessati dal sistema

  \item \textbf{Specifica dei requisiti}: definizione formale dei requisiti del sistemao

  \item \textbf{Validazione dei requisiti}: verifica che i requisiti siano completi e
    consistenti
\end{itemize}

\subsubsection{Design}
Questo processo consiste nella conversione delle specifiche del sistema in un sistema
eseguibile e consiste in:
\begin{itemize}
  \item \textbf{Design del software}: progettazione di una struttura software che
    realizzi i requisiti del sistema

  \item \textbf{Implementazione}: traduzione del design in un programma eseguibile
\end{itemize}
Queste attività sono interconnesse e spesso si intrecciano.
\begin{figure}[H]
  \centering
  \begin{tikzpicture}

    % Box 1 ------------------------------------------------------------------------------
    \node[fill,fill opacity=0.2,rectangle,align=center,minimum width=9.5cm,
      minimum height=2cm]
      (box1) {};

    \node[above right,at={(box1.north west)},align=center] {Design inputs};

    \node[
      draw=black,fill=white,rectangle,align=center,at={(box1)},minimum width=2.7cm,
      minimum height=1.2cm,xshift=-3cm
      ]
      (info) {Informazioni\\della piattaforma};

    \node[
      draw=black,fill=white,rectangle,align=center,at={(box1)},minimum width=2.7cm,
      minimum height=1.2cm
      ]
      (requirements) {Specifica\\dei requisiti};

    \node[
      draw=black,fill=white,rectangle,align=center,at={(box1)},minimum width=2.7cm,
      minimum height=1.2cm,xshift=3cm
      ]
      (data) {Descrizione\\dei dati};
    % Box 1 ------------------------------------------------------------------------------

    % Box 2 ------------------------------------------------------------------------------
    \node[fill,fill opacity=0.2,rectangle,align=center,minimum width=9.5cm,
      minimum height=3.8cm]
      (box2) [below=of box1] {};

    \node[above right,at={(box2.north west)},align=center] {Attività di design};

    \node[
      draw=black,fill=white,rectangle,align=center,at={(box2.north)},minimum width=2.7cm,
      minimum height=1.2cm,shift={(-3cm,-1cm)},rounded corners=6mm
      ]
      (archi) {Design\\architetturale};

    \node[
      draw=black,fill=white,rectangle,align=center,at={(box2.north)},minimum width=2.7cm,
      minimum height=1.2cm,shift={(0cm,-1cm)},rounded corners=6mm
      ]
      (interface) {Design\\dell'interfaccia};

    \node[
      draw=black,fill=white,rectangle,align=center,at={(box2.north)},minimum width=2.7cm,
      minimum height=1.2cm,shift={(3cm,-1cm)},rounded corners=6mm
      ]
      (component) {Design\\dei componenti};

    \node[
      draw=black,fill=white,rectangle,align=center,at={(box2.north)},minimum width=2.7cm,
      minimum height=1.2cm,shift={(0cm,-2.8cm)},rounded corners=6mm
      ]
      (database) {Design del database};

    \draw[->] (archi) -- (interface);
    \draw[->] (interface) -- (component);

    \draw[->] (archi) -- (database);
    \draw[->] (component) -- (database);

    \draw[->] (box1) -- (box2);
    % Box 2 ------------------------------------------------------------------------------

    % Box 3 ------------------------------------------------------------------------------
    \node[fill,fill opacity=0.2,rectangle,align=center,minimum width=12.1cm,
      minimum height=2cm]
      (box3) [below=of box2] {};

    \node[above right,at={(box3.north west)},align=center] {Design outputs};

    \node[
      draw=black,fill=white,rectangle,align=center,at={(box3)},minimum width=2.7cm,
      minimum height=1.2cm,xshift=-4.5cm
      ]
      (sysarch) {Architettura\\del sistema};

    \node[
      draw=black,fill=white,rectangle,align=center,at={(box3)},minimum width=2.7cm,
      minimum height=1.2cm,xshift=-1.5cm
      ]
      (dbspec) {Specifica\\del database};

    \node[
      draw=black,fill=white,rectangle,align=center,at={(box3)},minimum width=2.7cm,
      minimum height=1.2cm,xshift=1.5cm
      ]
      (intspec) {Specifica\\dell'interfaccia};

    \node[
      draw=black,fill=white,rectangle,align=center,at={(box3)},minimum width=2.7cm,
      minimum height=1.2cm,xshift=4.5cm
      ]
      (compspec) {Specifica\\dei componenti};

    \draw[->] (box2) -- (box3);
    % Box 3 ------------------------------------------------------------------------------
  \end{tikzpicture}
  \caption{Modello generale del processo di design}
\end{figure}

\noindent
Le principali attività di design sono:
\begin{itemize}
  \item \textbf{Design architetturale} dove si identifica la struttura complessiva del
    sistema, i componenti principali, le loro relazioni e come sono distribuiti

  \item \textbf{Design del database} dove si progettano le strutture dati del sistema e
    come esse vengono rappresentate all'interno del database

  \item \textbf{Design dell'interfaccia} dove si definiscono le interfacce tra i 
    componenti del sistema

  \item \textbf{Design e selezione dei componenti} dove si cercano componenti 
    riutilizzabili. Se non sono disponibili si progettano nuovi componenti
\end{itemize}

\subsubsection{Implementazione}
Il software è implementato sviluppando dei programmi, oppure configurando un'applicazione.
Il design e l'implementazione sono attività interconnesse per la maggior parte dei sistemi
software.

La programmazione è un'attività individuale senza alcun processo standard,
mentre invece il debugging consiste nel trovare e correggere errori nei programmi.

\subsubsection{Validazione}
La verifica e la validazione serve a dimostrare che un sistema è conforme alle specifiche
e che soddisfa i requisiti del cliente. La validazione consiste nel controllare e
verificare i processi e anche nel fare \textbf{testing}.

Il testing consiste nell'esecuzione di un sistema con dei casi di test derivati dalla
specificazione dei dati reali che il software deve processare. Il testing è il l'attività
di validazione più utilizzata.
\begin{figure}[H]
  \centering
  \begin{tikzpicture}
    \node[draw,rectangle,align=center,rounded corners]
      (component) {Testing dei\\componenti};

    \node[draw,rectangle,align=center,rounded corners]
      (system) [right=of component] {Testing del\\sistema};

    \node[draw,rectangle,align=center,rounded corners]
      (acceptance) [right=of system] {Testing\\dell'accettazione};

    \draw[->] (component) -- (system);
    \draw[->] (system) -- (acceptance);

    \draw[->] (component.north) -- ++(0,0.5) -| (acceptance);
    \draw[->] (acceptance.south) -- ++(0,-0.5) -| (component);
  \end{tikzpicture}
  \caption{Fasi del testing}
\end{figure}

\noindent
Le principali fasi del testing sono:
\begin{itemize}
  \item \textbf{Testing dei componenti}: I singoli componenti vengono testati
    individualmente. I componenti possono essere funzioni, oggetti o gruppi coesi di
    tali entità.

  \item \textbf{Testing del sistema}: I componenti vengono integrati e il sistema
    viene testato come un'entità unica. È importare testare eventuali proprietà emergenti

  \item \textbf{Testing dell'accettazione}: Il sistema viene testato con i dati reali
    del cliente per verificare che soddisfi i requisiti del cliente
\end{itemize}

\subsubsection{Evoluzione}
Il software è flessibile e può cambiare col cambiamento dei requisiti. Anche se la linea
tra sviluppo e mantenimento è spesso sfumata, questo diventa irrilevante siccome sempre
meno sistemi software vengono sviluppati da zero.

\begin{figure}[H]
  \centering
  \begin{tikzpicture}
    \node[draw,rectangle,align=center,rounded corners]
      (requirements) {Definizione\\dei requisiti};

    \node[draw,rectangle,align=center,rounded corners]
      (assessment) [right=of requirements] {Valutazione dei\\requisiti già esistenti};

    \node[draw,rectangle,align=center,rounded corners]
      (changes) [right=of assessment] {Proposta di\\modifiche};

    \node[draw,rectangle,align=center,rounded corners]
      (modify) [right=of changes] {Modifica\\del sistema};

    \draw[->] (requirements) -- (assessment);
    \draw[->] (assessment) -- (changes);
    \draw[->] (changes) -- (modify);
  \end{tikzpicture}
\end{figure}

\end{document}
