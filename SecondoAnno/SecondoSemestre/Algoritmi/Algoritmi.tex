\documentclass[a4paper]{article}
\usepackage{import}
\input{../../../preamble.sty}

\begin{document}

\input{title.tex}

\tableofcontents
\pagebreak

\section{Grafi}
I grafi permettono di risolvere problemi particolarmente complessi, ma la parte difficile
è la conversione di un problema in un grafo. I grafi sono costituiti da nodi e archi:
\begin{figure}[H]
  \centering
  \begin{tikzpicture}
    \node[draw,circle] (1) at (0,0) {1};
    \node[draw,circle] (3) [below left=of 1] {3};
    \node[draw,circle] (4) [below right=of 1] {4};
    \node[draw,circle] (2) [right=of 1] {2};

    \draw (1) -- (3);
    \draw (1) -- (4);
    \draw (1) -- (2);
    \draw (4) -- (2);
  \end{tikzpicture}
  \caption{Esempio di grafo}
  \label{fig:grafo1}
\end{figure}
\begin{itemize}
  \item \textbf{Nodi}: rappresentano gli elementi del problema.
  \item \textbf{Archi}: rappresentano le relazioni tra i nodi.
\end{itemize}
I grafi in cui gli archi hanno un valore (o peso) vengono chiamati \textbf{grafi pesati}.
Si possono anche aggiungere delle direzioni agli archi, ottenendo così un 
\textbf{grafo orientato}, in cui un arco si può attraversare in un solo verso.
\begin{definition}[Cammino]
  Un \textbf{cammino} è una sequenza di nodi per cui esiste un arco tra ogni coppia di nodi adiacenti.
\end{definition}
In un cammino, la ripetizione di un nodo rappresenta un \textbf{loop} e questo cammino
viene detto \textbf{cammino ciclico}. (un cammino senza cicli si dice \textbf{cammino
semplice})

Il \textbf{grado} di un nodo è il numero di archi che incidono sul nodo. Ha senso parlare
di grado di un nodo solo quando il grafo non è orientato perchè così ogni arco viene
contato una sola volta.
\begin{itemize}
  \item \textbf{Grado entrante}: numero di archi entranti in un nodo.
  \item \textbf{Grado uscente}: numero di archi uscenti da un nodo.
\end{itemize}

\vspace{1em}
\noindent
La definizione formale di un grafo è la seguente:
\begin{definition}
  Un grafo è definito come una coppia $G = (V, E)$ dove:
  \begin{itemize}
    \item $V$ è un insieme di nodi.
    \item $E$ è un insieme di archi:
      \[
        E \subseteq V \times V
      \] 
  \end{itemize}
\end{definition}
Dallla figura \ref{fig:grafo1} si ha che:
\begin{itemize}
  \item $V = \{1, 2, 3, 4\}$.
  \item $E = \left\{(1, 3), (3,1), (1,1), (1,4), (4,1), (1,2), (2,4), (4,2)\right\}$.
\end{itemize}
La definizione formale dei concetti precedenti è:
\begin{definition}
  Il \textbf{grado uscente} di un nodo $v$ in un grafo orientato $G = (V, E)$ è il numero
  di archi uscenti da $v$ (\( |\ldots| \) è la cardinalità di un insieme):
  \[
    \text{grado\_uscente}(v) = \left|\{u \;|\; (v, u) \in E\}\right|
  \]
\end{definition}
\begin{definition}
  Il \textbf{grado entrante} di un nodo $v$ in un grafo orientato $G = (V, E)$ è il numero
  di archi entranti in $v$:
  \[
    \text{grado\_entrante}(v) = \left|\{u \;|\; (u, v) \in E\}\right|
  \]
\end{definition}
\begin{definition}
  Un cammino è una sequenza di nodi in cui per ogni coppia di nodi consecutivi esiste un arco:
  \[
    \forall i \in \{0 \ldots n-1\} \quad (v_i, v_{i+1}) \in E
  \] 
\end{definition}

\subsection{Rappresentazione di un grafo}
Per rappresentare un grafo ci sono due modi:
\begin{itemize}
  \item \textbf{Rappresentazione per liste di adiacenza}:
    Si crea una lista in cui si rappresentano i nodi e
    ad ogni nodo si associa la lista di tutti i nodi raggiungibili tramite un arco.
    Prendiamo in considerazione la figura \ref{fig:grafo1}:
    \begin{figure}[H]
      \centering
      \begin{tikzpicture}[
        node distance=0cm and 0.5cm
        ]
        \node[draw,rectangle,minimum width=1cm,minimum height=0.5cm] (1) at (0,0) {1};
        \node[draw,rectangle,minimum width=1cm,minimum height=0.5cm] (2) [below=of 1] {2};
        \node[draw,rectangle,minimum width=1cm,minimum height=0.5cm] (3) [below=of 2] {3};
        \node[draw,rectangle,minimum width=1cm,minimum height=0.5cm] (4) [below=of 3] {4};

        \node[draw,rectangle,minimum size=0.5cm] (1-1-1) [right=of 1] {3};
        \node[draw,rectangle,minimum size=0.5cm] (1-1-2) [right=0cm of 1-1-1] {p};
        \node[draw,rectangle,minimum size=0.5cm] (1-1-3) [right=0cm of 1-1-2] {};
        \draw[->] (1) -- (1-1-1);
        \node[draw,rectangle,minimum size=0.5cm] (1-2-1) [right=of 1-1-3] {1};
        \node[draw,rectangle,minimum size=0.5cm] (1-2-2) [right=0cm of 1-2-1] {p};
        \node[draw,rectangle,minimum size=0.5cm] (1-2-3) [right=0cm of 1-2-2] {};
        \draw[->] (1-1-3.center) -- (1-2-1);
        \node[draw,rectangle,minimum size=0.5cm] (1-3-1) [right=of 1-2-3] {4};
        \node[draw,rectangle,minimum size=0.5cm] (1-3-2) [right=0cm of 1-3-1] {p};
        \node[draw,rectangle,minimum size=0.5cm] (1-3-3) [right=0cm of 1-3-2] {};
        \draw[->] (1-2-3.center) -- (1-3-1);
        \node[draw,rectangle,minimum size=0.5cm] (1-4-1) [right=of 1-3-3] {2};
        \node[draw,rectangle,minimum size=0.5cm] (1-4-2) [right=0cm of 1-4-1] {p};
        \node[draw,rectangle,minimum size=0.5cm] (1-4-3) [right=0cm of 1-4-2] {\footnotesize/};
        \draw[->] (1-3-3.center) -- (1-4-1);


        \node[draw,rectangle,minimum size=0.5cm] (2-1-1) [right=of 2] {4};
        \node[draw,rectangle,minimum size=0.5cm] (2-1-2) [right=0cm of 2-1-1] {p};
        \node[draw,rectangle,minimum size=0.5cm] (2-1-3) [right=0cm of 2-1-2] {\footnotesize/};
        \draw[->] (2) -- (2-1-1);


        \node[draw,rectangle,minimum size=0.5cm] (3-1-1) [right=of 3] {1};
        \node[draw,rectangle,minimum size=0.5cm] (3-1-2) [right=0cm of 3-1-1] {p};
        \node[draw,rectangle,minimum size=0.5cm] (3-1-3) [right=0cm of 3-1-2] {\footnotesize/};
        \draw[->] (3) -- (3-1-1);


        \node[draw,rectangle,minimum size=0.5cm] (4-1-1) [right=of 4] {1};
        \node[draw,rectangle,minimum size=0.5cm] (4-1-2) [right=0cm of 4-1-1] {p};
        \node[draw,rectangle,minimum size=0.5cm] (4-1-3) [right=0cm of 4-1-2] {};
        \draw[->] (4) -- (4-1-1);
        \node[draw,rectangle,minimum size=0.5cm] (4-2-1) [right=of 4-1-3] {2};
        \node[draw,rectangle,minimum size=0.5cm] (4-2-2) [right=0cm of 4-2-1] {p};
        \node[draw,rectangle,minimum size=0.5cm] (4-2-3) [right=0cm of 4-2-2] {\footnotesize/};
        \draw[->] (4-1-3.center) -- (4-2-1);
      \end{tikzpicture}
      \caption{Rappresentazione per liste di adiacenza}
    \end{figure}
    \noindent
    Lo spazio in memoria occupato è \(\Theta(|V| + |E|)\).

  \item \textbf{Rappresentazione per matrice di adiacenza}:
    Si crea una matrice \(A\) di dimensione \(|V| \times |V|\) in cui \(A_{ij} = 1\) se esiste
    un arco tra i nodi \(i\) e \(j\), altrimenti \(A_{ij} = 0\).
    Prendiamo in considerazione la figura \ref{fig:grafo1}, dove \( p \) è il peso dell'arco:
    \begin{table}[H]
      \centering
      \begin{tabular}{c|cccc}
        / & 1 & 2 & 3 & 4 \\
        \hline
        1 & 1 & 1 & 1 & 1 \\
        2 & 0 & 0 & 0 & 1 \\
        3 & 1 & 0 & 0 & 0 \\
        4 & 1 & 1 & 0 & 0 \\
      \end{tabular}
      \caption{Rappresentazione per matrice di adiacenza}
    \end{table}
    \noindent
    Lo spazio in memoria occupato è \(\Theta(|V|^2)\).
\end{itemize}

\noindent
\begin{itemize}
  \item Un \textbf{grafo trasposto} è un grafo in cui tutti gli archi sono invertiti.

  \item
    La \textbf{chiusura transitiva di un grafo} è un grafo in cui se esiste un cammino tra due nodi
    allora esiste un arco diretto tra i due nodi:
    \begin{figure}[H]
      \centering
      \begin{tikzpicture}
        \node[draw,circle] (a) at (0,0) {a};
        \node[draw,circle] (b) [right=of a] {b};
        \node[draw,circle] (c) [right=of b] {c};

        \draw[->] (a) -- (b);
        \draw[->] (b) -- (c);
        \draw[->] (a) to [bend left=45] (c);
      \end{tikzpicture}
      \caption{Grafo con chiusura transitiva}
    \end{figure}

  \item Il \textbf{diametro} è il percorso più lungo fra i percorsi minimi
\end{itemize}

\subsection{Esplorazione di un grafo}
\subsubsection{Visita in ampiezza (BFS: Breath First Search)}
La visita in ampiezza (o a ventaglio) è un algoritmo che permette di visitare tutti i nodi
di un grafo partendo da un nodo iniziale. L'algoritmo è il seguente:
\begin{lstlisting}[language=Scala]
// G e' un grafo composto da un insieme di nodi V e un insieme di archi E
// s e' un nodo dell'arco
bfs(G, s)
  for u in G.V
    u.color <- white // non esplorato
    u.distance <- +inf // distanza dal nodo s
    u.parent <- NIL // nodo da cui si arriva a u

  s.color <- gray // scoperto, ma non esplorato
  s.distance <- 0
  s.parent <- NIL
  Q <- {s} // coda FIFO che contiene i nodi scoperti non esplorati

  while Q != empty
    u <- q.head

    for v in G.adj(u) // lista di nodi adiacenti a u
      if v.color == white
        v.color <- gray
        v.distance <- u.distance + 1
        v.parent <- u
        Q.enqueue(v)

  Q.dequeue()
  u.color <- black // esplorato
\end{lstlisting}
La complessità di questo algoritmo è \(O(|V| + |E|)\).
\begin{example}
  L'algoritmo passo per passo è il seguente, dove i colori rappresentano:
  \begin{itemize}
    \item Nero: non esplorato,
    \item \textcolor{blue}{Blu}: scoperto, ma non esplorato,
    \item \textcolor{red}{Rosso}: esplorato,
  \end{itemize}
  \begin{enumerate}
    \item Primo passo:
      \begin{table}[H]
        \centering
        \begin{tabular}{c|c}
          Distanza & 0 \\
          Coda & s 
        \end{tabular}
      \end{table}
      \begin{figure}[H]
        \centering
        \begin{tikzpicture}[
          every node/.style={minimum size=0.7cm},
          ]
          \node[draw,circle] (r) {} node[above] at (r.north) {r};
          \node[draw,circle,blue] (s) [right=of r] {0} node[above] at (s.north) {s};
          \node[draw,circle] (t) [right=of s] {} node[above] at (t.north) {t};
          \node[draw,circle] (u) [right=of t] {} node[above] at (u.north) {u};

          \node[draw,circle] (v) [below=of r] {} node[below] at (v.south) {v};
          \node[draw,circle] (w) [below=of s] {} node[below] at (w.south) {w};
          \node[draw,circle] (x) [below=of t] {} node[below] at (x.south) {x};
          \node[draw,circle] (y) [below=of u] {} node[below] at (y.south) {y};

          \draw (r) -- (s);
          \draw (r) -- (v);
          \draw (s) -- (w);
          \draw (t) -- (w);
          \draw (t) -- (x);
          \draw (t) -- (u);
          \draw (w) -- (x);
          \draw (u) -- (y);
          \draw (x) -- (y);
        \end{tikzpicture}
      \end{figure}

    \item Secondo passo:
      \begin{table}[H]
        \centering
        \begin{tabular}{c|ccc}
          Distanza & 0 & 1 & 1\\
          Coda & s & w & r
        \end{tabular}
      \end{table}
      \begin{figure}[H]
        \centering
        \begin{tikzpicture}[
          every node/.style={minimum size=0.7cm},
          ]
          \node[draw,circle,blue] (r) {1} node[above] at (r.north) {r};
          \node[draw,circle,red] (s) [right=of r] {0} node[above] at (s.north) {s};
          \node[draw,circle] (t) [right=of s] {} node[above] at (t.north) {t};
          \node[draw,circle] (u) [right=of t] {} node[above] at (u.north) {u};

          \node[draw,circle] (v) [below=of r] {} node[below] at (v.south) {v};
          \node[draw,circle,blue] (w) [below=of s] {1} node[below] at (w.south) {w};
          \node[draw,circle] (x) [below=of t] {} node[below] at (x.south) {x};
          \node[draw,circle] (y) [below=of u] {} node[below] at (y.south) {y};

          \draw[->,thick] (r) -- (s);
          \draw (r) -- (v);
          \draw[<-,thick] (s) -- (w);
          \draw (t) -- (w);
          \draw (t) -- (x);
          \draw (t) -- (u);
          \draw (w) -- (x);
          \draw (u) -- (y);
          \draw (x) -- (y);
        \end{tikzpicture}
      \end{figure}

    \item Terzo passo:
      \begin{table}[H]
        \centering
        \begin{tabular}{c|cccccc}
          Distanza & 0 & 1 & 1 & 2 & 2 & 2\\
          Coda & $\cancel{\text{s}}$ & $\cancel{\text{w}}$ & $\cancel{\text{r}}$
               & t & x & v
        \end{tabular}
      \end{table}
      \begin{figure}[H]
        \centering
        \begin{tikzpicture}[
          every node/.style={minimum size=0.7cm},
          ]
          \node[draw,circle,red] (r) {1} node[above] at (r.north) {r};
          \node[draw,circle,red] (s) [right=of r] {0} node[above] at (s.north) {s};
          \node[draw,circle,blue] (t) [right=of s] {2} node[above] at (t.north) {t};
          \node[draw,circle] (u) [right=of t] {} node[above] at (u.north) {u};

          \node[draw,circle,blue] (v) [below=of r] {2} node[below] at (v.south) {v};
          \node[draw,circle,red] (w) [below=of s] {1} node[below] at (w.south) {w};
          \node[draw,circle,blue] (x) [below=of t] {2} node[below] at (x.south) {x};
          \node[draw,circle] (y) [below=of u] {} node[below] at (y.south) {y};

          \draw[->,thick] (r) -- (s);
          \draw[<-,thick] (r) -- (v);
          \draw[<-,thick] (s) -- (w);
          \draw[->,thick] (t) -- (w);
          \draw (t) -- (x);
          \draw (t) -- (u);
          \draw[<-,thick] (w) -- (x);
          \draw (u) -- (y);
          \draw (x) -- (y);
        \end{tikzpicture}
      \end{figure}

    \item Quarto passo:
      \begin{table}[H]
        \centering
        \begin{tabular}{c|cccccccc}
          Distanza & 0 & 1 & 1 & 2 & 2 & 2 & 3 & 3\\
          Coda & $\cancel{\text{s}}$ & $\cancel{\text{w}}$ & $\cancel{\text{r}}$
               & $\cancel{\text{t}}$ & $\cancel{\text{x}}$ & $\cancel{\text{v}}$
               & u & y
        \end{tabular}
      \end{table}
      \begin{figure}[H]
        \centering
        \begin{tikzpicture}[
          every node/.style={minimum size=0.7cm},
          ]
          \node[draw,circle,red] (r) {1} node[above] at (r.north) {r};
          \node[draw,circle,red] (s) [right=of r] {0} node[above] at (s.north) {s};
          \node[draw,circle,red] (t) [right=of s] {2} node[above] at (t.north) {t};
          \node[draw,circle,blue] (u) [right=of t] {3} node[above] at (u.north) {u};

          \node[draw,circle,red] (v) [below=of r] {2} node[below] at (v.south) {v};
          \node[draw,circle,red] (w) [below=of s] {1} node[below] at (w.south) {w};
          \node[draw,circle,red] (x) [below=of t] {2} node[below] at (x.south) {x};
          \node[draw,circle,blue] (y) [below=of u] {3} node[below] at (y.south) {y};

          \draw[->,thick] (r) -- (s);
          \draw[<-,thick] (r) -- (v);
          \draw[<-,thick] (s) -- (w);
          \draw[->,thick] (t) -- (w);
          \draw (t) -- (x);
          \draw[<-,thick] (t) -- (u);
          \draw[<-,thick] (w) -- (x);
          \draw (u) -- (y);
          \draw[<-,thick] (x) -- (y);
        \end{tikzpicture}
      \end{figure}

    \item Quinto passo:
      \begin{table}[H]
        \centering
        \begin{tabular}{c|cccccccc}
          Distanza & 0 & 1 & 1 & 2 & 2 & 2 & 3 & 3\\
          Coda & $\cancel{\text{s}}$ & $\cancel{\text{w}}$ & $\cancel{\text{r}}$
               & $\cancel{\text{t}}$ & $\cancel{\text{x}}$ & $\cancel{\text{v}}$
               & $\cancel{\text{u}}$ & $\cancel{\text{y}}$
        \end{tabular}
      \end{table}
      \begin{figure}[H]
        \centering
        \begin{tikzpicture}[
          every node/.style={minimum size=0.7cm},
          ]
          \node[draw,circle,red] (r) {1} node[above] at (r.north) {r};
          \node[draw,circle,red] (s) [right=of r] {0} node[above] at (s.north) {s};
          \node[draw,circle,red] (t) [right=of s] {2} node[above] at (t.north) {t};
          \node[draw,circle,red] (u) [right=of t] {3} node[above] at (u.north) {u};

          \node[draw,circle,red] (v) [below=of r] {2} node[below] at (v.south) {v};
          \node[draw,circle,red] (w) [below=of s] {1} node[below] at (w.south) {w};
          \node[draw,circle,red] (x) [below=of t] {2} node[below] at (x.south) {x};
          \node[draw,circle,red] (y) [below=of u] {3} node[below] at (y.south) {y};

          \draw[->,thick] (r) -- (s);
          \draw[<-,thick] (r) -- (v);
          \draw[<-,thick] (s) -- (w);
          \draw[->,thick] (t) -- (w);
          \draw (t) -- (x);
          \draw[<-,thick] (t) -- (u);
          \draw[<-,thick] (w) -- (x);
          \draw (u) -- (y);
          \draw[<-,thick] (x) -- (y);
        \end{tikzpicture}
      \end{figure}
  \end{enumerate}
  Se si vuole trovare il cammino minimo tra due nodi, si parte dal nodo di destinazione
  e si risale al nodo di partenza seguendo il campo \texttt{parent} di ogni nodo.

  \vspace{1em}
  \noindent
  Questo algoritmo produce un \textbf{albero dei cammini di lunghezza minima} radicato in
  \( s \) che ha un cammino minimo per ogni nodo, se tale cammino esiste.
\end{example}

\noindent
\textbf{Dimostrazione}: Dimostriamo che l'algoritmo BFS produce sempre un albero dei 
cammini di lunghezza minima:

Sia \( \delta(v) \) la lunghezza del cammino minimo da \( s \) a \( v \). Dimostrare che
\[
  \forall v \quad v.distance = \delta(v)
\]
Per dimostrare l'uguaglianza dimostriamo che sia comtemporaneamente maggiore e uguale
e minore e uguale:

\vspace{1em}
\noindent
\textbf{Lemma 1.} \( \forall (u,v) \in E \quad \delta(v) \le \delta(u) + 1 \) 
\begin{figure}[H]
  \centering
  \begin{tikzpicture}
    \node[draw,circle] (s) at (0,0) {s};
    \node[draw,circle] (u) [below right=of s] {u};
    \node[draw,circle] (v) [above right=of s] {v};

    \draw[->,dashed] (s) -- (u) node[midway, below left] {$\delta(u)$};
    \draw[->,dashed] (s) -- (v) node[midway, above left] {$\delta(v)$};
    \draw[->] (u) -- (v) node[midway, right] {$\delta(u) + 1$};
  \end{tikzpicture}
  \caption{Lemma 1}
\end{figure}

\noindent
\textbf{Lemma 2.} \( \forall v \quad v.distance \ge \delta(v) \) perchè:
\[
  \begin{aligned}
    s.distance &= 0 \ge 0\\
    v.distance &= u.distance + 1 \ge \delta(u) + 1 \ge \delta(v)
  \end{aligned}
\] 

\noindent
\textbf{Lemma 3.} Nella coda \( Q \) ci sono smpre al più 2 valori e la coda è ordinata
per distanza crescente.
Sia \( \left<v_1, \ldots, v_r \right> \) il contenuto di \( Q \) in un qualche istante,
allora:
\[
  v_1.distance \le v_2.distance \le \ldots \le v_r.distance \le v_1.distance + 1
\] 
Questo è vero per ogni istruzione del programma, è un \textbf{invariante}.
Ogni istruzione che non modifica \( Q \) e non modifica le distanze non modifica l'invariante.
L'inizializzazione della coda e la modifica della distanza di un nodo da aggiungere alla
coda non modificano l'invariante. L'aggiunta di un nodo alla coda mantiene l'invariante.
Quindi tutte le istruzioni mantengono l'invariante.

\begin{theorem}
  Sia \( V_k \) l'insieme di nodi \( v \;\big|\; \delta(v) = k \), allora
  \( \forall v \in V_k \) esiste un punto dell'algoritmo in cui:
  \begin{itemize}
    \item \( v \) è grigio (scoperto, ma non esplorato).
    \item \( k \) è assegnato a \( v.distance \).
    \item se \( v \neq s \) allora \( v.parent = u \) per qualche \( u \in V_{k-1} \).
    \item \( v \) è inserito in coda
  \end{itemize}
\end{theorem}

\subsubsection{Visita in profondità (DFS: Depth First Search)}
L'algoritmo è il seguente:
\begin{lstlisting}[language=Scala]
// G e' un grafo composto da un insieme di nodi V e un insieme di archi E
dfs(G)
  for u in G.V
    u.color <- white // non esplorato
    u.parent <- NIL

  time <- 0

  for u in G.V
    if u.color == white
      dfs-visit(u)
\end{lstlisting}
\begin{lstlisting}[language=Scala]
// Le variabili della funzione dfs sono accessibili anche da dfs-visit
dfs_visit(u)
  u.color <- gray // scoperto, ma non esplorato
  u.start <- time <- time + 1

  for v in G.adj(u)
    if v.color == white // non esplorato
      v.parent <- u
      dfs-visit(v)

  u.color <- black // esplorato
  u.finish <- time <- time + 1
\end{lstlisting}
La complessità di questo algoritmo è \(O(|V| + |E|)\).
\begin{example}
  I numeri a sinistra indicano il tempo di inizio della visita e i numeri a destra
  la fine della visita
  \begin{figure}[H]
    \centering
    \begin{tikzpicture}[
      every node/.style={minimum size=1.2cm},
      ]
      \node[draw,circle] (y) {3/6} node[above] at (y.north) {y};
      \node[draw,circle] (z) [right=of y] {2/9} node[above] at (z.north) {z};
      \node[draw,circle] (s) [right=of z] {1/10} node[above] at (s.north) {s};
      \node[draw,circle] (t) [right=of s] {11/16} node[above] at (t.north) {t};

      \node[draw,circle] (x) [below=of y] {4/5} node[below] at (x.south) {x};
      \node[draw,circle] (w) [below=of z] {7/8} node[below] at (w.south) {w};
      \node[draw,circle] (v) [below=of s] {12/13} node[below] at (v.south) {v};
      \node[draw,circle] (u) [below=of t] {14/15} node[below] at (u.south) {u};

      \draw[->] (y) -- (x);
      \draw[<-] (y) -- (z);
      \draw[->] (z) -- (w);
      \draw[<-] (z) -- (s);
      \draw[<-] (s) -- (v);
      \draw[->] (t) -- (v);
      \draw[->] (t) -- (u);
      \draw[->] (v) -- (w);
      \draw[->] (w) -- (x);
      \draw[->] (x) -- (z);
      \draw[->] (s) -- (w);

      \draw[->,thick] (x) to [bend left] (y);
      \draw[->,thick] (y) to [bend left] (z);
      \draw[->,thick] (z) to [bend left] (s);
      \draw[->,thick] (w) to [bend left] (z);

      \draw[->,thick] (v) to [bend left] (t);
      \draw[->,thick] (u) to [bend left] (t);

      \node[below left=0cm and 0.2cm of y] {Parent};
    \end{tikzpicture}
    \caption{Visita in profondità}
  \end{figure}
\end{example}

Riprendendo l'esempio precedente scriviamo i passaggi nel seguente modo:
Il tipo di nodo è denotato dal tipo di parentesi:
\begin{itemize}
  \item Parentesi aperta: inizio a visitare il nodo
  \item Parentesi chiusa: fine della visita del nodo
\end{itemize}

\begin{table}[H]
  \centering
  \setlength{\tabcolsep}{2pt}
  \begin{tabular}{ccccccccccccccccc}
    Tempo & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 & 10 & 11 & 12 & 13 & 14 & 15 & 16\\
  \hline
          & (s & (z & (y & (x & x) & y) & (w & w) & z) & s) & (t & (v & v) & (u & u) & t)\\
  \end{tabular}
\end{table}
Questa espressione è ben parentesizzata:
\begin{figure}[H]
  \centering
  \begin{tikzpicture}[scale=0.7]
    \node (1) at (1,0) {1} node[below=0.2cm] at (1) {(s};
    \node (2) at (2,0) {2} node[below=0.2cm] at (2) {(z};
    \node (3) at (3,0) {3} node[below=0.2cm] at (3) {(y};
    \node (4) at (4,0) {4} node[below=0.2cm] at (4) {(x};
    \node (5) at (5,0) {5} node[below=0.2cm] at (5) {x)};
    \node (6) at (6,0) {6} node[below=0.2cm] at (6) {y)};
    \node (7) at (7,0) {7} node[below=0.2cm] at (7) {(w};
    \node (8) at (8,0) {8} node[below=0.2cm] at (8) {w)};
    \node (9) at (9,0) {9} node[below=0.2cm] at (9) {z)};
    \node (10) at (10,0) {10} node[below=0.2cm] at (10) {s)};
    \node (11) at (11,0) {11} node[below=0.2cm] at (11) {(t};
    \node (12) at (12,0) {12} node[below=0.2cm] at (12) {(v};
    \node (13) at (13,0) {13} node[below=0.2cm] at (13) {v)};
    \node (14) at (14,0) {14} node[below=0.2cm] at (14) {(u};
    \node (15) at (15,0) {15} node[below=0.2cm] at (15) {u)};
    \node (16) at (16,0) {16} node[below=0.2cm] at (16) {t)};

    \draw (4,1) rectangle (5,1.6) node[below left] {x} node[midway] (x) {};

    \draw (3,2) rectangle (6,2.6) node[below left] {y} node[midway] (y) {};
    \draw (7,2) rectangle (8,2.6) node[below left] {w} node[midway] (w) {};

    \draw (2,3) rectangle (9,3.6) node[below left] {z} node[midway] (z) {};
    \draw (12,3) rectangle (13,3.6) node[below left] {v} node[midway] (v) {};
    \draw (14,3) rectangle (15,3.6) node[below left] {u} node[midway] (u) {};

    \draw (1,4) rectangle (10,4.6) node[below left] {s} node[midway] (s) {};
    \draw (11,4) rectangle (16,4.6) node[below left] {t} node[midway] (t) {};

    \draw[->] (y) -- (x);
    \draw[->] (z) -- (y);
    \draw[->] (z) -- (w);
    \draw[->] (s) -- (z);
    \draw[->] (t) -- (v);
    \draw[->] (t) -- (u);
  \end{tikzpicture}
  \caption{Visualizzazione dell'albero}
\end{figure}

\noindent
Gli archi si dividono in:
\begin{itemize}
  \item \textbf{Arco dell'albero} (T): è un arco che collega un nodo a un suo discendente
  \item \textbf{Arco all'indietro} (B): è un arco che collega un nodo a un suo antenato
  \item \textbf{Arco in avanti} (F): è un arco che collega un nodo a un discendente non diretto
  \item \textbf{Arco trasversale} (C): è un arco che collega due nodi non correlati
\end{itemize}
Quindi nell'esempio precedente abbiamo:
\begin{figure}[H]
  \centering
  \begin{tikzpicture}[
    every node/.style={minimum size=1.2cm},
    ]
    \node[draw,circle] (y) {3/6} node[above] at (y.north) {y};
    \node[draw,circle] (z) [right=of y] {2/9} node[above] at (z.north) {z};
    \node[draw,circle] (s) [right=of z] {1/10} node[above] at (s.north) {s};
    \node[draw,circle] (t) [right=of s] {11/16} node[above] at (t.north) {t};

    \node[draw,circle] (x) [below=of y] {4/5} node[below] at (x.south) {x};
    \node[draw,circle] (w) [below=of z] {7/8} node[below] at (w.south) {w};
    \node[draw,circle] (v) [below=of s] {12/13} node[below] at (v.south) {v};
    \node[draw,circle] (u) [below=of t] {14/15} node[below] at (u.south) {u};

    \draw[->] (y) -- (x) node[midway, right=-0.3cm] {T};
    \draw[<-] (y) -- (z) node[midway, above=-0.3cm] {T};
    \draw[->] (z) -- (w) node[midway, right=-0.3cm] {T};
    \draw[<-] (z) -- (s) node[midway, above=-0.3cm] {T};
    \draw[<-] (s) -- (v) node[midway, right=-0.3cm] {C};
    \draw[->] (t) -- (v) node[midway, right=-0.2cm] {T};
    \draw[->] (t) -- (u) node[midway, right=-0.3cm] {T};
    \draw[->] (v) -- (w) node[midway, above=-0.3cm] {C};
    \draw[->] (w) -- (x) node[midway, above=-0.3cm] {C};
    \draw[->] (x) -- (z) node[midway, right=-0.3cm] {B};
    \draw[->] (s) -- (w) node[midway, right=-0.3cm] {F};
  \end{tikzpicture}
  \caption{Tipi di archi}
\end{figure}

nel nostro algoritmo abbiamo che il clolore degli archi distingue i vari tipi:
\begin{itemize}
  \item \textbf{Bianco} (non esplorato): arco trasversale (T)
  \item \textbf{Grigio} (scoperto, ma non esplorato): arco all'indietro (B)
  \item \textbf{Nero} (esplorato): arco dell'albero o arco in avanti (F,C)
\end{itemize}
Da questo consegue che se ci sono archi all'indietro è presente un ciclo, quindi esiste
un algoritmo di complessità \(O(|V| + |E|)\) per trovare se un grafo è ciclico e questo
algoritmo è il DFS.

\begin{theorem}
  Dopo una DFS \( \forall u, v \) gli intervalli \( [\text{\texttt{u.start}},
  \text{\texttt{u.finish}}] \) sono disgiunti, oppure uno sottointervallo dell'altro

  \vspace{1em}
  \noindent
  \textbf{Dimostrazione}:
  \begin{enumerate}
    \item Caso 1: Supponiamo che \( \text{\texttt{u.start}} < \text{\texttt{v.start}} \)
      \begin{enumerate}
        \item Se \( \text{\texttt{u.finish}} < \text{\texttt{v.start}} \) allora
          i due intervalli sono disgiunti
        \item Se \( \text{\texttt{u.start}} < \text{\texttt{v.finish}} \) allora
          \( v \) è un sottointervallo di \( u \) 
      \end{enumerate}
      \textbf{Corollario}: In DFS \( v \) discende da \( u \) se e solo se:
      \[
        \text{\texttt{u.start}} < \text{\texttt{v.start}} < \text{\texttt{v.finish}} < \text{\texttt{u.finish}}
      \] 
  \end{enumerate}
\end{theorem}
\begin{theorem}
  Nella foresta di alberi generata da una DFS, un nodo \( v \) è un discendente di un nodo
  \( u \) se e solo se al tempo \( \text{\texttt{u.start}} \) esiste un cammino da \( u \) 
  a \( v \) fatto di soli nodi bianchi (non esplorati).

  \vspace{1em}
  \noindent
  \textbf{Dimostrazione}: Supponiamo che \( v \) discende da \( u \), sia \( w \) un nodo
  del cammino da \( u \to v \) della foresta:
  \[
    \text{\texttt{u.start}} < \text{\texttt{w.start}}
  \] 
  Quindi nel momento in cui \( u \) viene scoperto, \( w \) è ancora bianco.
  \begin{figure}[H]
    \begin{itemize}
      \item Nero: non esplorato,
      \item \textcolor{blue}{Blu}: scoperto, ma non esplorato,
      \item \textcolor{red}{Rosso}: esplorato,
    \end{itemize}
    \centering
    \begin{tikzpicture}
      \node[draw,circle,red] (u) {u};
      \node[draw,circle] (w) [right=of u] {w};
      \node[draw,circle] (v) [right=of w] {v};

      \draw[->] (u) -- (w);
      \draw[->] (w) -- (v);
    \end{tikzpicture}
  \end{figure}

  \vspace{1em}
  \noindent
  \( v \) raggiungibile da \( u \) al tempo \( \text{\texttt{u.start}} \) con cammino
  di nodi bianchi (non esplorati). Supponiamo per assurdo che \( v \) non discende da \( u \) 
  \begin{figure}[H]
    \centering
    \begin{tikzpicture}[
      every node/.style={minimum size=0.8cm},
      ]
      \node[draw,circle] (u) {\( u \) };
      \node[draw,circle] (u1) [right=of u] {\( u_1 \)};
      \node[draw,circle] (u2) [right=of u1] {\( u_2 \)};
      \node[draw,circle] (w) [right=of u2] {\( w \)};
      \node[draw,circle] (v) [right=of w] {\( v \)};

      \draw[->] (u) -- (u1);
      \draw[->] (u1) -- (u2);
      \draw[->] (u2) -- (w);
      \draw[->] (w) -- (v);
    \end{tikzpicture}
  \end{figure}
  \noindent
  Supponiamo, senza perdita di generalità, che il predecessore di \( v \) discende da \( u \).
  Sia \( w \) il predecessore di \( v \), allora \( w \) discende da \( u \), quindi:
  \[
    \text{\texttt{w.finish}} < \text{\texttt{u.finish}}
  \] 
  di conseguenza:
  \[
    \text{\texttt{u.start}} < \text{\texttt{w.start}} < 
    \underbrace{\text{\texttt{v.start}} < \text{\texttt{v.finish}}}_{\text{Sottointervallo
    di \( u \)}}
    < \text{\texttt{w.finish}} < \text{\texttt{u.finish}}
  \] 
  Quindi l'intervallo \( v \) è un sottointervallo di \( u \) contraddicendo l'ipotesi
  e dimostrando che \( v \) discende da \( u \).
\end{theorem}

\end{document}
