\documentclass[a4paper]{article}
\usepackage{import}
\input{../../../preamble.sty}

\begin{document}

\input{title.tex}

\tableofcontents
\pagebreak

\section{Laboratorio}
\subsection{Shell}
La shell è un interprete dei comandi che permette di comunicare con il sistema operativo.
La shell principale di Linux è la \textbf{bash} (Bourne Again SHell) che è una shell
che permette di eseguire comandi, script e programmi. Il funzionamento principale è il
seguente:
\begin{figure}[H]
  \centering
  \begin{tikzpicture}
    \node[draw] (shell) at (0,0) {\texttt{/bin/bash}};
    \node[draw, right=of shell] (fork) {\texttt{/bin/bash}};
    \node[draw, below=of fork] (programma) {\texttt{/bin/ls}};

    \draw[->] (shell) -- (fork) node[midway,above] {fork};
    \draw[->] (fork) -- (programma) node[midway,right] {exec};
    \draw[->] (programma) -| (shell) node[midway,above right] {exit};
  \end{tikzpicture}
  \caption{Funzionamento della bash}
\end{figure}
\noindent
Le system call coinvolte sono:
\begin{itemize}
  \item \texttt{fork}: Processo padre Bash crea un nuovo processo figlio
  \item \texttt{exec}: Processo figlio carica il codice del comando richiesto
  \item \texttt{exit}: Processo figlio termina
  \item \texttt{wait}: Processo padre Bash aspetta la terminazione del figlio
\end{itemize}

\subsubsection{Comandi}
La sintassi generale di un comando linux è:
\begin{lstlisting}[language=bash]
comando [-opzioni] [argomenti]
\end{lstlisting}
Più comandi possono essere concatenati con il carattere \texttt{;}. Ad esempio:
\begin{lstlisting}[language=bash]
comando1; comando2; ...; comandoN
\end{lstlisting}
Ogni comando linux ha un  manuale che può essere consultato con il comando:
\begin{lstlisting}[language=bash]
man <comando>
\end{lstlisting}

\subsubsection{File system}
Il file system è la struttura che permette di organizzare i file e le directory in un
sistema operativo. Il file system di Linux è basato su una struttura ad albero con
una radice "\texttt{/}" e permette di accedere ai file e alle directory tramite un
\textbf{percorso} (path). Il path può essere di 2 tipi:
\begin{itemize}
  \item \textbf{Path assoluto}: Parte dalla radice "/" del file system, ad esempio
    \texttt{/dir1/dir2}

  \item \textbf{Path relativo}: Parte dalla directory corrente, ad esempio

    \texttt{dir1/dir2}
\end{itemize}

\vspace{1em}
\noindent
Un path può anche contenere dei caratteri speciali, chiamati \textbf{wildcard}:
\begin{itemize}
  \item \texttt{*} Qualsiasi stringa di caratteri
  \item \texttt{?} Qualsiasi singolo carattere
  \item \texttt{[ ]} Qualsiasi carattere tra le parentesi
\end{itemize}

\vspace{1em}
\noindent
In linux ogni cosa è un file e i file sono di diversi tipi:
\begin{itemize}
  \item \textbf{Directory}: Contiene altri file e sotto-directory
  \item \textbf{Special file}: È un entry point per un dispositivo di I/O, ad esempio
    \texttt{/dev/sda}
  \item \textbf{Link}: Puntatore ad un altro file. Si divide in:
    \begin{itemize}
      \item \textbf{Hard link}: Puntatore diretto al file
      \item \textbf{Symbolic link} (o soft link): Puntatore indiretto al file, quindi
        solo al percorso del file. Se la destinazione del link viene spostata, il link
        non funziona più
    \end{itemize}
  \item \textbf{File ordinatio}: Contiene dati
\end{itemize}

\vspace{1em}
\noindent
Ogni file ha associati dei \textbf{permessi} che definiscono chi può leggere (r, read),
scrivere (w, write) e/o eseguire (x, execute) il file.
I permessi sono divisi in 3 categorie:
\begin{itemize}
  \item \textbf{User} (u): Il proprietario del file
  \item \textbf{Group} (g): Il gruppo del file
  \item \textbf{Others} (o): Tutti gli altri
\end{itemize}

\subsubsection{Comandi base}
\begin{itemize}
\item
\begin{lstlisting}
ls [-options] <path>
\end{lstlisting}
Mostra i file e le directory presenti nel \textbf{path} specificato.

\item
\begin{lstlisting}
cat <file>
\end{lstlisting}
Stampa il contenuto del file specificato su standard output.

\item
\begin{lstlisting}
head [-n] <file>
\end{lstlisting}
Visualizza le prime \textbf{n} righe del file.

\item
\begin{lstlisting}
tail [-n] <file>
\end{lstlisting}
Visualizza le ultime \textbf{n} righe del file.

\item
\begin{lstlisting}
cp <file> <dest>
\end{lstlisting}
Copia il file nella destinazione \texttt{dest}.

\item
\begin{lstlisting}
mv <file> <dest>
\end{lstlisting}
Sposta il file nella destinazione \texttt{dest}. Se la destinazione è la stessa del file
allora il file viene rinominato.

\item
\begin{lstlisting}
rm [-rf] <path>
\end{lstlisting}
Rimuove il file o la directory specificata. L'opzione \texttt{-r} permette di rimuovere
una directory in modo ricorsivo, cioè anche il contenuto della directory. L'opzione
\texttt{-f} permette di rimuovere senza chiedere conferma.

\item
\begin{lstlisting}
cd <path>
\end{lstlisting}
Cambia la directory corrente con quella specificata.

\item
\begin{lstlisting}
pwd
\end{lstlisting}
Stampa il percorso della directory corrente.

\item
\begin{lstlisting}
mkdir <dir>
\end{lstlisting}
Crea una directory con il nome specificato.

\item
\begin{lstlisting}
rmdir <dir>
\end{lstlisting}
Rimuove la directory specificata se è vuota.

\item
\begin{lstlisting}
chgrp [-R] <group> <file>
\end{lstlisting}
Cambia il gruppo del file specificato. L'opzione \texttt{-R} permette di cambiare il
gruppo ricorsivamente.

\item
\begin{lstlisting}
chown [-R] <user:group> <file>
\end{lstlisting}
Cambia il proprietario (e il gruppo) del file specificato.

\item
\begin{lstlisting}
chmod [-R] <permessi> <path>
\end{lstlisting}
Cambia i permessi del file o della directory specificata. I permessi possono essere
specificati in 3 modi:
\begin{itemize}
  \item \textbf{Notazione numerica} (ottale): Ad esempio \texttt{777} che corrisponde ai
    permessi \texttt{rwxrwxrwx}.
    La prima cifra corrisponde ai permessi dell'utente, la seconda
    ai permessi del gruppo e la terza agli altri. I permessi sono:
    \begin{itemize}
      \item \texttt{r} (read): 4
      \item \texttt{w} (write): 2
      \item \texttt{x} (execute): 1
    \end{itemize}
    e la somma di ogni singolo permesso corrisponde ai permessi totali, ad esempio:
    \[
      7 = 4 + 2 + 1 = \texttt{rwx}
    \] 
  \item \textbf{Notazione simbolica}: Ad esempio \texttt{ugo+r} che aggiunge il permesso
    di lettura a user, group e others
  \item \textbf{Notazione mista}: Ad esempio \texttt{u=rwx,g=rx,o=r} che assegna i permessi
    \texttt{rwx} all'utente, \texttt{rx} al gruppo e \texttt{r} agli altri
\end{itemize}

\item
\begin{lstlisting}
find <path> [-name <pattern>]
\end{lstlisting}
Cerca i file e le directory nel \texttt{path} specificato e ritorna i file che rendono
vera l'espressione specificata in \texttt{pattern}. Ad esempio:
\begin{lstlisting}[language=bash]
find / -name "*.txt"
\end{lstlisting}
cerca tutti i file con estensione \texttt{.txt} partendo dalla radice.

\item
\begin{lstlisting}
diff [-options] <file1> <file2>
\end{lstlisting}
Mostra le differenze tra i due file.
\end{itemize}

\subsubsection{Processi}
Un processo è un'istanza di un programma in esecuzione (un file binario). Per vedere
la lista dei processi in esecuzione si può usare il comando:
\begin{lstlisting}
ps

  PID TTY          TIME CMD
11877 pts/1    00:00:00 bash
12110 pts/1    00:00:00 ps
\end{lstlisting}
Dove:
\begin{itemize}
  \item \texttt{PID}: Process ID, l'identificativo del processo
  \item \texttt{TTY}: Il terminale associato al processo
  \item \texttt{TIME}: Il tempo di CPU usato dal processo
  \item \texttt{CMD}: Il comando che ha generato il processo
\end{itemize}

\vspace{1em}
\noindent
I processi possono essere eseguiti in due modi:
\begin{itemize}
  \item \textbf{Foreground}: Il processo viene eseguito in primo piano e il terminale
    rimane bloccato finchè il processo non termina. In questa modalità il processo
    ha accesso a tre canali standard connessi al terminale:
    \begin{itemize}
      \item \texttt{stdin}: Standard input
      \item \texttt{stdout}: Standard output
      \item \texttt{stderr}: Standard error
    \end{itemize}
    Un processo in foreground può essere sospeso con la combinazione di tasti \texttt{Ctrl + Z}
    (\texttt{\textasciicircum Z}) e può essere ripreso con il comando \texttt{fg}.

    Un processo può essere interrotto con la combinazione di tasti \texttt{Ctrl + C} (\texttt{\textasciicircum C}).
  \item \textbf{Background}: Il processo viene eseguito in secondo piano e il terminale
    rimane libero. Inquesta modalità il processo non ha accesso ai canali standard.
    Per eseguire un processo in background si può usare il carattere \texttt{\&} alla
    fine del comando, ad esempio:
\begin{lstlisting}[language=bash]
ls &
\end{lstlisting}
\end{itemize}

\vspace{1em}
\noindent
I comandi principali per gestire i processi sono:
\begin{itemize}
\item 
\begin{lstlisting}
jobs [-l]
\end{lstlisting}
Elenca i processi in background o sospesi.

\item 
\begin{lstlisting}
bg [%<job>]
\end{lstlisting}
Riattiva un processo sospeso in background.

\item 
\begin{lstlisting}
fg [%<job>]
\end{lstlisting}
Riattiva un processo sospeso in foreground.

\item 
\begin{lstlisting}
kill [-signal] <PID>
\end{lstlisting}
Manda un segnale al processo indicato. I più comuni sono:
\begin{itemize}
  \item \texttt{SIGKILL} (9): Termina il processo
  \item \texttt{SIGTERM} (15): Termina il processo in modo pulito
\end{itemize}
\end{itemize}

\subsubsection{Redirezione dell'I/O}
La redirezione dell'I/O permette di ridirezionare i canali standard di un processo su
un file o su un altro canale.

\vspace{1em}
\noindent
Per redirezionare l'I/O si possono usare i seguenti operatori:
\begin{itemize}
  \item \texttt{<}: Redireziona lo standard input, ad esempio:
\begin{lstlisting}
cat < file.txt
\end{lstlisting}

  \item \texttt{>}: Redireziona lo standard output, ad esempio:
\begin{lstlisting}
ls > file.txt
\end{lstlisting}

  \item \texttt{>>}: Redireziona lo standard output in append mode (aggiunge il contenuto
    al file senza sovrascriverlo), ad esempio:
\begin{lstlisting}
ls >> file.txt
\end{lstlisting}

\item \texttt{[n]>}: Redireziona il canale \texttt{n}, dove \texttt{n} è un numero
  che rappresenta:
  \begin{itemize}
    \item \texttt{0}: Standard input
    \item \texttt{1}: Standard output
    \item \texttt{2}: Standard error
  \end{itemize}
  Ad esempio:
\begin{lstlisting}
ls 1> file.out 2> file.err
\end{lstlisting}

  \item \texttt{2>\&1}: Redireziona lo standard error su standard output

  \item \texttt{|} (Pipe): Permette di concatenare più comandi in modo che l'output di
    un comando venga usato come input per il comando successivo, ad esempio:
\begin{lstlisting}
ls | cat
\end{lstlisting}
\end{itemize}

\subsubsection{Variabili d'ambiente}
La shell ha un insieme di variabili d'ambiente, cioè delle variabili globali che
contengono informazioni sul sistema.
Ogni variabile rispetta la sintassi:
\begin{lstlisting}
nome=valore
\end{lstlisting}
Le variabili d'ambiente principali sono:
\begin{itemize}
  \item \texttt{PWD}: Path corrente del file system
  \item \texttt{SHELL}: Il percorso della shell corrente (ad esempio \texttt{/bin/bash})
  \item \texttt{USER}: Il nome dell'utente
  \item \texttt{HOME}: La directory home dell'utente
  \item \texttt{PATH}: La lista delle directory in cui cercare i comandi (binari)
\end{itemize}

\vspace{1em}
\noindent
Per leggere le variabili d'ambiente si possono usare i seguenti comandi:
\begin{itemize}
\item 
\begin{lstlisting}
printenv <var>
\end{lstlisting}
Stampa il valore della variabile d'ambiente specificata.

\item 
\begin{lstlisting}
env
\end{lstlisting}
Stampa tutte le variabili d'ambiente.

\item 
\begin{lstlisting}
echo $<var>
\end{lstlisting}
Stampa il valore della variabile d'ambiente specificata.
\end{itemize}

\subsubsection{Script}
Uno script è una lista di comandi di sistema eseguiti sequenzialmente dalla shell.
Gli script sono salvati in file di testo con estensione \texttt{.sh} e devono avere
come prima riga:
\begin{lstlisting}[language=bash]
#!/bin/bash
\end{lstlisting}
che indica il percorso dell'interprete da usare per eseguire lo script, in questo caso
la bash.

\vspace{1em}
\noindent
Per eseguire uno script:
\begin{itemize}
  \item Si può usare il comando:
\begin{lstlisting}
bash <script> [args]
\end{lstlisting}
        che esegue lo script con la bash
  \item Si può rendere lo script eseguibile con il comando:
\begin{lstlisting}
chmod +x <script>
\end{lstlisting}
        e poi eseguirlo direttamente con:
\begin{lstlisting}
./<script> [args]
\end{lstlisting}
\end{itemize}

\vspace{1em}
\noindent
La bash memorizza gli argomenti della linea di comando dentro una serie di variabili
speciali:
\begin{itemize}
  \item \texttt{\$0}: Il nome dello script
  \item \texttt{\$1}, \texttt{\$2}, ...: Gli argomenti passati allo script
  \item \texttt{\$*}: Tutti gli argomenti passati allo script
  \item \texttt{\$@}: Tutti gli argomenti passati allo script
  \item \texttt{\$?}: Indica se il comando precedente è stato eseguito correttamente:
    \begin{itemize}
      \item 0: Comando eseguito correttamente
      \item 1: Comando non eseguito correttamente
    \end{itemize}
  \item \texttt{\$\#}: Il numero di argomenti passati allo script
\end{itemize}

\vspace{1em}
\noindent
\textbf{Variabili:}

\noindent
Le variabili in uno script si dichiarano come: \texttt{nome=valore}, ma per accedere
al valore della variabile si deve usare il simbolo di dollaro prima del nome. Ad esempio:
\begin{lstlisting}[language=bash]
#!/bin/bash
nome="Fabio"
echo $nome

# Output:
# Fabio
\end{lstlisting}

\vspace{1em}
\noindent
Per acquisire input dallo standard input si può usare il comando \texttt{read}:
\begin{lstlisting}
read <var>
\end{lstlisting}
ad esempio:
\begin{lstlisting}[language=bash]
read x
< Fabio
echo $x
> Fabio
\end{lstlisting}

\vspace{1em}
\noindent
Tutte le variabili in bash sono stringhe, quindi per fare operazioni aritmetiche si
deve specificare di volerlo fare con l'operatore \texttt{\$(( ))} che permette di 
valutare un'espressione, ad esempio:
\begin{lstlisting}[language=bash]
x = 0
echo $x+1
> 0+1
echo $((x+1))
> 1
\end{lstlisting}


\vspace{1em}
\noindent
È possibile utilizzare l'output di un comando come valore di inizializzazione di una
variabile, per fare ciò si usa l'operatore \texttt{\$()}:
\begin{lstlisting}[language=bash]
lista_file=$(ls)
# Ora la variabile lista_file contiene l'output del comando ls
\end{lstlisting}
Un altro modo per fare la stessa cosa è usare le backticks:
\begin{lstlisting}[language=bash]
lista_file=`ls`
# Ora la variabile lista_file contiene l'output del comando ls
\end{lstlisting}

\vspace{1em}
\noindent
\textbf{Condizionali:}

\noindent
Per fare un'istruzione condizionale si usa la seguente sintassi:
\begin{lstlisting}[language=bash]
if [ <condizione> ]; then
  <comandi>
fi
\end{lstlisting}
Oppure:
\begin{lstlisting}[language=bash]
if [ <condizione> ]; then
  <comandi>
elif [ <condizione> ]; then
  <comandi>
else
  <comandi>
fi
\end{lstlisting}

\vspace{1em}
\noindent
\textbf{Cicli:}

\noindent
Per fare un ciclo for si usa la seguente sintassi:
\begin{lstlisting}[language=bash]
for var in <lista>; do
  <comandi>
done
\end{lstlisting}
Per fare un while si usa la seguente sintassi:
\begin{lstlisting}[language=bash]
while [ <condizione> ]; do
  <comandi>
done
\end{lstlisting}

\vspace{1em}
\noindent
\textbf{Funzioni:}

\noindent
Per definire una funzione si usa la seguente sintassi:
\begin{lstlisting}[language=bash]
function nome_funzione {
  <comandi>
}
\end{lstlisting}
Oppure:
\begin{lstlisting}[language=bash]
nome_funzione() {
  <comandi>
}
\end{lstlisting}
Per chiamare una funzione si usa il nome della funzione:
\begin{lstlisting}[language=bash]
nome_funzione
\end{lstlisting}

\subsubsection{Programmi filtri}
Sono programmi che ricevono dati di ingresso da stdin e generano risultati su stdout.
Alcuni comandi più usati sono:
\begin{itemize}
  \item \texttt{grep, fgrep, egrep}: Filtra le righe di testo che contengono una stringa specificata
  \item \texttt{sort}: Ordina le righe di testo
  \item \texttt{uniq}: Rimuove le righe duplicate
  \item \texttt{wc}: Conta le righe, le parole e i caratteri
  \item \texttt{sed}: Sostituisce stringhe di testo
  \item \texttt{awk}: Filtra e trasforma il testo
  \item \texttt{cut}: Estrae colonne di testo
  \item \texttt{more, less}: Visualizza il testo a schermo
\end{itemize}

\subsection{Processi e programmi}
Un \textbf{processo} è un'istanza di un programma in esecuzione, mentre un \textbf{programma}
è un file binario che contiene un set di informazioni che descrive come costruire un
processo in runtime (cioè quando il programma viene eseguito).

\vspace{1em}
\noindent
Dal punto di vista del kernel un processo è composto da:
\begin{itemize}
  \item Memoria user-space che contiene il codice del programma
  \item Le variabili utilizzate dal codice
  \item Un insieme di strutture dati del kernel che mantengono informazioni riguardo
    allo stato del processo, ad esempio:
    \begin{itemize}
      \item Tabella di file aperti
      \item Tabelle di pagine
      \item Segnali da inviare
      \item Limiti e utilizzo delle risorse del processo
    \end{itemize}
\end{itemize}
Alla creazione di un processo, esso viene caricato in memoria contenendo i seguenti
campi:
\begin{itemize}
  \item \textbf{Codice del programma}: Una sezione di sola lettura che contiene sottoforma
    di testo le istruzioni del programma (text)
  \item \textbf{Dati inizializzati}: Una sezione che contiene le variabili globali
    e statiche inizializzate (data)
  \item \textbf{Dati non inizializzati}: Una sezione che contiene le variabili globali
    e statiche non inizializzate (bss)
  \item \textbf{Heap}: Una sezione che contiene le variabili allocate dinamicamente.
    Nell'architettura x86 il heap cresce verso indirizzi di memoria più alti
  \item \textbf{Stack}: Una sezione che contiene le variabili locali e i parametri
    delle funzioni. Nell'architettura x86 lo stack cresce verso indirizzi di memoria
    più bassi
\end{itemize}
\begin{figure}[H]
  \centering
  \begin{tikzpicture}
    \def\w{3.5}
    \def\h{1.5}
    % Process
    \draw (0,0) node[left,scale=0.8] {\texttt{0x08048000}}
      rectangle ++(\w,\h*1.2) node[midway,align=center] {Codice del\\programma\\(text)}
      rectangle ++(-\w,\h) node[midway,align=center] {Dati inizializzati\\(data)}
      rectangle ++(\w,\h) node[midway,align=center] {Dati non inizializzati\\(bss)}
      rectangle ++(-\w,\h) node[midway,align=center] {Heap\\(cresce verso l'alto)};

    \draw[<-] (-0.1,\h*1.2+\h*3) -- ++(-1,0) node[above,scale=0.8] {Program break};
    \draw[fill,fill opacity=0.1,text opacity=1]
      (0,\h*1.2+\h*3) rectangle ++(\w,\h*1.5) node[midway,align=center]
      {(memoria non\\allocata)};
    \draw[<-] (-0.1,\h*1.2+\h*3+\h*1.5) -- ++(-1,0) node[above,scale=0.8] {Cima dello stack};

    \draw (0,\h*1.2+\h*3+\h*1.5) rectangle ++(\w,\h) node[midway,align=center] {Stack\\(cresce verso il basso)}
      rectangle ++(-\w,\h/3) node[midway,align=center] {argv, environ}
      node[left,scale=0.8] {\texttt{0xC0000000}};
  \end{tikzpicture}
  \caption{Struttura di un processo}
\end{figure}
\noindent
\begin{example}
  Il seguente programma mostra dove vengono allocate le varie sezioni di un processo:
\begin{lstlisting}[language=c]
#include <stlib.h>
// Variabili dichiarate globalmente
char buffer[10];                    // (bss)
int primes[] = {2, 3, 5, 7};        // (data)

// Implementazioni delle funzioni
void method(int *a) {               // (stack)
  int i;                            // (stack)
  for (i = 0; i < 10; i++) {
    a[i] = i;
  }
}

// Entry point del programma
int main (int argc, char *argv[]) { // (stack)
  static int key = 123;             // (data)
  int *p;                           // (stack)
  p = malloc(10 * sizeof(int));     // (heap)

  method(p);
  free(p);

  return 0;
}
\end{lstlisting}
\end{example}
Per vedere la grandezza delle varie sezioni si può usare il comando \texttt{size}:
\begin{lstlisting}
gcc -o program program.c
size program
   text    data     bss     dec     hex     filename
   1017     260      12    1289     509     program
\end{lstlisting}

\vspace{1em}
\noindent
Per ogni processo il kernel salva una \textbf{file descriptor table}, che è una tabella
che contiene i file aperti dal processo. Ogni riga della tabella contiene un
\textbf{file descriptor}, cioè un intero positivo che rappresenta una risorsa di 
input/output aperta dal processo, ad esempio files, pipes, sockets, ecc.

Per convenzione ci sono sempre 3 file descriptor in un nuovo processo:
\begin{table}[H]
  \centering
  \begin{tabular}{c|c|c}
    \textbf{File descriptor} & \textbf{Descrizione} & \textbf{Nome POSIX} \\
    \hline
    0 & Standard input (stdin) & STDIN\_FILENO \\
    1 & Standard output (stdout) & STDOUT\_FILENO \\
    2 & Standard error (stderr) & STDERR\_FILENO \\
  \end{tabular}
  \caption{File descriptor standard}
\end{table}

\subsection{System call}
Le system call sono delle funzioni che permettono ai processi di interagire con il
kernel permettendo di accedere ai servizi offerti dal kernel, come ad esempio:
\begin{itemize}
  \item Creare un nuovo processo
  \item Leggere e scrivere file
  \item Creare un socket
  \item ecc...
\end{itemize}
Richiamare una system call è simile ad una chiamata di funzione, però ciò che viene
richiamato è solo un wrapper che passa i parametri alla system call effettiva che
viene eseguita in kernel mode dopo aver ricevuto un interrupt software. Una volta
che la system call è terminata, il controllo ritorna al processo chiamante in modalità
utente.

\subsubsection{Gestione degli errori}
Le system call ritornano un valore intero che rappresenta il risultato dell'operazione.
Quando una system call fallisce ritorna -1, oppure un NULL pointer. Successivamente
il valore di errore viene salvato all'interno di
una variabile globale chiamata \texttt{errno} che contiene un intero positivo che
rappresenta l'errore che si è verificato.
(Bisogna includere la libreria \texttt{<errno.h>} che fornisce una dichiarazione
della variabile \texttt{errno} e delle funzioni per gestire gli errori).

\begin{example}
  Un esempio di come gestire gli errori in una system call è il seguente:
\begin{lstlisting}[language=c]
// System call per aprire un file
fd = open(pathname, flags, mode);

// Gestione degli errori
if (fd == -1) { // La system call ha fallito
  if (errno == EACCES) { // Errore di accesso al file
    // Gestione dell'errore di accesso
  } else {
    // Altro tipo di errore
  }
}
\end{lstlisting}
\end{example}
Per vedere il significato dell'errore si
può usare la funzione \texttt{perror} che stampa su \texttt{stderr} un messaggio passato
come parametro, seguito da un messaggio che descrive l'ultimo errore riscontrato da una 
system call

\vspace{1em}
\noindent
Per vedere il significato dell'errore si può usare la funzione \texttt{strerror} che
ritorna una stringa che descrive l'errore passato come parametro. Esiste una tabella
degli errori che associa un codice di errore ad una stringa che lo descrive.

\vspace{1em}
\noindent
Per vedere quali system call sono state chiamate da un processo si può usare il comando
\texttt{strace}:
\begin{lstlisting}
strace <program> [args]
\end{lstlisting}

\subsubsection{File}
Le principali system call per gestire i file sono:
\begin{itemize}
\item Apre un file esistente o ne crea uno nuovo se viene specificato il flag adeguato.
  Se va a buon fine ritorna il file descriptor del file aperto, altrimenti ritorna -1
  \begin{lstlisting}[language=C]
#include <sys/stat.h>
#include <fcntl.h>

int open(const char *pathname, int flags, .../*mode_t mode*/);
  \end{lstlisting}
  \begin{itemize}
    \item \texttt{pathname}: Il percorso del file da aprire
    \item \texttt{flags}: I flag per aprire il file, ad esempio:
      \begin{itemize}
        \item \texttt{O\_RDONLY}: Apre il file in sola lettura
        \item \texttt{O\_WRONLY}: Apre il file in sola scrittura
        \item \texttt{O\_RDWR}: Apre il file in lettura/scrittura
        \item \texttt{O\_CREAT}: Crea il file se non esiste
        \item \texttt{O\_APPEND}: Scrive alla fine del file
        \item \texttt{O\_TRUNC}: Se il file esiste, lo svuota
      \end{itemize}
    \item \texttt{mode}: I permessi del file se viene creato, ad esempio:
      \begin{itemize}
        \item \texttt{S\_IRUSR}: Permesso di lettura per l'utente
        \item \texttt{S\_IWGRP}: Permesso di scrittura per il gruppo
        \item \texttt{S\_IXOTH}: Permesso di esecuzione per gli altri
      \end{itemize}
  \end{itemize}

\item Legge da un file aperto e scrive i dati letti in un buffer. Ritorna il numero
  di byte letti, 0 se è arrivato alla fine del file, -1 se c'è stato un errore
  \begin{lstlisting}[language=C]
#include <unistd.h>

ssize_t read(int fd, void *buf, size_t count);
  \end{lstlisting}
  \begin{itemize}
    \item \texttt{fd}: Il file descriptor del file da leggere
    \item \texttt{buf}: L'indirizzo di memoria in cui scrivere i dati letti
    \item \texttt{count}: Il numero di byte da leggere
  \end{itemize}

\item Scrive su un file aperto i dati contenuti in un buffer. Ritorna il numero di
  byte scritti, -1 se c'è stato un errore
  \begin{lstlisting}[language=C]
#include <unistd.h>

ssize_t write(int fd, const void *buf, size_t count);
  \end{lstlisting}
  \begin{itemize}
    \item \texttt{fd}: Il file descriptor del file su cui scrivere
    \item \texttt{buf}: L'indirizzo di memoria da cui leggere i dati da scrivere
    \item \texttt{count}: Il numero di byte da scrivere
  \end{itemize}

\item Sposta il cursore di lettura/scrittura del file al byte specificato. Ritorna
  la nuova posizione del cursore, -1 se c'è stato un errore
  \begin{lstlisting}[language=C]
#include <unistd.h>

off\_t lseek(int fd, off\_t offset, int whence);
  \end{lstlisting}
  \begin{itemize}
    \item \texttt{fd}: Il file descriptor del file su cui spostare il cursore
    \item \texttt{offset}: Il numero di byte da spostare il cursore
    \item \texttt{whence}: Da dove iniziare a spostare il cursore, ad esempio:
      \begin{itemize}
        \item \texttt{SEEK\_SET}: Inizia dall'inizio del file
        \item \texttt{SEEK\_CUR}: Inizia dalla posizione corrente
        \item \texttt{SEEK\_END}: Inizia dalla fine del file
      \end{itemize}
  \end{itemize}

\item Chiude il file descriptor specificato. Ritorna 0 se va a buon fine, -1 se c'è
  stato un errore
  \begin{lstlisting}[language=C]
#include <unistd.h>

int close(int fd);
  \end{lstlisting}
  \begin{itemize}
    \item \texttt{fd}: Il file descriptor del file da chiudere
  \end{itemize}

\item Rimuove un "link" dal file specificato, se è l'ultimo link al file, il file
  viene rimosso. Ritorna 0 se va a buon fine, -1 se c'è stato un errore
  \begin{lstlisting}[language=C]
#include <unistd.h>

int unlink(const char *pathname);
  \end{lstlisting}
  \begin{itemize}
    \item \texttt{pathname}: Il percorso del file da rimuovere
  \end{itemize}
  (non può rimuovere le directory)

\end{itemize}

\section{Sistema Operativo}
Il \textbf{sistema operativo} è il livello del software che si pone tra l'hardware
e gli utenti. E quindi il sistema operativo incapsula la macchina fisica.
Per mettere in comunicazione l'utente e l'hardware solitamente si usano le 
\textbf{applicazioni}, ma quando si vuole accedere direttamente all'hardware
si usano le interfacce utente, ad esempio:
\begin{enumerate}
  \item \textbf{Interfaccia grafica} (GUI)
  \item \textbf{Command line} (Terminale o Shell)
  \item \textbf{Touch screen}
\end{enumerate}
\noindent
Gli obiettivi principali sono:
\begin{itemize}
  \item Facilitare l'uso del computer
  \item Rendere efficiente l'utilizzo dell'hardware
  \item Evitare conflitti nell'allocazione delle risorse hardware e software
\end{itemize}
Questo rimuove la necessità di conoscere la struttura dell'hardware attraverso l'
\textbf{astrazione} facilitando la programmazione.

\subsection{Compiti del sistema operativo}
\subsubsection{Gestione delle risorse}
Il sistema operativo deve gestire le risorse hardware, come ad esempio i dischi, la memoria,
gli input/output e la CPU. Deve anche gestire le risorse software, come ad esempio i file,
i programmi e la memoria virtuale.

\subsubsection{Programma di controllo}
Un altro compito del sistema operativo è quello di controllare l'esecuzione dei programmi
e del corretto utilizzo del sistema.

\subsection{Interrupt}
Un \textbf{interrupt} è un segnale hardware che interrompe il normale flusso di esecuzione
di un programma. Gli interrupt possono essere generati da:
\begin{itemize}
  \item \textbf{Hardware}: Per esempio quando un dispositivo ha finito un'operazione
  \item \textbf{Software}: Per esempio quando un programma chiama una system call
\end{itemize}
Questo serve per permettere alla CPU di lavorare per più tempo.

\subsubsection{Operazioni input/output}
Per gestire gli input/output
ad esempio si usano i \textbf{device driver} che sono programmi che permettono di
programmare la periferica per comunicare con il sistema operativo. Finchè il dispositivo
non ha finito l'operazione, la CPU esegue altri processi e quando riceve l'interrupt
dal dispositivo che segnala la fine dell'operazione, la CPU interrompe il processo
corrente e inizia a gestire l'interrupt.

\begin{itemize}
  \item \textbf{Buffering}: Sovrapposizione di CPU e I/O dello \textbf{stesso} processo
  \item \textbf{Spooling}: Sovrapposizione di CPU e I/O di \textbf{diversi} processi
\end{itemize}
Lo spooling serve quando l'elaborazione dei dati letti da un processo è più veloce
della lettura stessa, quindi si avrebbero dei tempi morti rimossi con lo spooling che
permette di elaborare i dati, già pronti, letti da un altro processo.

\subsection{Multiprogrammazione}
È la possibilità di tenere caricati in memoria più programmi e di eseguirli in modo
alternato. Questo permette di sfruttare al meglio la CPU e di ridurre i tempi morti
dovuti all'I/O.
\begin{figure}[H]
  \centering
  \begin{tikzpicture}
    \node[above left] at (0,0) {CPU};
    \node[below left] at (0,0) {I/O};
    \node[right] at (6.7,0) {Sequenziale};

    \draw (0,0) rectangle ++(1,0.5) node[midway] {$P_1$};
    \draw (1,0) rectangle ++(1.5,-0.5) node[midway] {$P_1$};
    \draw (2.5,0) rectangle ++(0.5,0.5) node[midway] {$P_1$};

    \draw (3,0) rectangle ++(1.3,0.5) node[midway] {$P_2$};
    \draw (4.3,0) rectangle ++(1.5,-0.5) node[midway] {$P_2$};
    \draw (5.7,0) rectangle ++(0.5,0.5) node[midway] {$P_2$};
  \end{tikzpicture}
  \caption{Senza multiprogrammazione}
\end{figure}
\begin{figure}[H]
  \centering
  \begin{tikzpicture}
    \node[above left] at (0,0) {CPU};
    \node[below left] at (0,0) {I/O};
    \node[right] at (5.5,0) {Multiprogrammato};

    \draw (0,0) rectangle ++(1,0.5) node[midway] {$P_1$};
    \draw (1,0) rectangle ++(1.5,-0.5) node[midway] {$P_1$};
    \draw (2.5,0) rectangle ++(0.5,0.5) node[midway] {$P_1$};

    \draw (1,0) rectangle ++(1.3,0.5) node[midway] {$P_2$};
    \draw (2.5,0) rectangle ++(1.5,-0.5) node[midway] {$P_2$};
    \draw (4,0) rectangle ++(0.5,0.5) node[midway] {$P_2$};
  \end{tikzpicture}
  \caption{Con multiprogrammazione}
\end{figure}
\noindent
Per eseguire più programmi alla volta, non soltanto quando un programma è in attesa
di I/O, si utilizza il concetto di \textbf{time sharing} che permette di eseguire
più programmi in modo alternato ad intervalli di tempo molto brevi chiamati \textbf{
quanto di tempo} creando l'impressione che i programmi vengano eseguiti in parallelo.

\vspace{1em}
\noindent
Quando si hanno tanti processi che concorrono per l'utilizzo della CPU bisogna implementare
delle regole per decidere quale processo eseguire. Queste regole sono definite dal
sistema operativo, nello specifico dallo \textbf{scheduler}.

\subsection{Protezione}
La possibilità di eseguire più processi contemporaneamente crea dei problemi, come ad
esempio la possibilità che un processo possa accedere ad un'altra area di memoria di
un altro processo. Per evitare questo si usano delle tecniche di \textbf{protezione}:
\begin{itemize}
  \item \textbf{Protezione I/O}: Programmi diversi non devono usare I/O contemporaneamente
  \item \textbf{Protezione della memoria}: Un processo non può leggere o scrivere in un'area di
    memoria che non gli appartiene
  \item \textbf{Protezione della CPU}: Un processo non può usare la CPU per più tempo di quello
    che gli è stato assegnato
\end{itemize}
In generale la protezione è realizzata tramite il meccanismo della \textbf{modalità duale}
di esecuzione:
\begin{itemize}
  \item \textbf{Modalità utente}: Il programma viene eseguito in modo normale, senza accesso
    alle risorse hardware
  \item \textbf{Modalità kernel}: Il programma viene eseguito con privilegi speciali
    che permettono di accedere all'hardware
\end{itemize}

\subsubsection{Protezione I/O}
Quando un processo vuole usare un dispositivo I/O, deve passare per il \textbf{device
driver} che esegue le operazioni di I/O in modalità \textbf{supervisor} (o kernel mode).
Questo viene fatto attraverso una \textbf{system call}, cioè un interrupt software
che permette di passare dalla modalità utente alla modalità kernel per
esequire operazioni privilegiate. Al termine della system call si ritorna in modalità
utente.

\subsubsection{Protezione della memoria}
Per proteggere la memoria si devono imporre dei limiti di accesso alla memoria ai processi.
Il sistema operativo tiene traccia di questi limiti e li controlla ad ogni accesso alla 
memoria. 

\subsubsection{Protezione della CPU}
Per proteggere la CPU bisogna garantire che il sistema operativo abbia sempre il controllo
su di essa per poter interrompere qualsiasi processo che non restituisca il controllo
della CPU. Per fare ciò si usano i \textbf{timer} che interrompono il processo se
viene eseguito per troppo tempo.

\subsection{Tipi di sistema operativo}
Esistono diversi tipi di sistemi operativi che si differenziano e si classificano sulla
base di determinate architetture di calcolo e determinati scopi. I principali tipi sono:
\begin{itemize}
  \item \textbf{S.O. per PC e workstation}: Uso personale dell'elaboratore
  \item \textbf{S.O. di rete}: Separazione logica delle risorse remote e locali
  \item \textbf{S.O. distribuiti}: Non c'è la separazione logica tra risorse remote e
    locali, quindi l'accesso alle risorse remote viene effettuato nello stesso modo
    di quello alle risorse locali
  \item \textbf{S.O. real-time}: Vincoli sui tempi di risposta del sistema
  \item \textbf{S.O. embedded}: Per dispositivi con risorse limitate
\end{itemize}

\section{Componenti di un sistema operativo}
Le componenti principali di un sistema operativo sono:
\begin{itemize}
  \item \textbf{Gestione dei processi}
  \item \textbf{Gestione della memoria primaria} (RAM): Spazio dei processi
  \item \textbf{Gestione della memoria secondaria} (Memoria di massa): Spazio dei
    programmi e dei dati
  \item \textbf{Gestione dell'I/O}
  \item \textbf{Gestione dei file}
  \item \textbf{Protezione}
  \item \textbf{Rete}
  \item \textbf{Interprete dei comandi}
\end{itemize}

\subsection{Gestione dei processi}
Un processo è l'istanza di un programma in esecuzione. Ogni processo ha bisogno di
risorse per poter essere eseguito, come ad esempio la CPU, la memoria, i file e i
dispositivi I/O. Il sistema operativo deve gestire i processi e assegnare le risorse per
garantire che i processi vengano eseguiti in modo corretto e senza conflitti e deve
gestire anche se stesso perchè anche il sistema operativo è un'insieme di processi in
modalità kernel.

\vspace{1em}
\noindent
Il sistema operativo è responsabile della:
\begin{itemize}
  \item \textbf{Creazione e distruzione di processi}: Creare un processo significa
    allocare le risorse necessarie e inizializzare le strutture dati del processo;
    distruggere un processo significa rilasciare le risorse e liberare la memoria

  \item \textbf{Sospensione e riesumazione di processi}: Un processo viene sospeso
    quando deve aspettare un evento, come ad esempio un I/O

  \item \textbf{Sincronizzazione e comunicazione tra processi}: I processi devono
    poter comunicare tra di loro e sincronizzarsi per evitare conflitti
\end{itemize}

\subsection{Gestione della memoria primaria}
Un programma deve essere caricato in memoria per essere eseguito e nella RAM sono anche
presenti dati condivisi tra CPU e dispositivi I/O.

\vspace{1em}
\noindent
Il sistema operativo è responsabile di:
\begin{itemize}
  \item \textbf{Gestire lo spazio di memoria}: Decide quali parti della memoria allocare
    e a quali processi assegnarla

  \item \textbf{Decidere quale processo caricare in memoria quando esiste spazio disponibile}

  \item \textbf{Gestire l'allocazione e il rilascio dello spazio di memoria}
\end{itemize}

\subsection{Gestione della memoria secondaria}
La memoria secondaria è usata per memorizzare programmi e dati che non possono stare
nella memoria primaria e per mantenere grandi quantità di dati in modo permanente. Il
sistema operativo deve gestire l'ottimizzazione dell'uso della memoria secondaria.

\vspace{1em}
\noindent
Il sistema operativo è responsabile di:
\begin{itemize}
  \item \textbf{Gestire lo spazio sulla memoria di massa}

  \item \textbf{Allocare spazio su memoria di massa}

  \item \textbf{Ordinare gli accessi ai dispositivi}
\end{itemize}

\subsection{Gestione dell'I/O}
Il sistema operativo deve creare un livello software che permetta all'utente di usare
le periferiche senza doverne capire le caratteristiche fisiche.

\vspace{1em}
\noindent
Il sistema di I/O consiste di:
\begin{itemize}
  \item \textbf{Sistema per accumulare gli accessi ai dispositivi}: Buffering, cioè
    l'accumulo di dati in memoria prima di essere scritti o letti dal dispositivo

  \item \textbf{Generica interfaccia verso i device driver}

  \item \textbf{Device driver specifici per alcuni dispositivi}
\end{itemize}

\subsection{Gestione dei file}
I file servono per memorizzare informazioni su supporti fisici diversi controllati da
driver con caratteristiche diverse. Un file è l'\textbf{astrazione logica} per rendere
conveniente l'uso della memoria non volatile e permette di raccogliere informazioni
correlate, come ad esempio dati o programmi.

\vspace{1em}
\noindent
Il sistema operativo è responsabile di:
\begin{itemize}
  \item \textbf{Creare e cancellare file e directory}

  \item \textbf{Fornire primitive per la gestione di file e directory}: Ad esempio
    aprire, leggere, scrivere, chiudere, rinominare, cancellare ecc...

  \item \textbf{Gestire la corrispondnza tra file e spazio fisico su memoria di massa}:
    Bisogna tenere traccia di dove sono memorizzati i file

  \item \textbf{Salvare informazioni a scopo di backup}
\end{itemize}

\subsection{Protezione}
È il meccanismo per controllare l'accesso alle risorse da parte di utenti e processi.

\vspace{1em}
\noindent
Il sistema operativo è responsabile di:
\begin{itemize}
  \item \textbf{Definire accessi autorizzati e non}

  \item \textbf{Definire controlli per gli accessi}

  \item \textbf{Fornire strumenti per verificare le politiche di accesso}
\end{itemize}

\subsection{Rete}
Il sistema operativo deve gestire tutte le risorse di calcolo connesse tramite una rete.

\vspace{1em}
\noindent
Il sistema operativo è responsabile della gestione di:
\begin{itemize}
  \item \textbf{Processi distribuiti}
  \item \textbf{Memoria distribuita}
  \item \textbf{File system distribuito}
\end{itemize}

\subsection{Interprete dei comandi}
L'interprete dei comandi è un programma che permette all'utente di comunicare con il
sistema operativo. L'interprete dei comandi permette di:
\begin{itemize}
  \item \textbf{Creare e gestire processi}
  \item \textbf{Gestire l'I/O}
  \item \textbf{Gestire il disco, la memoria, il file system}
  \item \textbf{Gestire le protezioni}
  \item \textbf{Gestire la rete}
\end{itemize}
Un interprete dei comandi è la \textbf{shell}, che è un programma che legge e interpreta i comandi.

\subsection{System call}
Sono un'interfaccia tra processi e sistema operativo e permettono ai processi di
comunicare con il sistema operativo. Le system call sono chiamate tramite un'istruzione
software e permettono di eseguire operazioni privilegiate. Le possibili opzioni per
comunicare tra sistema operativo e processo sono:
\begin{enumerate}
  \item Passare i parametri della system call tramite registri
  \item Passare i parametri tramite lo stack del programma
    \begin{lstlisting}[language=C]
    // Programma utente
    void main() {
      ...
      A(x);
      ...
    }

    A(int x) {
      ...
      push x;
      _A(); // Vera e propria system call
      ...
    }

    _A() {
      scrivi 13
      TRAP // Interruzione software
      ...
    }
    \end{lstlisting}
    \begin{lstlisting}[language=C]
    // Sistema operativo
    Leggi 13
    Salta al gestore 13

    handler_13() {
      ...
    }
    \end{lstlisting}
  \item Memorizzare i parametri in una tabella in memoria
    \begin{itemize}
      \item L'indirizzo della tabella è passato in un registro o nello stack
    \end{itemize}
    \begin{figure}[H]
      \centering
      \begin{tikzpicture}
        \draw (0,0) rectangle ++(2,3);
        \node[below] at (1,0) {Prog. utente};
        \node at (1,2) {\texttt{syscall(x)}};
        \node[align=center,scale=0.7] (sys) at (1,1) {Carica indirizzo \texttt{x}\\System call \#13};

        \node[draw,minimum width=1.5cm] (x) at (4,3) {$x$};
        \node[above,align=center,scale=0.8] at (x.north) {Indirizzo della tabella\\in memoria};
        \node[below,align=center,scale=0.8] at (x.south) {Registro};

        \draw (6,0) rectangle ++(2,3);
        \draw (6,0.8) rectangle ++(2,1.4);

        \draw (8.2,2.2) -- ++(0.2,0) -- ++(0,-1.4) node[midway,right,align=center,scale=0.8]
          {Codice per\\system call\\\#13} -- ++(-0.2,0);

        \node[align=center,scale=0.8] (call) at (7,1.5) {Usa parametri\\contenuti nella\\tabella con\\indirizzo $x$};
        \node[below] at (7,0) {S.O.};

        \draw[->] (sys.east) -- (x.west);
        \draw[->] (x.east) -- (call.west);
      \end{tikzpicture}
      \caption{Passaggio dei parametri tramite tabella in memoria}
    \end{figure}
\end{enumerate}

\subsection{Programmi di sistema}
I programmi di sistema sono un'interfaccia comoda che ha l'utente delle operazioni che il
sistema operativo può fare tramite le sue system call, ad esempio:
\begin{itemize}
  \item \textbf{Gestione/manipolazione dei file}: Crea, copia, cancella...
  \item \textbf{Informazioni sullo stato del sistema}: Uso della CPU, data, spazio su 
    disco...
  \item \textbf{Strumenti di supporto alla programmazione}: Compilatori, assemblatori,
    editor...
  \item \textbf{Programmi di gestione della rete}: Login remoto, trasferimento file...
  \item \textbf{Formattazione documenti}
  \item \textbf{Mail}
  \item \textbf{Interprete dei comandi}
  \item \textbf{Utility varie}
\end{itemize}

\section{Architettura di un sistema operativo}
\subsection{Tipi di architetture}
\subsubsection{Sistemi monolitici}
I primi tipi di sistema operativo erano \textbf{monolitici}, cioè un unico programma
che gestiva tutte le funzioni del sistema operativo e aveva tutti i componenti allo
stesso livello, di conseguenza non c'era alcuna gerarchia e le funzioni potevano
richiamarsi a vicenda.

\vspace{1em}
\noindent
\textbf{Svantaggi}:
\begin{itemize}
  \item Codice dipendente dall'architettura hardware era distribuito su tutto il sistema
    operativo

  \item Difficile da testare, debuggare ed espandere
\end{itemize}

\noindent
\textbf{Svantaggi}:
\begin{itemize}
  \item Facile da implementare
\end{itemize}

\subsubsection{Sistemi a struttura semplice}
Si è cominciato a dividere il sistema operativo in livelli, implementando così una 
minima struttura gerarchica. Genericamente i livelli erano pochi e in alcuni casi
anche bypassabili. Alcuni esempi di questi sistemi sono:
\begin{itemize}
  \item UNIX
  \item MS-DOS
\end{itemize}

\subsubsection{Sistemi a livelli}
È un sistema operativo con più livelli che ha al livello più alto l'interfaccia utente
e al livello più basso l'hardware. Tra l'utente e l'hardware ci sono diversi livelli
\textbf{strettamente gerarchici} dove ogni livello svolge una funzionalità fornendo
servizi al livello superiore e acquisendo servizi dal livello inferiore.

\vspace{1em}
\noindent
\textbf{Vantaggi}:
\begin{itemize}
  \item Modularità, cioè facilità di sviluppo, test e debug senza impattare gli altri
    livelli
\end{itemize}

\noindent
\textbf{Svantaggi}:
\begin{itemize}
  \item Difficile definire appropriatamente i livelli
  \item Minor efficienza perchè ogni strato aggiunge \textbf{overhead} alle system call,
    cioè tempo di esecuzione aggiuntivo
  \item Minore portabilità, perchè funzionalità dipendenti dall'architettura sono sparse
    su vari livelli
\end{itemize}

\noindent
Questa architettura a livelli crea l'idea di \textbf{macchina virtuale}, cioè
un'astrazione dell'hardware tale da rendere trasparente la presenza di un hadrware 
all'utente.

La macchina virtuale permette di effettuare un \textbf{multiplexing} (moltiplicazione) 
dell'hardware per permettere a più processi di accedere all'hardware contemporaneamente.
\begin{figure}[H]
  \centering
  \begin{tikzpicture}
    \draw (0,0) rectangle ++(1.5,0.6) node[midway] {HW};
    \draw (0,0.6) rectangle ++(1.5,0.6) node[midway] {Kernel};
    \draw (0,1.2) rectangle ++(1.5,2) node[midway] {Processi};
    \node[below,align=center,scale=0.8] at (0.75,0) {Non-Virtual\\Machine};

    \draw (2.5,0) rectangle ++(4.5,0.6) node[midway] {HW};
    \draw (2.5,0.6) rectangle ++(4.5,0.6) node[midway] {Virtual Machine};

    \draw (2.5,1.2) rectangle ++(1.5,0.6) node[midway] {Kernel};
    \draw (4,1.2) rectangle ++(1.5,0.6) node[midway] {Kernel};
    \draw (5.5,1.2) rectangle ++(1.5,0.6) node[midway] {Kernel};

    \draw (2.5,1.8) rectangle ++(1.5,1.4) node[midway] {Processi};
    \draw (4,1.8) rectangle ++(1.5,1.4) node[midway] {Processi};
    \draw (5.5,1.8) rectangle ++(1.5,1.4) node[midway] {Processi};
    \node[below,align=center,scale=0.8] at (4.75,0) {Virtual\\Machine};
  \end{tikzpicture}
  \caption{Differeza tra macchina virtuale e non virtuale}
\end{figure}

\noindent
\textbf{Vantaggi}:
\begin{itemize}
  \item Protezione completa del sistema: ogni VM è isolata dalle altre
  \item Più di un sistema operativo può essere eseguito sulla stessa macchina
  \item Ottimizzazione delle risorse: la stessa macchina può ospitare quello che senza
    VM doveva essere eseguito su macchine separate
  \item Ottime per lo sviluppo di sistemi operativi
  \item Buona portabilità
\end{itemize}

\noindent
\textbf{Svantaggi}:
\begin{itemize}
  \item Problemi di prestazioni
  \item Necessità di gestire dual mode virtuale: il sistema di gestione delle VM esegue
    in kernel mode, ma la VM esegue in user mode
  \item Ogni VM è isolata alle altre, quindi non c'è condivisione di risorse. Una 
    possibile soluzione sarebbe condividere un volume del file system o definire una rete
    virtuale tra VM via software.
\end{itemize}

\subsubsection{Sistemi client-server}
I livelli non sono più gerarchici, ma sono paralleli e comunicano tra di loro tramite
il kernel. Questo permette di avere un sistema operativo più flessibile e modulare.
\begin{figure}[H]
  \centering
  \begin{tikzpicture}
    \draw (0,0) rectangle ++(4,1) node[midway] {Kernel};

    \draw (0,1) rectangle ++(0.3,2);
    \draw (0.5,1) rectangle ++(0.3,2) node[above,scale=0.8,xshift=-0.2cm] {Server};
    \draw (1,1) rectangle ++(0.3,2);


    \draw (4,1) rectangle ++(-0.3,2);
    \draw (3.5,1) rectangle ++(-0.3,2) node[above,scale=0.8,xshift=0.2cm] {Client utente};
    \draw (3,1) rectangle ++(-0.3,2);

    \draw[->,red] (3.35,2.8) -- ++(0,-2.3) -- ++(-0.3,0);
    \draw[<-,red] (0.65,2.8) -- ++(0,-2.3) -- ++(0.3,0);
  \end{tikzpicture}
  \caption{Sistema client-server}
\end{figure}

\section{Programma e processo}
\begin{itemize}
  \item \textbf{Programma}: Un programma è un insieme di istruzioni e di dati contenuti
    in un file. È un'entità statica.
  \item \textbf{Processo}: Un processo è un'istanza di un programma in esecuzione.
    È un'entità dinamica.
\end{itemize}

\subsection{Gestione dei processi}
Un processo è un'\textbf{istanza di un programma in esecuzione} perchè da un programma
si possono creare più processi. Il processo è dinamico perchè è in esecuzione, mentre
invece il programma è statico perchè è solo un insieme di istruzioni.

\noindent
I processi evolvono \textbf{un'istruzione alla volta}, ma in un sistema multiprogrammato
essi evolvono in modo \textbf{concorrente} perchè hanno risorse fisiche e logiche limitate.

\noindent
Un processo è un'\textbf{immagine in memoria} che consiste di:
\begin{itemize}
  \item \textbf{Istruzioni} (Sezione di codice o testo)
    \begin{itemize}
      \item Parte statica del codice
    \end{itemize}

  \item \textbf{Dati} (sezione dati)
    \begin{itemize}
      \item Variabili globali
    \end{itemize}

  \item \textbf{Stack}
    \begin{itemize}
      \item Variabili locali
      \item Chiamate a procedure e parametri
    \end{itemize}

  \item \textbf{Heap}
    \begin{itemize}
      \item Memoria allocata dinamicamente
    \end{itemize}

  \item \textbf{Attributi} rappresentat dal PCB (Process Control Block):
    \begin{itemize}
      \item PID
      \item Stato del processo
      \item Program counter
      \item Valori dei registri
      \item Informazioni sulla memoria (registri limite, tabella pagine)
      \item Informazioni sullo stato dell'I/O (richieste pendenti, file)
      \item Informazioni sull'utilizzo del sistema (CPU)
      \item Informazioni di scheduling (priorità)
    \end{itemize}
\end{itemize}
\begin{figure}[H]
  \centering
  \begin{tikzpicture}
    % Process
    \draw (0,0) rectangle ++(1.5,0.6) node[midway] {Attributi};
    \draw (0,0.6) rectangle ++(1.5,0.6) node[midway] {Codice};
    \draw (0,0.6*2) rectangle ++(1.5,0.6) node[midway] {Heap};
    \draw (0,0.6*3) rectangle ++(1.5,0.6*2);
    \draw (0,0.6*5) rectangle ++(1.5,0.6) node[midway] {Stack};
    \draw (0,0.6*6) rectangle ++(1.5,0.6) node[midway] {Dati};

    \draw[->] (0.75,0.6*5) -- ++(0,-0.3);
    \draw[->] (0.75,0.6*3) -- ++(0,0.3);

    \draw (-0.2,0) -- ++(-0.2,0) -- ++(0,0.6*7)
      node[midway,left] {Immagine} -- ++(0.2,0);

    % Attributes
    \draw (3,0) rectangle ++(3,0.6) node[midway,yshift=0.1cm] {$\vdots$};
    \draw (3,0.6) rectangle ++(3,0.6) node[midway] {List of open files};
    \draw (3,0.6*2) rectangle ++(3,0.6) node[midway] {Memory limits};
    \draw (3,0.6*3) rectangle ++(3,0.6*2) node[midway] {Registers};
    \draw (3,0.6*5) rectangle ++(3,0.6) node[midway] {Program counter};
    \draw (3,0.6*6) rectangle ++(3,0.6) node[midway] {Process number};
    \draw (3,0.6*7) rectangle ++(1.5,0.6*2) node[midway] {Pointer};
    \draw (3+1.5,0.6*7) rectangle ++(1.5,0.6*2) node[midway,align=center] {Process\\state};

    \draw (1.5,0.6) -- (3,0.6*9);
    \draw (1.5,0) -- (3,0);

    \draw (6.2,0) -- ++(0.2,0) -- ++(0,0.6*9)
      node[midway,right] {PCB} -- ++(-0.2,0);
  \end{tikzpicture}
  \caption{Immagine di un processo in memoria}
\end{figure}

\subsubsection{Stati di un processo}
Un processo durante la sua esecuzione può evolvere attraverso diversi stati:
\begin{figure}[H]
  \centering
  \begin{tikzpicture}[node distance=3cm and 2cm,>=stealth',auto, every place/.style={draw}]
    \node [place] (nuovo) [scale=1] {Nuovo};
    \node [place] (pronto) [right of=nuovo, scale=1, align=center] {Pronto};
    \node [place] (attesa) [below right of=pronto, scale=0.8, align=center,xshift=-0.85cm]
      {In attesa};
    \node [place] (exec) [right of=pronto, scale=0.7, align=center] {In\\esecuzione};
    \node [place] (finito) [right of=exec, scale=1, align=center] {Finito};

    \path[->] (nuovo) edge node[scale=0.8,align=center]
      {Ammissione\\nel sistema} (pronto);

    \path[->] (pronto) edge[bend left=20] node[scale=0.8,align=center]
      {Dispatch} (exec);
    \path[<-] (pronto) edge[bend right=20] node[below,scale=0.8,align=center]
      {Time-out} (exec);

    \path[->] (exec) edge node[scale=0.8,align=center]
      {Terminazione} (finito);

    \path[->] (attesa) edge node[scale=0.8,align=center]
      {Completameno\\I/O o evento} (pronto);
    \path[<-] (attesa) edge node[below right,scale=0.8,align=center]
      {Attesa di\\I/O o evento} (exec);

    \path[->,dashed] (pronto) edge[bend left=60] node[scale=0.8,align=center]
      {Terminazione\\forzata} (finito);
  \end{tikzpicture}
  \caption{Stati di un processo}
\end{figure}

\noindent
Il sistema operativo gestisce il passaggio tra gli stati del processo tramite:
\begin{itemize}
  \item \textbf{Scheduler}: Decide quale processo eseguire
  \item \textbf{Dispatcher}: Cambia lo stato del processo che si chiama
    \textbf{context switch}, cioè il salvataggio dello stato del processo corrente
    in memoria (PCB) e il caricamento dello stato del nuovo processo. Il cambio di
    contesto è puro sovraccarico perchè la CPU non fa nulla mentre sta succedendo.
\end{itemize}

\subsubsection{Scheduling}
Lo \textbf{Scheduler} sceglie il processo da eseguire nella CPU al fine di
garantire:
\begin{itemize}
  \item Multiprogrammazione: con l'obiettovo di massimizzare l'uso della CPU
    caricando più di un processo in memoria
  \item Time-sharing: con l'obiettivo di commutare frequentemente la CPU tra
    processi in modo che ognuno creda di avere la CPU tutta per sè
\end{itemize}
Ogni processo è inserito in una serie di \textbf{code di scheduling}:
\begin{itemize}
  \item \textbf{Ready queue}: Coda dei processi pronti ad essere eseguiti
  \item \textbf{Coda di un dispositivo}: Coda dei processi in attesa che il dispositivo
    si liberi
\end{itemize}
Ogni coda ha la propria \textbf{politica di scheduling}.

\vspace{1em}
\noindent
Gli stati di un processo possono anche essere rappresentati come un diagramma di
accodamento:
\begin{figure}[H]
  \centering
  \begin{tikzpicture}

    \node[draw,minimum width=3.5cm,minimum height=0.6cm,align=center] (codaproc)
      at (-5.5,1.5) {Coda dei processi pronti};

    \node[draw,circle,minimum width=0.6cm,minimum height=0.6cm,align=center] (cpu) at
      (1.2,1.5) {CPU};

    \node[draw,minimum width=3.5cm,minimum height=0.6cm,align=center] (richio) at (0,0) 
      {Richiesta di I/O};
    \node[draw,minimum width=2cm,minimum height=0.6cm,align=center] (codaio) at (-4,0) 
      {Coda di I/O};
    \node[draw,circle,minimum width=0.6cm,minimum height=0.6cm,align=center] (io) at
      (-7,0) {I/O};


    \node[draw,minimum width=3.5cm,minimum height=0.6cm,align=center] (tempo) at (0,-1) 
      {Quanto di tempo\\esaurito};

    \node[draw,minimum width=3.5cm,minimum height=0.6cm,align=center] (figlio) at (0,-2.2) 
      {Generazione di un\\processo figlio};
    \node[draw,ellipse,minimum width=0.6cm,minimum height=0.6cm,align=center,scale=0.8]
      (procfiglio) at (-4.5,-2.2) {Processo figlio\\in esecuzione};


    \node[draw,minimum width=3.5cm,minimum height=0.6cm,align=center] (interrupt)
      at (0,-3.4) {Attesa di un\\interrupt};
    \node[draw,ellipse,minimum width=0.6cm,minimum height=0.6cm,align=center,scale=0.8]
      (occint) at (-4.5,-3.4) {Occorrenza\\dell'interruzione};


    \draw[<-] (codaproc.west) ++(0,0.2) -- ++(-1,0);
    \draw[<-] (codaproc.west) ++(0,-0.2) -- ++(-0.8,0) -- ++(0,-4.7);

    \draw[->] (codaproc) -- (cpu);

    \draw[->] (cpu.east) ++(0,0.2) -- ++(1,0);
    \draw (cpu.east) ++(0,-0.2) -- ++(0.5,0) -- ++(0,-4.7);

    \draw[<-] (richio.east) -- ++(0.5,0);
    \draw[<-] (tempo.east) -- ++(0.5,0);
    \draw[<-] (figlio.east) -- ++(0.5,0);
    \draw[<-] (interrupt.east) -- ++(0.5,0);

    \draw[->] (richio) -- (codaio) -- (io);
    \draw (io.west) -- ++(-0.8,0);

    \draw (tempo) -- ++(-8.3,0);

    \draw[->] (figlio) -- (procfiglio);
    \draw (procfiglio.west) -- ++(-2.4,0);

    \draw[->] (interrupt) -- (occint);
    \draw (occint.west) -- ++(-2.25,0);
  \end{tikzpicture}
  \caption{Diagramma di accodamento}
\end{figure}

\subsubsection{Creazione di un processo}
La creazione di un processo avviene per creazione da parte di un altro processo. Quando
un computer viene acceso il primo processo creato è il \textbf{processo init} che è il
padre di tutti i processi. La creazione di un processo avviene tramite la system call
\texttt{fork()} che crea un processo figlio ed esso ottiene
risorse dal sistema operativo o direttamente dal padre per:
\begin{itemize}
  \item \textbf{Spartizione}: Il padre divide le risorse con il figlio
  \item \textbf{Condivisione}: Il padre e il figlio condividono le risorse
\end{itemize}
Un processo può essere eseguito in 2 modalità:
\begin{itemize}
  \item \textbf{Sincrona}: Il padre aspetta che i figlii terminino
  \item \textbf{Asincrona}: Avviene un'evoluzione \textbf{parallela} di padre e figli
\end{itemize}

\vspace{1em}
\noindent
Le system call principali per la creazione di un processo sono:
\begin{itemize}
  \item \texttt{fork()}: Crea un processo figlio che è un duplicato esatto del padre
  \item \texttt{exec()}: Carica sul figlio un programma diverso da quello del padre
  \item \texttt{wait()}: Il padre aspetta che il figlio termini
\end{itemize}

\begin{example}
  Un esempio in C della creazione di un processo figlio è il seguente:
  \begin{lstlisting}[language=C]
#include <stdio.h>
void main(int argc, char *argv[]) {
  int pid;
  pid = fork(); // Genera un nuovo processo

  if (pid < 0) {
    printf("Errore di creazione\n");
    exit(-1);
  } else if (pid == 0) {
    // Codice del processo figlio
    execlp("/bin/ls", "ls", NULL); // Esegue il comando ls
  } else {
    // Codice del processo padre
    wait(NULL); // Aspetta che il figlio termini
    printf("Il figlio ha terminato\n");
    exit(0);
  }
}
  \end{lstlisting}
  Il padre riceve come \texttt{pid} il process id del figlio e il figlio riceve 0.
\end{example}

\subsection{Terminazione di un processo}
Un processo può terminare in diversi modi:
\begin{itemize}
  \item \textbf{Terminazione volontaria}: Il processo termina volontariamente
    perchè ha finito la sua esecuzione

  \item \textbf{Terminazione forzata dal padre}: Il padre decide di terminare il
    processo figlio per più motivi:
    \begin{itemize}
      \item Eccesso nell'uso delle risorse
      \item Il compito richiesto al figlio non è più necessario
      \item Il padre termina e il sistema operaivo termina tutti i processi figli
    \end{itemize}

  \item \textbf{Terminazione forzata dal S.O.}: Il sistema operativo termina il
    processo quando:
    \begin{itemize}
      \item L'utente chiude l'applicazione
      \item Ci sono errori durante l'esecuzione (aritmetici, di protezione, di memoria...)
    \end{itemize}
\end{itemize}

\subsection{Relazione tra processi}
I processi possono essere di due tipi:
\begin{itemize}
  \item \textbf{Processi indipendenti}: Sono processi che dipendono soltanto dal proprio
    input e quindi non influenzano altri processi. L'esecuzione di un processo indipendente
    è deterministica e riproducibile.

  \item \textbf{Processi cooperanti}: Sono processi che influenzano e sono influenzati da
    altri processi. Possono condividere dati e informazioni e possono comunicare tra di
    loro. L'esecuzione di un processo cooperante è non deterministica e non riproducibile.
\end{itemize}

\subsection{Thread}
Un \textbf{thread} è un flusso di esecuzione di un processo. Un processo può avere più
thread e ogni thread lavora in modo indipendente sulle risorse del processo e ad essi
è associato un Thread Control Block (TCB) che serve a memorizzare lo stato del thread.
\begin{itemize}
  \item Ad un processo sono associati:
    \begin{itemize}
      \item Spazio di indirizzamento
      \item Risorse del sistema
    \end{itemize}

  \item Ad ogni singolo thread sono associati:
    \begin{itemize}
      \item Stato di esecuzione
      \item Program counter
      \item Insieme di registri della CPU
      \item Stack
    \end{itemize}
\end{itemize}
I thread condividono le risorse e lo stato del processo e lo spazio di indirizzamento.
Il \textbf{Multithreading} è l'abilità di un sistema operativo di supportare più thread
all'interno di un processo.

\subsubsection{Vantaggi}
I vantaggi del multithreading sono:
\begin{itemize}
  \item \textbf{Riduzione del tempo di risposta}: Un thread può continuare a lavorare
    mentre un altro thread è bloccato
  \item \textbf{Condivisione delle risorse}: I thread condividono le risorse del processo
    senza dover introdurre tecniche esplicite di condivisione come avviene per i processi.
  \item \textbf{Economia}: I thread sono più economici dei processi perchè la loro creazione
    e distruzione e il loro context switch sono più veloci
  \item \textbf{Scalabilità}: Aumenta il parallelismo se l'esecuzione avviene su un
    multiprocessore 
\end{itemize}

\subsubsection{Stati di un thread}
Anche i thread hanno uno stato di esecuzione, come i processi:
\begin{itemize}
  \item \textbf{Pronto}: Il thread è pronto ad essere eseguito
  \item \textbf{In esecuzione}: Il thread è in esecuzione sulla CPU
  \item \textbf{Bloccato}: Il thread è bloccato in attesa di un evento
\end{itemize}
Lo stato di un thread può non coincidere con lo stato del processo.

\subsubsection{Implementazione}
I thread possono essere implementati come:
\begin{itemize}
  \item \textbf{User-level thread}: Sono implementati dal programmatore e la gestione
    è affidata all'applicazione, di conseguenza il kernel ignora l'esistenza dei thread.
    I vantaggi sono:
    \begin{itemize}
      \item Non serve passare alla modalità kernel per la gestione dei thread
      \item Lo scheduling può variare da applicazione ad applicazione
      \item Sono portabili, cioè possono essere implementati su qualsiasi sistema
        operativo senza modificare il kernel
    \end{itemize}
    Gli svantaggi sono:
    \begin{itemize}
      \item Il blocco di un thread blocca l'intero processo
      \item Non è possibile sfruttare i processori multi-core
    \end{itemize}

  \item \textbf{Kernel-level thread}: La gestione è affidata al kernel e le applicazioni
    usano i thread tramite system call.
    I vantaggi sono:
    \begin{itemize}
      \item Scheduling a livello di thread, cioè il blocco di un thread non blocca
        l'intero processo
      \item Più thread possono essere eseguiti in parallelo su processori diversi
      \item Le funzioni del sistema operativo possono essere multithreaded
    \end{itemize}
    Gli svantaggi sono:
    \begin{itemize}
      \item Scarsa efficienza perchè il passaggio da un thread all'altro richiede
        il passaggio attraverso il kernel
    \end{itemize}
\end{itemize}

\subsection{Gestione dei processi del sistema operativo}
Il sistema operativo è un programma come tutti gli altri e quindi può generare più
processi. Il sistema operativo può essere eseguito in diversi modi:
\begin{itemize}
  \item \textbf{Kernel separato}: Il kernel viene eseguito al di fuori da ogni processo:
    \begin{itemize}
      \item Il sistema operativo possiede uno spazio di memoria riservato
      \item Il sistema operativo prende il controllo del sistema
      \item Il sistema operativo è sempre in esecuzione in modo privilegiato
    \end{itemize}
    È un processo che viene applicato soltanto ai processi utente:
    \begin{figure}[H]
      \centering
      \begin{tikzpicture}
        \draw (0,0) rectangle ++(4,1) node[midway] {Kernel};

        \draw (0.25,1) rectangle ++(0.5,0.5) node[midway] {\( p_1 \)};
        \draw (1.25,1) rectangle ++(0.5,0.5) node[midway] {\( p_2 \)};
        \node at (2.45,1.25) {\(\dots\)};
        \draw (3.25,1) rectangle ++(0.5,0.5) node[midway] {\( p_n \)};
      \end{tikzpicture}
      \caption{Kernel separato}
    \end{figure}

  \item \textbf{Kernel in processi utente}: Il kernel è eseguito come un processo
    utente fornendo delle procedure richiamabili da programmi utente in modalità kernel.
    L'immagine dei processi (PCB) deve contenere anche:
    \begin{itemize}
      \item Kernel stack per gestire il funzionamento del processo in modalità protetta
        (chiamate a funzione)
      \item Codice/dati del S.O. condiviso tra processi utente
    \end{itemize}
    \begin{figure}[H]
      \centering
      \begin{tikzpicture}
        \draw (-0.25,0) rectangle ++(4.5,1) node[midway] {Process Switching Functions};

        \draw (0,1) rectangle ++(1,0.8) node[midway,align=center] {OS\\func.};
        \draw (0,1 + 0.8) rectangle ++(1,0.5) node[midway] {\( p_1 \)};

        \draw (1.2,1) rectangle ++(1,0.8) node[midway,align=center] {OS\\func.};
        \draw (1.2,1 + 0.8) rectangle ++(1,0.5) node[midway] {\( p_2 \)};

        \node at (2.57,1.25) {\(\dots\)};

        \draw (3,1) rectangle ++(1,0.8) node[midway,align=center] {OS\\func.};
        \draw (3,1 + 0.8) rectangle ++(1,0.5) node[midway] {\( p_n \)};
      \end{tikzpicture}
      \caption{Kernel in processi utente}
    \end{figure}
    Il vantaggio è che 
    basta cambiare la modalità di esecuzione per passare da utente a kernel
    che è più leggero di un context switch e dopo che il sistema operativo ha
    completato il suo lavoro può decidere se riattivare lo stesso processo
    utente (mode switch) o un altro (context switch)

  \item \textbf{Kernel come processo}: I servizi del sistema operativo sono processi
    individuali che si comportano come qualsiasi altro processo, solo che sono
    eseguiti in modalità kernel e non in modalità utente. Una minima parte del
    sistema operativo deve comunque eseguire al di fuori di tutti i processi (scheduler).
    È vantaggioso per i sistemi multiprocessore perchè i processi possono essere
    eseguiti in parallelo.
    \begin{figure}[H]
      \centering
      \begin{tikzpicture}
        \draw (0,0) rectangle ++(9,1) node[midway] {Kernel};

        \draw (0.25,1) rectangle ++(0.5,0.5) node[midway] {\( p_1 \)};
        \draw (1.25,1) rectangle ++(0.5,0.5) node[midway] {\( p_2 \)};
        \node at (2.45,1.25) {\(\dots\)};
        \draw (3.25,1) rectangle ++(0.5,0.5) node[midway] {\( p_n \)};

        \draw (5,1) rectangle ++(0.5,0.5) node[midway,align=center,scale=0.9] {\( os_1 \)};
        \draw (6,1) rectangle ++(0.5,0.5) node[midway,align=center,scale=0.9] {\( os_2 \)};
        \node at (7.25,1.25) {\(\dots\)};
        \draw (8,1) rectangle ++(0.5,0.5) node[midway,align=center,scale=0.9] {\( os_n \)};
      \end{tikzpicture}
      \caption{Kernel separato}
    \end{figure}
\end{itemize}

\subsubsection{Problematiche}
I problemi principali sono:
\begin{itemize}
  \item Allocazione delle risorse (CPU, memoria, spazio su disco) ai
    processi e ai thread.
  \item Coordinamento tra processi e thread (concorrenti):
    \begin{itemize}
      \item Sincronizzazione
      \item Comunicazione
    \end{itemize}
\end{itemize}

\section{Scheduling}
Lo scheduling dei processi è il processo di selezione del processo da eseguire
sulla CPU nel tempo. Serve perchè con l'utilizzo della multiprogrammazione bisogna
implementare una strategia per regolamentare:
\begin{itemize}
  \item Ammissione dei processi nel sistema (memoria)
  \item Ammissione dei processi all'esecuzione (CPU)
\end{itemize}

\subsection{Tipi di scheduling}
Lo scheduling gestisce in che modo viene ordinato l'accesso ad ogni coda di processi.
Gli scheduler sono di due tipi:
\begin{itemize}
  \item \textbf{Scheduler a lungo termine (job scheduler)}: Seleziona quali processi 
    devono essere portati dalla memoria alla redy queue. Questo scheduler è invocato
    molto spesso.
  \item \textbf{Scheduler a medio termine (swapper)}: Seleziona quali processi
    devono essere spostati dalla memoria al disco e viceversa. Questo scheduler è
    invocato meno frequentemente.
  \item \textbf{Scheduler a breve termine (CPU scheduler)}: Seleziona quale processo
    deve essere eseguito sulla CPU. Questo scheduler è invocato più raramente.
\end{itemize}



% Il sistema operativo fornisce dei servizi per comunicare con l'hardware e questi
% servizi possono essere usati tramite delle \textbf{system calls}, ad esempio:
%
% \begin{itemize}
%   \item Esecuzione dei programmi
%   \item Gestione dei file
%   \item Operazioni I/O
%   \item Gestione degli errori
%   \item Comunicazione
% \end{itemize}
%
% \noindent
% L'unico programma che è sempre in esecuzione su un computer è il \textbf{kernel}.
%
% \subsection{Operazioni}
% \begin{itemize}
%   \item \textbf{Bootstrap program}: è una piccola porzione di codice che inizializza
%     il sistema e carica il kernel
%
%   \item Viene caricato il kernel
%
%   \item Vengono caricati i \textbf{system daemons}, cioè dei servizi forniti al
%     di fuori del kernel
%
%   \item Gestione delle chiamate di sistema:
%     \begin{itemize}
%       \item Hardware interrupt
%       \item Software interrupt
%     \end{itemize}
% \end{itemize}
%
% \noindent
% Su un computer vengono eseguiti più programmi alla volta salvando la coda dei
% processi da eseguire in memoria e lo \textbf{scheduler} si occupa di gestire
% l'ordine di esecuzione e di interruzione. Per permettere di eseguire più processi
% alla volta si utilizza il \textbf{time sharing}, cioè la CPU cambia processo così
% frequentemente che si crea l'illusione che i processi vengano eseguiti in parallelo
% anche se in realtà non è così.
%
% \section{Modalità di esecuzione}
% Il sistema operativo può eseguire il codice in 2 modalità:
% \begin{enumerate}
%   \item \textbf{Modalità utente}: il codice viene eseguito in modo normale
%   \item \textbf{Modalità kernel}: il codice viene eseguito con privilegi speciali
%     che permettono di accedere all'hardware
% \end{enumerate}
%
% \noindent
% Per capire in che modalità si sta eseguendo il codice si utilizza un bit nel
% \textbf{program status word} (PSW) che indica la modalità di esecuzione chiamato
% \textbf{mode bit}.
%
% \noindent Si può entrere in modalità kernel tramite:
% \begin{enumerate}
%   \item \textbf{Nuovo processo}: Per creare un nuovo processo, il kernel copia il
%     programma nella memoria, setta il program counter alla prima istruzione del
%     processo e setta lo stack pointer alla base dello stack del processo e infine
%     si torna in modalità utente. 
%
%     \item \textbf{Ritorno da un interrupt o system call}: Quando il kernel finisce
%       di gestire la richiesta, riprende l'esecuzione del processo che ha chiamato
%       l'interrupt o la system call e torna in modalità utente.
%       
%     \item \textbf{Cambio di contesto}: Quando il kernel decide di cambiare il
%       processo in esecuzione, salva lo stato del processo corrente e carica lo
%       stato del nuovo processo e torna in modalità utente.
% \end{enumerate}
%
% \noindent
% Per prevenire che un processo faccia un ciclo infinito esiste un timer che interrompe
% il processo se viene eseguito per troppo tempo.
%
% \subsection{Protezione e sicurezza}
% \begin{enumerate}
%   \item \textbf{Protezione}: qualsiasi meccanismo per controllare l'accesso dei
%     processi o degli utenti alle risorse del sistema.
%
%   \item \textbf{Sicurezza}: protezione da accessi esterni non autorizzati.
% \end{enumerate}
%
% \noindent
% Ogni utente è identificato da un \textbf{user id} e ogni utente può far parte di
% un gruppo, identificato da un \textbf{group id}. Ogni file ha un \textbf{owner} e
% un \textbf{group owner} e per ogni file ci sono 3 tipi di permessi:
% \begin{enumerate}
%   \item \textbf{Read}
%   \item \textbf{Write}
%   \item \textbf{Execute}
% \end{enumerate}
%
% \section{Linux}
% \subsection{Filesystem}
% In linux qualsiasi cosa è un file, cioè un contenitore di dati. I principali
% tipi di file sono:
% \begin{enumerate}
%   \item \textbf{Regolare}: File classici utente
%   \item \textbf{Directory}: Informazioni relative ad altri file
%   \item \textbf{Pipe}: Comunicazioni tra processi
%   \item \textbf{Link}: Alias
%   \item \textbf{Socket}: Comunicazioni tra processi
%   \item \textbf{Speciale}: Dispositivi
% \end{enumerate}
%
% \noindent Tutti i file sono organizzati in un albero, chiamato \textbf{file system}.
% \begin{enumerate}
%   \item \textbf{root}: La radice del file system: /
%   \item \textbf{nodo}: File (se ha già figli è una directory)
% \end{enumerate}
%
%
\end{document}
