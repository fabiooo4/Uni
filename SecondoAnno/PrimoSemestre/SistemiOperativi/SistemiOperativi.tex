\documentclass[a4paper]{article}
\usepackage{import}
\input{../../../preamble.sty}

\begin{document}

\input{title.tex}

\tableofcontents
\pagebreak

\section{Sistema Operativo}
Il \textbf{sistema operativo} è il livello del software che si pone tra l'hardware
e gli utenti. E quindi il sistema operativo incapsula la macchina fisica.
Per mettere in comunicazione l'utente e l'hardware solitamente si usano le 
\textbf{applicazioni}, ma quando si vuole accedere direttamente all'hardware
si usano le interfacce utente, ad esempio:
\begin{enumerate}
  \item \textbf{Interfaccia grafica} (GUI)
  \item \textbf{Command line} (Terminale o Shell)
  \item \textbf{Touch screen}
\end{enumerate}
\noindent
Gli obiettivi principali sono:
\begin{itemize}
  \item Facilitare l'uso del computer
  \item Rendere efficiente l'utilizzo dell'hardware
  \item Evitare conflitti nell'allocazione delle risorse hardware e software
\end{itemize}
Questo rimuove la necessità di conoscere la struttura dell'hardware attraverso l'
\textbf{astrazione} facilitando la programmazione.

\subsection{Compiti del sistema operativo}
\subsubsection{Gestione delle risorse}
Il sistema operativo deve gestire le risorse hardware, come ad esempio i dischi, la memoria,
gli input/output e la CPU. Deve anche gestire le risorse software, come ad esempio i file,
i programmi e la memoria virtuale.

\subsubsection{Programma di controllo}
Un altro compito del sistema operativo è quello di controllare l'esecuzione dei programmi
e del corretto utilizzo del sistema.

\subsection{Interrupt}
Un \textbf{interrupt} è un segnale hardware che interrompe il normale flusso di esecuzione
di un programma. Gli interrupt possono essere generati da:
\begin{itemize}
  \item \textbf{Hardware}: Per esempio quando un dispositivo ha finito un'operazione
  \item \textbf{Software}: Per esempio quando un programma chiama una system call
\end{itemize}
Questo serve per permettere alla CPU di lavorare per più tempo.

\subsubsection{Operazioni input/output}
Per gestire gli input/output
ad esempio si usano i \textbf{device driver} che sono programmi che permettono di
programmare la periferica per comunicare con il sistema operativo. Finchè il dispositivo
non ha finito l'operazione, la CPU esegue altri processi e quando riceve l'interrupt
dal dispositivo che segnala la fine dell'operazione, la CPU interrompe il processo
corrente e inizia a gestire l'interrupt.

\begin{itemize}
  \item \textbf{Buffering}: Sovrapposizione di CPU e I/O dello \textbf{stesso} processo
  \item \textbf{Spooling}: Sovrapposizione di CPU e I/O di \textbf{diversi} processi
\end{itemize}
Lo spooling serve quando l'elaborazione dei dati letti da un processo è più veloce
della lettura stessa, quindi si avrebbero dei tempi morti rimossi con lo spooling che
permette di elaborare i dati, già pronti, letti da un altro processo.

\subsection{Multiprogrammazione}
È la possibilità di tenere caricati in memoria più programmi e di eseguirli in modo
alternato. Questo permette di sfruttare al meglio la CPU e di ridurre i tempi morti
dovuti all'I/O.
\begin{figure}[H]
  \centering
  \begin{tikzpicture}
    \node[above left] at (0,0) {CPU};
    \node[below left] at (0,0) {I/O};
    \node[right] at (6.7,0) {Sequenziale};

    \draw (0,0) rectangle ++(1,0.5) node[midway] {$P_1$};
    \draw (1,0) rectangle ++(1.5,-0.5) node[midway] {$P_1$};
    \draw (2.5,0) rectangle ++(0.5,0.5) node[midway] {$P_1$};

    \draw (3,0) rectangle ++(1.3,0.5) node[midway] {$P_2$};
    \draw (4.3,0) rectangle ++(1.5,-0.5) node[midway] {$P_2$};
    \draw (5.7,0) rectangle ++(0.5,0.5) node[midway] {$P_2$};
  \end{tikzpicture}
  \caption{Senza multiprogrammazione}
\end{figure}
\begin{figure}[H]
  \centering
  \begin{tikzpicture}
    \node[above left] at (0,0) {CPU};
    \node[below left] at (0,0) {I/O};
    \node[right] at (5.5,0) {Multiprogrammato};

    \draw (0,0) rectangle ++(1,0.5) node[midway] {$P_1$};
    \draw (1,0) rectangle ++(1.5,-0.5) node[midway] {$P_1$};
    \draw (2.5,0) rectangle ++(0.5,0.5) node[midway] {$P_1$};

    \draw (1,0) rectangle ++(1.3,0.5) node[midway] {$P_2$};
    \draw (2.5,0) rectangle ++(1.5,-0.5) node[midway] {$P_2$};
    \draw (4,0) rectangle ++(0.5,0.5) node[midway] {$P_2$};
  \end{tikzpicture}
  \caption{Con multiprogrammazione}
\end{figure}
\noindent
Per eseguire più programmi alla volta, non soltanto quando un programma è in attesa
di I/O, si utilizza il concetto di \textbf{time sharing} che permette di eseguire
più programmi in modo alternato ad intervalli di tempo molto brevi chiamati \textbf{
quanto di tempo} creando l'impressione che i programmi vengano eseguiti in parallelo.

\vspace{1em}
\noindent
Quando si hanno tanti processi che concorrono per l'utilizzo della CPU bisogna implementare
delle regole per decidere quale processo eseguire. Queste regole sono definite dal
sistema operativo, nello specifico dallo \textbf{scheduler}.

\subsection{Protezione}
La possibilità di eseguire più processi contemporaneamente crea dei problemi, come ad
esempio la possibilità che un processo possa accedere ad un'altra area di memoria di
un altro processo. Per evitare questo si usano delle tecniche di \textbf{protezione}:
\begin{itemize}
  \item \textbf{Protezione I/O}: Programmi diversi non devono usare I/O contemporaneamente
  \item \textbf{Protezione della memoria}: Un processo non può leggere o scrivere in un'area di
    memoria che non gli appartiene
  \item \textbf{Protezione della CPU}: Un processo non può usare la CPU per più tempo di quello
    che gli è stato assegnato
\end{itemize}
In generale la protezione è realizzata tramite il meccanismo della \textbf{modalità duale}
di esecuzione:
\begin{itemize}
  \item \textbf{Modalità utente}: Il programma viene eseguito in modo normale, senza accesso
    alle risorse hardware
  \item \textbf{Modalità kernel}: Il programma viene eseguito con privilegi speciali
    che permettono di accedere all'hardware
\end{itemize}

\subsubsection{Protezione I/O}
Quando un processo vuole usare un dispositivo I/O, deve passare per il \textbf{device
driver} che esegue le operazioni di I/O in modalità \textbf{supervisor} (o kernel mode).
Questo viene fatto attraverso una \textbf{system call}, cioè un interrupt software
che permette di passare dalla modalità utente alla modalità kernel per
esequire operazioni privilegiate. Al termine della system call si ritorna in modalità
utente.

\subsubsection{Protezione della memoria}
Per proteggere la memoria si devono imporre dei limiti di accesso alla memoria ai processi.
Il sistema operativo tiene traccia di questi limiti e li controlla ad ogni accesso alla 
memoria. 

\subsubsection{Protezione della CPU}
Per proteggere la CPU bisogna garantire che il sistema operativo abbia sempre il controllo
su di essa per poter interrompere qualsiasi processo che non restituisca il controllo
della CPU. Per fare ciò si usano i \textbf{timer} che interrompono il processo se
viene eseguito per troppo tempo.

\subsection{Tipi di sistema operativo}
Esistono diversi tipi di sistemi operativi che si differenziano e si classificano sulla
base di determinate architetture di calcolo e determinati scopi. I principali tipi sono:
\begin{itemize}
  \item \textbf{S.O. per PC e workstation}: Uso personale dell'elaboratore
  \item \textbf{S.O. di rete}: Separazione logica delle risorse remote e locali
  \item \textbf{S.O. distribuiti}: Non c'è la separazione logica tra risorse remote e
    locali, quindi l'accesso alle risorse remote viene effettuato nello stesso modo
    di quello alle risorse locali
  \item \textbf{S.O. real-time}: Vincoli sui tempi di risposta del sistema
  \item \textbf{S.O. embedded}: Per dispositivi con risorse limitate
\end{itemize}

\section{Componenti di un sistema operativo}
Le componenti principali di un sistema operativo sono:
\begin{itemize}
  \item \textbf{Gestione dei processi}
  \item \textbf{Gestione della memoria primaria} (RAM): Spazio dei processi
  \item \textbf{Gestione della memoria secondaria} (Memoria di massa): Spazio dei
    programmi e dei dati
  \item \textbf{Gestione dell'I/O}
  \item \textbf{Gestione dei file}
  \item \textbf{Protezione}
  \item \textbf{Rete}
  \item \textbf{Interprete dei comandi}
\end{itemize}

\subsection{Gestione dei processi}
Un processo è l'istanza di un programma in esecuzione. Ogni processo ha bisogno di
risorse per poter essere eseguito, come ad esempio la CPU, la memoria, i file e i
dispositivi I/O. Il sistema operativo deve gestire i processi e assegnare le risorse per
garantire che i processi vengano eseguiti in modo corretto e senza conflitti e deve
gestire anche se stesso perchè anche il sistema operativo è un'insieme di processi in
modalità kernel.

\vspace{1em}
\noindent
Il sistema operativo è responsabile della:
\begin{itemize}
  \item \textbf{Creazione e distruzione di processi}: Creare un processo significa
    allocare le risorse necessarie e inizializzare le strutture dati del processo;
    distruggere un processo significa rilasciare le risorse e liberare la memoria

  \item \textbf{Sospensione e riesumazione di processi}: Un processo viene sospeso
    quando deve aspettare un evento, come ad esempio un I/O

  \item \textbf{Sincronizzazione e comunicazione tra processi}: I processi devono
    poter comunicare tra di loro e sincronizzarsi per evitare conflitti
\end{itemize}

\subsection{Gestione della memoria primaria}
Un programma deve essere caricato in memoria per essere eseguito e nella RAM sono anche
presenti dati condivisi tra CPU e dispositivi I/O.

\vspace{1em}
\noindent
Il sistema operativo è responsabile di:
\begin{itemize}
  \item \textbf{Gestire lo spazio di memoria}: Decide quali parti della memoria allocare
    e a quali processi assegnarla

  \item \textbf{Decidere quale processo caricare in memoria quando esiste spazio disponibile}

  \item \textbf{Gestire l'allocazione e il rilascio dello spazio di memoria}
\end{itemize}

\subsection{Gestione della memoria secondaria}
La memoria secondaria è usata per memorizzare programmi e dati che non possono stare
nella memoria primaria e per mantenere grandi quantità di dati in modo permanente. Il
sistema operativo deve gestire l'ottimizzazione dell'uso della memoria secondaria.

\vspace{1em}
\noindent
Il sistema operativo è responsabile di:
\begin{itemize}
  \item \textbf{Gestire lo spazio sulla memoria di massa}

  \item \textbf{Allocare spazio su memoria di massa}

  \item \textbf{Ordinare gli accessi ai dispositivi}
\end{itemize}

\subsection{Gestione dell'I/O}
Il sistema operativo deve creare un livello software che permetta all'utente di usare
le periferiche senza doverne capire le caratteristiche fisiche.

\vspace{1em}
\noindent
Il sistema di I/O consiste di:
\begin{itemize}
  \item \textbf{Sistema per accumulare gli accessi ai dispositivi}: Buffering, cioè
    l'accumulo di dati in memoria prima di essere scritti o letti dal dispositivo

  \item \textbf{Generica interfaccia verso i device driver}

  \item \textbf{Device driver specifici per alcuni dispositivi}
\end{itemize}

\subsection{Gestione dei file}
I file servono per memorizzare informazioni su supporti fisici diversi controllati da
driver con caratteristiche diverse. Un file è l'\textbf{astrazione logica} per rendere
conveniente l'uso della memoria non volatile e permette di raccogliere informazioni
correlate, come ad esempio dati o programmi.

\vspace{1em}
\noindent
Il sistema operativo è responsabile di:
\begin{itemize}
  \item \textbf{Creare e cancellare file e directory}

  \item \textbf{Fornire primitive per la gestione di file e directory}: Ad esempio
    aprire, leggere, scrivere, chiudere, rinominare, cancellare ecc...

  \item \textbf{Gestire la corrispondnza tra file e spazio fisico su memoria di massa}:
    Bisogna tenere traccia di dove sono memorizzati i file

  \item \textbf{Salvare informazioni a scopo di backup}
\end{itemize}

\subsection{Protezione}
È il meccanismo per controllare l'accesso alle risorse da parte di utenti e processi.

\vspace{1em}
\noindent
Il sistema operativo è responsabile di:
\begin{itemize}
  \item \textbf{Definire accessi autorizzati e non}

  \item \textbf{Definire controlli per gli accessi}

  \item \textbf{Fornire strumenti per verificare le politiche di accesso}
\end{itemize}

\subsection{Rete}
Il sistema operativo deve gestire tutte le risorse di calcolo connesse tramite una rete.

\vspace{1em}
\noindent
Il sistema operativo è responsabile della gestione di:
\begin{itemize}
  \item \textbf{Processi distribuiti}
  \item \textbf{Memoria distribuita}
  \item \textbf{File system distribuito}
\end{itemize}

\subsection{Interprete dei comandi}
L'interprete dei comandi è un programma che permette all'utente di comunicare con il
sistema operativo. L'interprete dei comandi permette di:
\begin{itemize}
  \item \textbf{Creare e gestire processi}
  \item \textbf{Gestire l'I/O}
  \item \textbf{Gestire il disco, la memoria, il file system}
  \item \textbf{Gestire le protezioni}
  \item \textbf{Gestire la rete}
\end{itemize}
Un interprete dei comandi è la \textbf{shell}, che è un programma che legge e interpreta i comandi.

\subsection{System call}
Sono un'interfaccia tra processi e sistema operativo e permettono ai processi di
comunicare con il sistema operativo. Le system call sono chiamate tramite un'istruzione
software e permettono di eseguire operazioni privilegiate. Le possibili opzioni per
comunicare tra sistema operativo e processo sono:
\begin{enumerate}
  \item Passare i parametri della system call tramite registri
  \item Passare i parametri tramite lo stack del programma
    \begin{lstlisting}[language=C]
    // Programma utente
    void main() {
      ...
      A(x);
      ...
    }

    A(int x) {
      ...
      push x;
      _A(); // Vera e propria system call
      ...
    }

    _A() {
      scrivi 13
      TRAP // Interruzione software
      ...
    }
    \end{lstlisting}
    \begin{lstlisting}[language=C]
    // Sistema operativo
    Leggi 13
    Salta al gestore 13

    handler_13() {
      ...
    }
    \end{lstlisting}
  \item Memorizzare i parametri in una tabella in memoria
    \begin{itemize}
      \item L'indirizzo della tabella è passato in un registro o nello stack
    \end{itemize}
    \begin{figure}[H]
      \centering
      \begin{tikzpicture}
        \draw (0,0) rectangle ++(2,3);
        \node[below] at (1,0) {Prog. utente};
        \node at (1,2) {\texttt{syscall(x)}};
        \node[align=center,scale=0.7] (sys) at (1,1) {Carica indirizzo \texttt{x}\\System call \#13};

        \node[draw,minimum width=1.5cm] (x) at (4,3) {$x$};
        \node[above,align=center,scale=0.8] at (x.north) {Indirizzo della tabella\\in memoria};
        \node[below,align=center,scale=0.8] at (x.south) {Registro};

        \draw (6,0) rectangle ++(2,3);
        \draw (6,0.8) rectangle ++(2,1.4);

        \draw (8.2,2.2) -- ++(0.2,0) -- ++(0,-1.4) node[midway,right,align=center,scale=0.8]
          {Codice per\\system call\\\#13} -- ++(-0.2,0);

        \node[align=center,scale=0.8] (call) at (7,1.5) {Usa parametri\\contenuti nella\\tabella con\\indirizzo $x$};
        \node[below] at (7,0) {S.O.};

        \draw[->] (sys.east) -- (x.west);
        \draw[->] (x.east) -- (call.west);
      \end{tikzpicture}
      \caption{Passaggio dei parametri tramite tabella in memoria}
    \end{figure}
\end{enumerate}

\subsection{Programmi di sistema}
I programmi di sistema sono un'interfaccia comoda che ha l'utente delle operazioni che il
sistema operativo può fare tramite le sue system call, ad esempio:
\begin{itemize}
  \item \textbf{Gestione/manipolazione dei file}: Crea, copia, cancella...
  \item \textbf{Informazioni sullo stato del sistema}: Uso della CPU, data, spazio su 
    disco...
  \item \textbf{Strumenti di supporto alla programmazione}: Compilatori, assemblatori,
    editor...
  \item \textbf{Programmi di gestione della rete}: Login remoto, trasferimento file...
  \item \textbf{Formattazione documenti}
  \item \textbf{Mail}
  \item \textbf{Interprete dei comandi}
  \item \textbf{Utility varie}
\end{itemize}

\section{Architettura di un sistema operativo}
\subsection{Tipi di architetture}
\subsubsection{Sistemi monolitici}
I primi tipi di sistema operativo erano \textbf{monolitici}, cioè un unico programma
che gestiva tutte le funzioni del sistema operativo e aveva tutti i componenti allo
stesso livello, di conseguenza non c'era alcuna gerarchia e le funzioni potevano
richiamarsi a vicenda.

\vspace{1em}
\noindent
\textbf{Svantaggi}:
\begin{itemize}
  \item Codice dipendente dall'architettura hardware era distribuito su tutto il sistema
    operativo

  \item Difficile da testare, debuggare ed espandere
\end{itemize}

\noindent
\textbf{Svantaggi}:
\begin{itemize}
  \item Facile da implementare
\end{itemize}

\subsubsection{Sistemi a struttura semplice}
Si è cominciato a dividere il sistema operativo in livelli, implementando così una 
minima struttura gerarchica. Genericamente i livelli erano pochi e in alcuni casi
anche bypassabili. Alcuni esempi di questi sistemi sono:
\begin{itemize}
  \item UNIX
  \item MS-DOS
\end{itemize}

\subsubsection{Sistemi a livelli}
È un sistema operativo con più livelli che ha al livello più alto l'interfaccia utente
e al livello più basso l'hardware. Tra l'utente e l'hardware ci sono diversi livelli
\textbf{strettamente gerarchici} dove ogni livello svolge una funzionalità fornendo
servizi al livello superiore e acquisendo servizi dal livello inferiore.

\vspace{1em}
\noindent
\textbf{Vantaggi}:
\begin{itemize}
  \item Modularità, cioè facilità di sviluppo, test e debug senza impattare gli altri
    livelli
\end{itemize}

\noindent
\textbf{Svantaggi}:
\begin{itemize}
  \item Difficile definire appropriatamente i livelli
  \item Minor efficienza perchè ogni strato aggiunge \textbf{overhead} alle system call,
    cioè tempo di esecuzione aggiuntivo
  \item Minore portabilità, perchè funzionalità dipendenti dall'architettura sono sparse
    su vari livelli
\end{itemize}

\noindent
Questa architettura a livelli crea l'idea di \textbf{macchina virtuale}, cioè
un'astrazione dell'hardware tale da rendere trasparente la presenza di un hadrware 
all'utente.

La macchina virtuale permette di effettuare un \textbf{multiplexing} (moltiplicazione) 
dell'hardware per permettere a più processi di accedere all'hardware contemporaneamente.
\begin{figure}[H]
  \centering
  \begin{tikzpicture}
    \draw (0,0) rectangle ++(1.5,0.6) node[midway] {HW};
    \draw (0,0.6) rectangle ++(1.5,0.6) node[midway] {Kernel};
    \draw (0,1.2) rectangle ++(1.5,2) node[midway] {Processi};
    \node[below,align=center,scale=0.8] at (0.75,0) {Non-Virtual\\Machine};

    \draw (2.5,0) rectangle ++(4.5,0.6) node[midway] {HW};
    \draw (2.5,0.6) rectangle ++(4.5,0.6) node[midway] {Virtual Machine};

    \draw (2.5,1.2) rectangle ++(1.5,0.6) node[midway] {Kernel};
    \draw (4,1.2) rectangle ++(1.5,0.6) node[midway] {Kernel};
    \draw (5.5,1.2) rectangle ++(1.5,0.6) node[midway] {Kernel};

    \draw (2.5,1.8) rectangle ++(1.5,1.4) node[midway] {Processi};
    \draw (4,1.8) rectangle ++(1.5,1.4) node[midway] {Processi};
    \draw (5.5,1.8) rectangle ++(1.5,1.4) node[midway] {Processi};
    \node[below,align=center,scale=0.8] at (4.75,0) {Virtual\\Machine};
  \end{tikzpicture}
  \caption{Differeza tra macchina virtuale e non virtuale}
\end{figure}

\noindent
\textbf{Vantaggi}:
\begin{itemize}
  \item Protezione completa del sistema: ogni VM è isolata dalle altre
  \item Più di un sistema operativo può essere eseguito sulla stessa macchina
  \item Ottimizzazione delle risorse: la stessa macchina può ospitare quello che senza
    VM doveva essere eseguito su macchine separate
  \item Ottime per lo sviluppo di sistemi operativi
  \item Buona portabilità
\end{itemize}

\noindent
\textbf{Svantaggi}:
\begin{itemize}
  \item Problemi di prestazioni
  \item Necessità di gestire dual mode virtuale: il sistema di gestione delle VM esegue
    in kernel mode, ma la VM esegue in user mode
  \item Ogni VM è isolata alle altre, quindi non c'è condivisione di risorse. Una 
    possibile soluzione sarebbe condividere un volume del file system o definire una rete
    virtuale tra VM via software.
\end{itemize}

\subsubsection{Sistemi client-server}
I livelli non sono più gerarchici, ma sono paralleli e comunicano tra di loro tramite
il kernel. Questo permette di avere un sistema operativo più flessibile e modulare.
\begin{figure}[H]
  \centering
  \begin{tikzpicture}
    \draw (0,0) rectangle ++(4,1) node[midway] {Kernel};

    \draw (0,1) rectangle ++(0.3,2);
    \draw (0.5,1) rectangle ++(0.3,2) node[above,scale=0.8,xshift=-0.2cm] {Server};
    \draw (1,1) rectangle ++(0.3,2);


    \draw (4,1) rectangle ++(-0.3,2);
    \draw (3.5,1) rectangle ++(-0.3,2) node[above,scale=0.8,xshift=0.2cm] {Client utente};
    \draw (3,1) rectangle ++(-0.3,2);

    \draw[->,red] (3.35,2.8) -- ++(0,-2.3) -- ++(-0.3,0);
    \draw[<-,red] (0.65,2.8) -- ++(0,-2.3) -- ++(0.3,0);
  \end{tikzpicture}
  \caption{Sistema client-server}
\end{figure}

\subsection{Gestione dei processi}
Un processo è un'\textbf{istanza di un programma in esecuzione} perchè da un programma
si possono creare più processi. Il processo è dinamico perchè è in esecuzione, mentre
invece il programma è statico perchè è solo un insieme di istruzioni.

\noindent
I processi evolvono \textbf{un'istruzione alla volta}, ma in un sistema multiprogrammato
essi evolvono in modo \textbf{concorrente} perchè hanno risorse fisiche e logiche limitate.

\noindent
Un processo è un'\textbf{immagine in memoria} che consiste di:
\begin{itemize}
  \item \textbf{Istruzioni} (Sezione di codice o testo)
    \begin{itemize}
      \item Parte statica del codice
    \end{itemize}

  \item \textbf{Dati} (sezione dati)
    \begin{itemize}
      \item Variabili globali
    \end{itemize}

  \item \textbf{Stack}
    \begin{itemize}
      \item Variabili locali
      \item Chiamate a procedure e parametri
    \end{itemize}

  \item \textbf{Heap}
    \begin{itemize}
      \item Memoria allocata dinamicamente
    \end{itemize}

  \item \textbf{Attributi} rappresentat dal PCB (Process Control Block):
    \begin{itemize}
      \item PID
      \item Stato del processo
      \item Program counter
      \item Valori dei registri
      \item Informazioni sulla memoria (registri limite, tabella pagine)
      \item Informazioni sullo stato dell'I/O (richieste pendenti, file)
      \item Informazioni sull'utilizzo del sistema (CPU)
      \item Informazioni di scheduling (priorità)
    \end{itemize}
\end{itemize}
\begin{figure}[H]
  \centering
  \begin{tikzpicture}
    % Process
    \draw (0,0) rectangle ++(1.5,0.6) node[midway] {Attributi};
    \draw (0,0.6) rectangle ++(1.5,0.6) node[midway] {Codice};
    \draw (0,0.6*2) rectangle ++(1.5,0.6) node[midway] {Heap};
    \draw (0,0.6*3) rectangle ++(1.5,0.6*2);
    \draw (0,0.6*5) rectangle ++(1.5,0.6) node[midway] {Stack};
    \draw (0,0.6*6) rectangle ++(1.5,0.6) node[midway] {Dati};

    \draw[->] (0.75,0.6*5) -- ++(0,-0.3);
    \draw[->] (0.75,0.6*3) -- ++(0,0.3);

    \draw (-0.2,0) -- ++(-0.2,0) -- ++(0,0.6*7)
      node[midway,left] {Immagine} -- ++(0.2,0);

    % Attributes
    \draw (3,0) rectangle ++(3,0.6) node[midway,yshift=0.1cm] {$\vdots$};
    \draw (3,0.6) rectangle ++(3,0.6) node[midway] {List of open files};
    \draw (3,0.6*2) rectangle ++(3,0.6) node[midway] {Memory limits};
    \draw (3,0.6*3) rectangle ++(3,0.6*2) node[midway] {Registers};
    \draw (3,0.6*5) rectangle ++(3,0.6) node[midway] {Program counter};
    \draw (3,0.6*6) rectangle ++(3,0.6) node[midway] {Process number};
    \draw (3,0.6*7) rectangle ++(1.5,0.6*2) node[midway] {Pointer};
    \draw (3+1.5,0.6*7) rectangle ++(1.5,0.6*2) node[midway,align=center] {Process\\state};

    \draw (1.5,0.6) -- (3,0.6*9);
    \draw (1.5,0) -- (3,0);

    \draw (6.2,0) -- ++(0.2,0) -- ++(0,0.6*9)
      node[midway,right] {PCB} -- ++(-0.2,0);
  \end{tikzpicture}
  \caption{Immagine di un processo in memoria}
\end{figure}

\subsubsection{Stati di un processo}
Un processo durante la sua esecuzione può evolvere attraverso diversi stati:
\begin{figure}[H]
  \centering
  \begin{tikzpicture}[node distance=3cm and 2cm,>=stealth',auto, every place/.style={draw}]
    \node [place] (nuovo) [scale=1] {Nuovo};
    \node [place] (pronto) [right of=nuovo, scale=1, align=center] {Pronto};
    \node [place] (attesa) [below right of=pronto, scale=0.8, align=center,xshift=-0.85cm]
      {In attesa};
    \node [place] (exec) [right of=pronto, scale=0.7, align=center] {In\\esecuzione};
    \node [place] (finito) [right of=exec, scale=1, align=center] {Finito};

    \path[->] (nuovo) edge node[scale=0.8,align=center]
      {Ammissione\\nel sistema} (pronto);

    \path[->] (pronto) edge[bend left=20] node[scale=0.8,align=center]
      {Dispatch} (exec);
    \path[<-] (pronto) edge[bend right=20] node[below,scale=0.8,align=center]
      {Time-out} (exec);

    \path[->] (exec) edge node[scale=0.8,align=center]
      {Terminazione} (finito);

    \path[->] (attesa) edge node[scale=0.8,align=center]
      {Completameno\\I/O o evento} (pronto);
    \path[<-] (attesa) edge node[below right,scale=0.8,align=center]
      {Attesa di\\I/O o evento} (exec);

    \path[->,dashed] (pronto) edge[bend left=60] node[scale=0.8,align=center]
      {Terminazione\\forzata} (finito);
  \end{tikzpicture}
  \caption{Stati di un processo}
\end{figure}

\noindent
Il sistema operativo gestisce il passaggio tra gli stati del processo tramite:
\begin{itemize}
  \item \textbf{Scheduler}: Decide quale processo eseguire
  \item \textbf{Dispatcher}: Cambia lo stato del processo che si chiama
    \textbf{context switch}, cioè il salvataggio dello stato del processo corrente
    in memoria (PCB) e il caricamento dello stato del nuovo processo. Il cambio di
    contesto è puro sovraccarico perchè la CPU non fa nulla mentre sta succedendo.
\end{itemize}

\subsubsection{Scheduling}
Lo \textbf{Scheduler} sceglie il processo da eseguire nella CPU al fine di
garantire:
\begin{itemize}
  \item Multiprogrammazione: con l'obiettovo di massimizzare l'uso della CPU
    caricando più di un processo in memoria
  \item Time-sharing: con l'obiettivo di commutare frequentemente la CPU tra
    processi in modo che ognuno creda di avere la CPU tutta per sè
\end{itemize}
Ogni processo è inserito in una serie di \textbf{code di scheduling}:
\begin{itemize}
  \item \textbf{Ready queue}: Coda dei processi pronti ad essere eseguiti
  \item \textbf{Coda di un dispositivo}: Coda dei processi in attesa che il dispositivo
    si liberi
\end{itemize}
Ogni coda ha la propria \textbf{politica di scheduling}.

\vspace{1em}
\noindent
Gli stati di un processo possono anche essere rappresentati come un diagramma di
accodamento:
\begin{figure}[H]
  \centering
  \begin{tikzpicture}

    \node[draw,minimum width=3.5cm,minimum height=0.6cm,align=center] (codaproc)
      at (-5.5,1.5) {Coda dei processi pronti};

    \node[draw,circle,minimum width=0.6cm,minimum height=0.6cm,align=center] (cpu) at
      (1.2,1.5) {CPU};

    \node[draw,minimum width=3.5cm,minimum height=0.6cm,align=center] (richio) at (0,0) 
      {Richiesta di I/O};
    \node[draw,minimum width=2cm,minimum height=0.6cm,align=center] (codaio) at (-4,0) 
      {Coda di I/O};
    \node[draw,circle,minimum width=0.6cm,minimum height=0.6cm,align=center] (io) at
      (-7,0) {I/O};


    \node[draw,minimum width=3.5cm,minimum height=0.6cm,align=center] (tempo) at (0,-1) 
      {Quanto di tempo\\esaurito};

    \node[draw,minimum width=3.5cm,minimum height=0.6cm,align=center] (figlio) at (0,-2.2) 
      {Generazione di un\\processo figlio};
    \node[draw,ellipse,minimum width=0.6cm,minimum height=0.6cm,align=center,scale=0.8]
      (procfiglio) at (-4.5,-2.2) {Processo figlio\\in esecuzione};


    \node[draw,minimum width=3.5cm,minimum height=0.6cm,align=center] (interrupt)
      at (0,-3.4) {Attesa di un\\interrupt};
    \node[draw,ellipse,minimum width=0.6cm,minimum height=0.6cm,align=center,scale=0.8]
      (occint) at (-4.5,-3.4) {Occorrenza\\dell'interruzione};


    \draw[<-] (codaproc.west) ++(0,0.2) -- ++(-1,0);
    \draw[<-] (codaproc.west) ++(0,-0.2) -- ++(-0.8,0) -- ++(0,-4.7);

    \draw[->] (codaproc) -- (cpu);

    \draw[->] (cpu.east) ++(0,0.2) -- ++(1,0);
    \draw (cpu.east) ++(0,-0.2) -- ++(0.5,0) -- ++(0,-4.7);

    \draw[<-] (richio.east) -- ++(0.5,0);
    \draw[<-] (tempo.east) -- ++(0.5,0);
    \draw[<-] (figlio.east) -- ++(0.5,0);
    \draw[<-] (interrupt.east) -- ++(0.5,0);

    \draw[->] (richio) -- (codaio) -- (io);
    \draw (io.west) -- ++(-0.8,0);

    \draw (tempo) -- ++(-8.3,0);

    \draw[->] (figlio) -- (procfiglio);
    \draw (procfiglio.west) -- ++(-2.4,0);

    \draw[->] (interrupt) -- (occint);
    \draw (occint.west) -- ++(-2.25,0);
  \end{tikzpicture}
  \caption{Diagramma di accodamento}
\end{figure}

\subsubsection{Creazione di un processo}
La creazione di un processo avviene per creazione da parte di un altro processo. Quando
un computer viene acceso il primo processo creato è il \textbf{processo init} che è il
padre di tutti i processi. La creazione di un processo avviene tramite la system call
\texttt{fork()} che crea un processo figlio ed esso ottiene
risorse dal sistema operativo o direttamente dal padre per:
\begin{itemize}
  \item \textbf{Spartizione}: Il padre divide le risorse con il figlio
  \item \textbf{Condivisione}: Il padre e il figlio condividono le risorse
\end{itemize}
Un processo può essere eseguito in 2 modalità:
\begin{itemize}
  \item \textbf{Sincrona}: Il padre aspetta che i figlii terminino
  \item \textbf{Asincrona}: Avviene un'evoluzione \textbf{parallela} di padre e figli
\end{itemize}

\vspace{1em}
\noindent
Le system call principali per la creazione di un processo sono:
\begin{itemize}
  \item \texttt{fork()}: Crea un processo figlio che è un duplicato esatto del padre
  \item \texttt{exec()}: Carica sul figlio un programma diverso da quello del padre
  \item \texttt{wait()}: Il padre aspetta che il figlio termini
\end{itemize}

\begin{example}
  Un esempio in C della creazione di un processo figlio è il seguente:
  \begin{lstlisting}[language=C]
#include <stdio.h>
void main(int argc, char *argv[]) {
  int pid;
  pid = fork(); // Genera un nuovo processo

  if (pid < 0) {
    printf("Errore di creazione\n");
    exit(-1);
  } else if (pid == 0) {
    // Codice del processo figlio
    execlp("/bin/ls", "ls", NULL); // Esegue il comando ls
  } else {
    // Codice del processo padre
    wait(NULL); // Aspetta che il figlio termini
    printf("Il figlio ha terminato\n");
    exit(0);
  }
}
  \end{lstlisting}
  Il padre riceve come \texttt{pid} il process id del figlio e il figlio riceve 0.
\end{example}


% Il sistema operativo fornisce dei servizi per comunicare con l'hardware e questi
% servizi possono essere usati tramite delle \textbf{system calls}, ad esempio:
%
% \begin{itemize}
%   \item Esecuzione dei programmi
%   \item Gestione dei file
%   \item Operazioni I/O
%   \item Gestione degli errori
%   \item Comunicazione
% \end{itemize}
%
% \noindent
% L'unico programma che è sempre in esecuzione su un computer è il \textbf{kernel}.
%
% \subsection{Operazioni}
% \begin{itemize}
%   \item \textbf{Bootstrap program}: è una piccola porzione di codice che inizializza
%     il sistema e carica il kernel
%
%   \item Viene caricato il kernel
%
%   \item Vengono caricati i \textbf{system daemons}, cioè dei servizi forniti al
%     di fuori del kernel
%
%   \item Gestione delle chiamate di sistema:
%     \begin{itemize}
%       \item Hardware interrupt
%       \item Software interrupt
%     \end{itemize}
% \end{itemize}
%
% \noindent
% Su un computer vengono eseguiti più programmi alla volta salvando la coda dei
% processi da eseguire in memoria e lo \textbf{scheduler} si occupa di gestire
% l'ordine di esecuzione e di interruzione. Per permettere di eseguire più processi
% alla volta si utilizza il \textbf{time sharing}, cioè la CPU cambia processo così
% frequentemente che si crea l'illusione che i processi vengano eseguiti in parallelo
% anche se in realtà non è così.
%
% \section{Modalità di esecuzione}
% Il sistema operativo può eseguire il codice in 2 modalità:
% \begin{enumerate}
%   \item \textbf{Modalità utente}: il codice viene eseguito in modo normale
%   \item \textbf{Modalità kernel}: il codice viene eseguito con privilegi speciali
%     che permettono di accedere all'hardware
% \end{enumerate}
%
% \noindent
% Per capire in che modalità si sta eseguendo il codice si utilizza un bit nel
% \textbf{program status word} (PSW) che indica la modalità di esecuzione chiamato
% \textbf{mode bit}.
%
% \noindent Si può entrere in modalità kernel tramite:
% \begin{enumerate}
%   \item \textbf{Nuovo processo}: Per creare un nuovo processo, il kernel copia il
%     programma nella memoria, setta il program counter alla prima istruzione del
%     processo e setta lo stack pointer alla base dello stack del processo e infine
%     si torna in modalità utente. 
%
%     \item \textbf{Ritorno da un interrupt o system call}: Quando il kernel finisce
%       di gestire la richiesta, riprende l'esecuzione del processo che ha chiamato
%       l'interrupt o la system call e torna in modalità utente.
%       
%     \item \textbf{Cambio di contesto}: Quando il kernel decide di cambiare il
%       processo in esecuzione, salva lo stato del processo corrente e carica lo
%       stato del nuovo processo e torna in modalità utente.
% \end{enumerate}
%
% \noindent
% Per prevenire che un processo faccia un ciclo infinito esiste un timer che interrompe
% il processo se viene eseguito per troppo tempo.
%
% \subsection{Protezione e sicurezza}
% \begin{enumerate}
%   \item \textbf{Protezione}: qualsiasi meccanismo per controllare l'accesso dei
%     processi o degli utenti alle risorse del sistema.
%
%   \item \textbf{Sicurezza}: protezione da accessi esterni non autorizzati.
% \end{enumerate}
%
% \noindent
% Ogni utente è identificato da un \textbf{user id} e ogni utente può far parte di
% un gruppo, identificato da un \textbf{group id}. Ogni file ha un \textbf{owner} e
% un \textbf{group owner} e per ogni file ci sono 3 tipi di permessi:
% \begin{enumerate}
%   \item \textbf{Read}
%   \item \textbf{Write}
%   \item \textbf{Execute}
% \end{enumerate}
%
% \section{Linux}
% \subsection{Filesystem}
% In linux qualsiasi cosa è un file, cioè un contenitore di dati. I principali
% tipi di file sono:
% \begin{enumerate}
%   \item \textbf{Regolare}: File classici utente
%   \item \textbf{Directory}: Informazioni relative ad altri file
%   \item \textbf{Pipe}: Comunicazioni tra processi
%   \item \textbf{Link}: Alias
%   \item \textbf{Socket}: Comunicazioni tra processi
%   \item \textbf{Speciale}: Dispositivi
% \end{enumerate}
%
% \noindent Tutti i file sono organizzati in un albero, chiamato \textbf{file system}.
% \begin{enumerate}
%   \item \textbf{root}: La radice del file system: /
%   \item \textbf{nodo}: File (se ha già figli è una directory)
% \end{enumerate}
%
%
\end{document}
