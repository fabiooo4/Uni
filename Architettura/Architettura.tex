\documentclass[a4paper]{article}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{textcomp}
\usepackage[italian]{babel}
\usepackage{amsmath, amssymb}
\usepackage{amsfonts}
\usepackage{mdframed}
\usepackage{float}
\usepackage{ntheorem}
\usepackage{xcolor}
\usepackage{graphicx}
\usepackage{tikz}
\graphicspath{{./figures/}}

\usepackage{import}
\usepackage{pdfpages}
\usepackage{transparent}
\usepackage{xcolor}

% Useful definitions frame
\theoremstyle{break}
\theoremheaderfont{\bfseries}
\newmdtheoremenv[%
	linecolor=gray,leftmargin=0,%
	rightmargin=0,
	innertopmargin=8pt,%
	innerbottommargin=8pt,
	ntheorem]{define}{Definizioni utili}[section]

% Example frame
\theoremstyle{break}
\theoremheaderfont{\bfseries}
\newmdtheoremenv[%
	linecolor=gray,leftmargin=0,%
	rightmargin=0,
	innertopmargin=8pt,%
	innerbottommargin=8pt,
	ntheorem]{example}{Esempio}[section]

% Important definition frame
\theoremstyle{break}
\theoremheaderfont{\bfseries}
\newmdtheoremenv[%
	linecolor=gray,leftmargin=0,%
	rightmargin=0,
	backgroundcolor=gray!40,%
	innertopmargin=8pt,%
	innerbottommargin=8pt,
	ntheorem]{definition}{Definizione}[section]

% Exercise frame
\theoremstyle{break}
\theoremheaderfont{\bfseries}
\newmdtheoremenv[%
	linecolor=gray,leftmargin=0,%
	rightmargin=0,
	innertopmargin=8pt,%
	innerbottommargin=8pt,
	ntheorem]{exercise}{Esercizio}[section]

% Theorem frame
\theoremstyle{break}
\theoremheaderfont{\bfseries}
\newmdtheoremenv[%
	linecolor=gray,leftmargin=0,%
	rightmargin=0,
	innertopmargin=8pt,
	innerbottommargin=8pt,
	ntheorem]{theorem}{Teorema}[section]


% figure support
\usepackage{import}
\usepackage{xifthen}
\pdfminorversion=7
\usepackage{pdfpages}
\usepackage{transparent}
\newcommand{\incfig}[1]{%
	\def\svgwidth{\columnwidth}
	\import{./figures/}{#1.pdf_tex}
}

\pdfsuppresswarningpagegroup=1

\begin{document}
\input{title.tex}

\tableofcontents
\pagebreak
\section{Introduzione}
L'informatica è nata per la risoluzione i problemi di calcolo, in particolare
quelli di calcolo numerico. Per questo motivo i primi computer erano macchine
che eseguivano operazioni aritmetiche. Per risolvere questi problemi si usano
degli algoritmi che sono una sequenza di istruzioni semplici che portano poi
a risolvere problemi di complessità variabile. Anche gli algoritmi hanno una
complessità che deve essere adeguata alla risoluzione del problema.

\subsection{Hardware}
Un algoritmo deve essere trasformato in un processo di calcolo automatico,
quindi deve essere implementato tramite hardware. Ci sono due tipi di hardware:
\begin{itemize}
	\item \textbf{Embedded} che è un hardware dedicato ad un singolo compito.
	      Ad esempio il microonde.
	\item \textbf{General purpose} non si sa l'utilizzo finale, quindi ha
	      funzionalità generali ampliate dal software installato. L'hardware
	      general purpose è programmabile attraverso il software. Un esempio
	      è il PC.
\end{itemize}

In base al tipo di hardware l'algoritmo viene implementato in diversi modi:
\begin{itemize}
	\item \textbf{Algoritmo} \( \to  \) \textbf{Software}: Tramite un linguaggio di programmazione
	\item \textbf{Algoritmo} \( \to  \)  \textbf{Hardware embedded}: Tramite linguaggi di basso livello
	      come C, Assembly o il sistema operativo.
	\item \textbf{Algoritmo} \( \to  \)  \textbf{Hardware}: Tramite sintesi logica
\end{itemize}

\subsection{Campionamento dei dati}
Ogni cosa nel mondo è rappresentabile da funzioni continue nel tempo \( f(t) \),
ma con risorse finite è impossibile rappresentare infiniti dati, bisogna quindi
campionarli.

\begin{figure}[h]
	\label{fig:f(t)}
	\centering
	\begin{tikzpicture}[scale=0.6, domain=0:10]
		\coordinate (A) at (0,4);
		\coordinate (B) at (1,4);
		\coordinate (C) at (2,2);
		\coordinate (D) at (3,4);
		\coordinate (E) at (4,1);
		\coordinate (F) at (5,3);
		\coordinate (G) at (6,2);
		\coordinate (H) at (7,4);
		\coordinate (I) at (8,3);
		\coordinate (J) at (9,2);
		\coordinate (K) at (10,5);

		\draw [->] (0,0) -- (10,0) node[right] {$t$};
		\draw [->] (0,0) -- (0,5) node[above] {$f(t)$};

		\draw [gray!50, ultra thin] (0,0) grid (10,5);
		\draw [blue, ultra thick] plot [smooth, tension=1] coordinates { (A) (B) (C) (D) (E) (F) (G) (H) (I) (J) (K) };
		\draw [red, thick ] (A) -- (B) -- (C) -- (D) -- (E) -- (F) -- (G) -- (H) -- (I) -- (J) -- (K);

		\draw [fill] (A) circle [radius=0.1];
		\draw [fill] (B) circle [radius=0.1];
		\draw [fill] (C) circle [radius=0.1];
		\draw [fill] (D) circle [radius=0.1];
		\draw [fill] (E) circle [radius=0.1];
		\draw [fill] (F) circle [radius=0.1];
		\draw [fill] (G) circle [radius=0.1];
		\draw [fill] (H) circle [radius=0.1];
		\draw [fill] (I) circle [radius=0.1];
		\draw [fill] (J) circle [radius=0.1];
		\draw [fill] (K) circle [radius=0.1];

		\draw (0, -0.2) -- (1, -0.2) node[below, xshift=-10] {\( \Delta t \) };
	\end{tikzpicture}
	\caption{Funzione casuale continua nel tempo}
\end{figure}
Per campionare la funzione nella figura \ref{fig:f(t)} bisogna scegliere un intervallo di tempo \( \Delta t \) e prendere
un valore della funzione ogni \( \Delta t \). In questo caso le linee
verticali rappresentano il \textbf{campionamento}, mentre quelle orizzontali
reppresentano la \textbf{discretizzazione o quantizzazione}.
La linea rossa è una spezzata approssimata della funzione continua, infatti
per il teorema di Shannon:

\begin{theorem}
	Deciso il grado di errore da voler compiere, esistono una precisa frequenza di
	campionamento e un intervallo di discretizzazione che garantiscono
	quell'errore.
\end{theorem}
Il sistema di calcolo è ora diventato digitale, cioè elabora i segnali numerici
in ingresso per produrre segnali numerici in uscita.

\begin{figure}[h]
	\centering
	\begin{tikzpicture}
		\node[draw, text=red, align=center] (Realtà fisica) at (0,0) {Realtà\\
			fisica};
		\node[draw, align=center] (Campionamento e discretizzazione) at (2,-1.5) {Campionamento e\\
			discretizzazione};
		\node[draw, text=blue, align=center] (Codifica) at (4,0) {Codifica};
		\node[draw, align=center] (Sistema digitale) at (6,-1.5) {Sistema\\
			digitale};
		\node[draw, text=blue, align=center] (Decodifica) at (8,0) {Decodifica};
		\node[draw, text=red, align=center] (Informazioni) at (9,-1.5) {Informazioni};

		\draw[->,draw] (Realtà fisica) to (Campionamento e discretizzazione);
		\draw[->,draw] (Campionamento e discretizzazione) to (Codifica);
		\draw[->,draw] (Codifica) to (Sistema digitale);
		\draw[->,draw] (Sistema digitale) to (Decodifica);
		\draw[->,draw] (Decodifica) to (Informazioni);
	\end{tikzpicture}
	\caption{Dalla realtà fisica al sistema digitale}
\end{figure}


\section{Sistemi di codifica}
Ogni sistema digitale lavora in base binaria, quindi entrano \( N \)  bit
ed escono \( M \)  bit. I bit in uscita devono essere codificati per
realizzare delle informazioni. Ci sono 2 tipi di informazioni:

\begin{itemize}
	\item \textbf{Informazioni intelleggibili}: sono già chiare agli esseri umani,
	      come un testo scritto.
	\item \textbf{Informazioni non intelleggibili}: hanno bisogno di macchine
	      per essere riprodotte, come le casse per l'audio.
\end{itemize}

\subsection{Codifica di informazioni non numeriche}
Ogni informazione deve avere un codice univoco in modo che il sistema
digitale non possa sbagliare a decodificarla. Date \( M \)  informazioni si
ricavano \( n = log_2{(M)} \)  codici disponibili per rappresentarle.

\begin{example}
	Con \( M=7 \) informazioni:
	\begin{itemize}
		\item \( n=log_2{(7)} \approx 3\; bit \)
		\item \( 2^3=8 \) codici disponibili
	\end{itemize}
\end{example}

\subsection{Numeri interi assoluti}
I numeri interi assoluti rappresentano solo i valori da \( 0 \) a \( 2^n-1 \),
dove \( n \) è il numero di bit disponibile.

La codifica da base decimale a base binaria prende il nome di \textbf{codifica
	a modulo}

\begin{example}
	\label{ex:57modulo}
	Si deve convertire il numero \( 57_{10} \) in base binaria
	\begin{center}
		\( n=log_2{(57)} = 6 \) bit (minimi)\\
		\( \sum_{i=1}^{n-1} 2^n-1 = 63 \) (codici massimi)
	\end{center}
	Si eseguono i seguenti passaggi:
	\begin{enumerate}
		\item Si sottraggono le potenze di 2 partendo da \( n-1 \).
		      \begin{itemize}
			      \item Se la potenza \( 2^i \) è minore o uguale del numero,
			            allora si moltiplica per 1.
			      \item Se la potenza \( 2^i \) è maggiore del numero,
			            allora si moltiplica per 0.
		      \end{itemize}
		\item Le sottrazioni continuano fino a quando si giunge a 0.
	\end{enumerate}
	\(57_{10}-{\textcolor{cyan}{1}}*2^{\textcolor{red}{5}}
		=25_{10}-{\textcolor{cyan}{1}}*2^{\textcolor{red}{4}}
		=9_{10}-{\textcolor{cyan}{1}}*2^{\textcolor{red}{3}}
		=1_{10}-{\textcolor{cyan}{0}}*2^{\textcolor{red}{2}}
		=1_{10}-{\textcolor{cyan}{0}}*2^{\textcolor{red}{1}}
		=1_{10}-{\textcolor{cyan}{1}}*2^{\textcolor{red}{0}}\)
\end{example}

\subsection{Numeri interi relativi}
La codifica più ovvia per i numeri interi relativi è la codifica a
\textbf{modulo + segno}. Tuttavia rappresenta varie problematiche, per cui
si preferisce usare la codifica in \textbf{complemento a 2}.

\subsubsection{Codifica a modulo + segno}
\begin{center}
	Intervallo: \( -2^{n-1} \le N \le 2^{n-1}-1 \)
\end{center}
Il segno si rappresenta con un bit, 0 per il positivo e 1 per il negativo.
Il bit più significativo è il bit del segno, mentre i bit meno significativi
rappresentano il modulo.

\begin{center}
	\begin{tikzpicture}
		\draw[draw] (0, 0) rectangle (2,1) node[pos=.5, align=center] {1 bit:\\
				segno \( \pm \) };
		\draw[draw] (2, 0) rectangle (7,1) node[pos=.5, align=center] {7 bit: modulo};
	\end{tikzpicture}
\end{center}
Considerando l'esempio \ref{ex:57modulo} si hanno le seguenti rappresentazioni:

\begin{center}
	\( +57_{10}=\textbf{0}|111001_2 \)\\
	\( -57_{10}=\textbf{1}|111001_2 \)
\end{center}
Sorge però un problema quando si vuole rappresentare il valore \( 0_{10} \),
che in binario risulterebbe:

\begin{center}
	\( +0_{10}=\textbf{0}|000000_2 \)\\
	\( -0_{10}=\textbf{1}|000000_2 \)
\end{center}
Inoltre le somme che passano dal positivo al negativo e viceversa risultano errate.

\subsubsection{Codifica in complemento a 2}
\begin{center}
	Intervallo: \( -2^{n-1} \le N \le 2^{n-1}-1 \)
\end{center}
La codifica in complemento a 2 rimuove tutti i problemi della codifica in modulo
+ segno. Questa codifica infatti rende le somme molto più semplici. La somma facile
infatti è l'obiettivo di questa codifica e parte dell'idea di trovare la
codifica di -1, pertanto si cerca di formulare \( -1+1=0 \).

\begin{center}
	\begin{tabular}{ c|c }
		Obiettivo            & Risultato      \\
		\hline                                \\
		\( ????_2 \) \( + \) & \( 1111_2 + \) \\
		\( 0001_2 = \)       & \( 0001_2 = \) \\ [2ex]
		\hline                                \\
		\( 0000_2 = \)       & \( 0000_2 \)   \\
	\end{tabular}
\end{center}

Se si considera il numero di bit \( n=4 \), allora l'intervallo di valori è
\( -2^3 \le N \le 2^3-1 \):

\begin{center}
	\begin{tabular}{c|c}
		\( 0_{10} = 0000_{2}\) & \( -1_{10} = 1111_{2}\) \\
		\( 1_{10} = 0001_{2}\) & \( -2_{10} = 1110_{2}\) \\
		\( 2_{10} = 0010_{2}\) & \( -3_{10} = 1101_{2}\) \\
		\( 3_{10} = 0011_{2}\) & \( -4_{10} = 1100_{2}\) \\
		\( 4_{10} = 0100_{2}\) & \( -5_{10} = 1011_{2}\) \\
		\( 5_{10} = 0101_{2}\) & \( -6_{10} = 1010_{2}\) \\
		\( 6_{10} = 0110_{2}\) & \( -7_{10} = 1001_{2}\) \\
		\( 7_{10} = 0111_{2}\) & \( -8_{10} = 1000_{2}\) \\
	\end{tabular}
\end{center}
I valori nel complemento a 2 ciclano, quindi se si somma 1 a 7 si ottiene -8.

\begin{example}
	Sottrazione con il complemento a 2: \( 43-17=25 \)
	\[
		n=7 \; bit
	\]
	\begin{enumerate}
		\item Per prima cosa si prende il valore assoluto del numero negativo
		      \( 17_{10} \) e si converte in binario.
		      \begin{center}
			      \( 17_{10}=0010001_{2} \)
		      \end{center}
		\item Si inverte il numero trovato.
		      \begin{center}
			      \( !(0010001_2) = 1101110_2 = -18_{10} \)
		      \end{center}
		\item Si somma 1 al numero trovato.
		      \begin{center}
			      \begin{tabular}{l}
				      \( 1101110\; + \) \\
				      \( 0000001 = \)   \\
				      \hline
				      \( 1101111 \)
			      \end{tabular}\\
			      \( 1101111_2 = -17_{10} \)
		      \end{center}
		\item Si somma il numero trovato al numero positivo.
		      \begin{center}
			      \begin{tabular}{l}
				      \( 0010001\; + \) \\
				      \( 1101111 = \)   \\
				      \hline
				      \( \textbf{1}0011010 \)
			      \end{tabular}
		      \end{center}
		\item Il risultato ottenuto è: \[
			      \textbf{1}0011010
		      \] Si osserva che c'è un bit in più rispetto a quelli disponibili (quello
		      in grassetto),
		      vuol dire che risulta in overflow\footnote{Indica il "traboccamento",
			      cioè se viene superato il limite massimo l'overfflow è un errore,
			      non perchè sia sbagliata la somma, ma perchè il risultato non è codificabile
			      con il numero di bit disponibili}, quindi si scarta il bit più significativo e
		      si ottiene:\[
			      0011010_2 = 26_{10}
		      \] che è il risultato corretto.
	\end{enumerate}
\end{example}

\section{Numeri razionali a virgola mobile}
Gli standard della virgola mobile sono: IEEE 754/85 e IEEE 754/19. Questo standard
è stato rivisto molte volte e ora viene usato da tutte le codifiche per i numeri in
virgola mobile.

Il numero viene separato in due parti: Mantissa (\( M \)) e una base (\(b\))
con un esponente ($e$).
\[
	N = +- M * b^{+-E}
\]
Questo permette di dividere il numero in modo da poter scegliere quanti bit dedicare
alla mantissa e quanti all'esponente.

Ci sono 2 problemi però:
\begin{itemize}
	\item bisogna scegliere la base in cui fare la codifica (base 2)
	\item divisione bit tra M e E (23 M, 8 E, 1 S)
	\item rappresentazione univoca (1.0...)
	\item bisogna trovare un modo per rappresentare gli errori
\end{itemize}

Un numero in base 10 si può rappresentare in più modi>
\(120_{10} = 12*10^{1} = 120 * 10^{0} = 1.20 * 10^{2}\)

Se la mantissa e la base sono in base 2 le operazioni tra numeri sono agevolate.

\(0110 * 2 = 1100\) è uno shift a sinistra in binario.

\(1010/2 = 0101\) è uno shift a destra in binario.

\subsection{Divisione tra bit con mantissa e base diversa}
Un numero è rappresentabile in 2 modi:
\begin{itemize}
	\item 32 bit (singola precisione / float)
	\item 64 bit (doppia precisione / double)
\end{itemize}

Prendiamo in considerazione 32 bit, ora dobbiamo decidere quanti bit dedicare alla
mantissa e alla base

$2^{+-E}$\\
$|E| = 4 bit = 2^{+7}$\\
$5 bit = 2^{+15}$\\
$6 bit = 2^{+31}$\\
$7 bit = 2^{+63}$\\
$8 bit = 2^{+127}$

L'impatto dei bit sull'esponente è doppiamente esponenziale, quindi cresce tantissimo.
Tra tutti i bit a disposizione ne dedichiamo 8 all'esponente, $32 - 8 = 24$ bit rimanenti,
quindi 23 bit vengono assegnati alla mantissa e 1 bit viene assegnato al segno.
\label{fig:disegno1}

Per la rappresentazione univoca la mantissa si codifica in virgola fissa.
Cioè si parte da una mantissa con un punto fisso e dividendo o moltiplicando (shift) si
può spostare la virgola per arrivare alla forma 1.00000... e questa forma è la
rappresentazione univoca. Questa operazioe si chiama normalizzazione e visto che la
rappresentazione è sempre la stessa l'1. non viene rappresentato, quindi
viene inserito nella mantissa solo tutto ciò che viene dopo l'1. .
\label{fig:disegno2}

Se lavorassimo con un esponente in complemento a due ci sarebbe il seguente problema:
$00000000000...0 = 1*2^{0}=1$

Allora si è deciso di codificare l'esponente in Eccesso 127. Quindi per rappresentare
lo zero si usa come esponente il minore numero possibile: $1*2^{127} = 0$
Per codificare i numeri si somma 127 al numero desiderato e visto che i numeri possibili
ora vanno da -127 a +127 se codifichiamo il risultato in modulo avremo dei numeri
da 0 a 256.

\begin{figure}[H]
	\begin{example}
		$1\:01110111\:0110...0$\\
		$M = -(1+1/4+1/8)*2 = -(11/8)*2^{E}$\\
		$E = (1+2+4+16+32+64)-127=119-127=-8$\\
		$N = -11/8 * 2^{-8}$
	\end{example}
\end{figure}

\begin{figure}[H]
	\begin{exercise}
		Codifica $+(4+\frac{1}{2}+\frac{1}{16})*2^{+34}$
	\end{exercise}
\end{figure}

\begin{itemize}
	\item $0\:00000000\:0...0 = +0$
	\item $1\:00000000\:0...0 = -0$
\end{itemize}

Quando l'esponente è tutto 1 e la mantissa tutta 0 allora equivale a $infinito$
+ o - in base al primo bit. Se invece la mantissa è diversa da 0 con esponente tutti 1
allora rappresenta un errore NaN.

Somma:\\
\label{es2}

\end{document}
