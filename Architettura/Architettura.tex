\documentclass[a4paper]{article}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{textcomp}
\usepackage[italian]{babel}
\usepackage{amsmath, amssymb}
\usepackage{amsfonts}
\usepackage{mdframed}
\usepackage{float}
\usepackage{xcolor}
\usepackage{listings}
\usepackage{graphicx}
\usepackage{tikz}
\usetikzlibrary{shapes}
\usepackage{circuitikz}
\usepackage[label=corner]{karnaugh-map}
\graphicspath{{./figures/}}

\usepackage{ntheorem}
\newtheorem{theorem}{Teorema}

\usepackage{import}
\usepackage{pdfpages}
\usepackage{transparent}
\usepackage{xcolor}

% Code blocks
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.95}

\lstdefinestyle{mystyle}{
	backgroundcolor=\color{backcolour},
	commentstyle=\color{codegreen},
	keywordstyle=\color{magenta},
	numberstyle=\tiny\color{codegray},
	stringstyle=\color{codepurple},
	basicstyle=\ttfamily\footnotesize,
	breakatwhitespace=false,
	breaklines=true,
	captionpos=b,
	keepspaces=true,
	numbers=left,
	numbersep=5pt,
	showspaces=false,
	showstringspaces=false,
	showtabs=false,
	tabsize=2
}

\lstset{style=mystyle}

\usepackage{color}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=tb,
	aboveskip=3mm,
	belowskip=3mm,
	showstringspaces=false,
	columns=flexible,
	basicstyle={\small\ttfamily},
	numbers=none,
	numberstyle=\tiny\color{gray},
	keywordstyle=\color{blue},
	commentstyle=\color{dkgreen},
	stringstyle=\color{mauve},
	breaklines=true,
	breakatwhitespace=true,
	tabsize=3
}

\usepackage{import}
\usepackage{pdfpages}
\usepackage{transparent}
\usepackage{xcolor}



% Useful definitions frame
\theoremstyle{break}
\theoremheaderfont{\bfseries}
\newmdtheoremenv[%
	linecolor=gray,leftmargin=0,%
	rightmargin=0,
	innertopmargin=8pt,%
	innerbottommargin=8pt,
	ntheorem]{define}{Definizioni utili}[section]

% Example frame
\theoremstyle{break}
\theoremheaderfont{\bfseries}
\newmdtheoremenv[%
	linecolor=gray,leftmargin=0,%
	rightmargin=0,
	innertopmargin=8pt,%
	innerbottommargin=8pt,
	ntheorem]{example}{Esempio}[section]

% Important definition frame
\theoremstyle{break}
\theoremheaderfont{\bfseries}
\newmdtheoremenv[%
	linecolor=gray,leftmargin=0,%
	rightmargin=0,
	backgroundcolor=gray!40,%
	innertopmargin=8pt,%
	innerbottommargin=8pt,
	ntheorem]{definition}{Definizione}[section]

% Exercise frame
\theoremstyle{break}
\theoremheaderfont{\bfseries}
\newmdtheoremenv[%
	linecolor=gray,leftmargin=0,%
	rightmargin=0,
	innertopmargin=8pt,%
	innerbottommargin=8pt,
	ntheorem]{exercise}{Esercizio}[section]

% figure support
\usepackage{import}
\usepackage{xifthen}
\pdfminorversion=7
\usepackage{pdfpages}
\usepackage{transparent}
\newcommand{\incfig}[1]{%
	\def\svgwidth{\columnwidth}
	\import{./figures/}{#1.pdf_tex}
}

\pdfsuppresswarningpagegroup=1

\begin{document}
\input{title.tex}

\tableofcontents
\pagebreak
\section{Introduzione}
L'informatica è nata per la risoluzione di problemi di calcolo, in particolare
quelli di calcolo numerico. Per questo motivo i primi computer erano macchine
che eseguivano operazioni aritmetiche. Per risolvere questi problemi si usano
degli algoritmi che sono una sequenza di istruzioni semplici che portano poi
a risolvere problemi di complessità variabile. Anche gli algoritmi hanno una
complessità che deve essere adeguata alla risoluzione del problema.

\subsection{Hardware}
Un algoritmo deve essere trasformato in un processo di calcolo automatico,
quindi deve essere implementato tramite hardware. Ci sono due tipi di hardware:
\begin{itemize}
	\item \textbf{Embedded} che è un hardware dedicato ad un singolo compito.
	      Ad esempio il microonde.
	\item \textbf{General purpose} non si sa l'utilizzo finale, quindi ha
	      funzionalità generali ampliate dal software installato. L'hardware
	      general purpose è programmabile attraverso il software. Un esempio
	      è il PC.
\end{itemize}

In base al tipo di hardware l'algoritmo viene implementato in diversi modi:
\begin{itemize}
	\item \textbf{Algoritmo} \( \to  \) \textbf{Software}: Tramite un linguaggio di programmazione
	\item \textbf{Algoritmo} \( \to  \)  \textbf{Hardware embedded}: Tramite linguaggi di basso livello
	      come C, Assembly o il sistema operativo.
	\item \textbf{Algoritmo} \( \to  \)  \textbf{Hardware}: Tramite sintesi logica
\end{itemize}

\subsection{Campionamento dei dati}
Ogni cosa nel mondo è rappresentabile da funzioni continue nel tempo \( f(t) \),
ma con risorse finite è impossibile rappresentare infiniti dati, bisogna quindi
campionarli.

\begin{figure}[h]
	\centering
	\begin{tikzpicture}[scale=0.6, domain=0:10]
		\coordinate (A) at (0,4);
		\coordinate (B) at (1,4);
		\coordinate (C) at (2,2);
		\coordinate (D) at (3,4);
		\coordinate (E) at (4,1);
		\coordinate (F) at (5,3);
		\coordinate (G) at (6,2);
		\coordinate (H) at (7,4);
		\coordinate (I) at (8,3);
		\coordinate (J) at (9,2);
		\coordinate (K) at (10,5);

		\draw [->] (0,0) -- (10,0) node[right] {$t$};
		\draw [->] (0,0) -- (0,5) node[above] {$f(t)$};

		\draw [gray!50, ultra thin] (0,0) grid (10,5);
		\draw [blue, ultra thick] plot [smooth, tension=1] coordinates { (A) (B) (C) (D) (E) (F) (G) (H) (I) (J) (K) };
		\draw [red, thick ] (A) -- (B) -- (C) -- (D) -- (E) -- (F) -- (G) -- (H) -- (I) -- (J) -- (K);

		\draw [fill] (A) circle [radius=0.1];
		\draw [fill] (B) circle [radius=0.1];
		\draw [fill] (C) circle [radius=0.1];
		\draw [fill] (D) circle [radius=0.1];
		\draw [fill] (E) circle [radius=0.1];
		\draw [fill] (F) circle [radius=0.1];
		\draw [fill] (G) circle [radius=0.1];
		\draw [fill] (H) circle [radius=0.1];
		\draw [fill] (I) circle [radius=0.1];
		\draw [fill] (J) circle [radius=0.1];
		\draw [fill] (K) circle [radius=0.1];

		\draw (0, -0.2) -- (1, -0.2) node[below, xshift=-10] {\( \Delta t \) };
	\end{tikzpicture}
    \caption{Funzione casuale continua nel tempo}
    \label{fig:f(t)}
\end{figure}
Per campionare la funzione nella figura \ref{fig:f(t)} bisogna scegliere un intervallo di tempo \( \Delta t \) e prendere
un valore della funzione ogni \( \Delta t \). In questo caso le linee
verticali rappresentano il \textbf{campionamento}, mentre quelle orizzontali
reppresentano la \textbf{discretizzazione o quantizzazione}.
La linea rossa è una spezzata approssimata della funzione continua, infatti
per il teorema di Shannon:

\begin{theorem}
	Deciso il grado di errore da voler compiere, esistono una precisa frequenza di
	campionamento e un intervallo di discretizzazione che garantiscono
	quell'errore.
\end{theorem}
Il sistema di calcolo è ora diventato digitale, cioè elabora i segnali numerici
in ingresso per produrre segnali numerici in uscita.

\begin{figure}[h]
	\centering
	\begin{tikzpicture}
		\node[draw, text=red, align=center] (Realtà fisica) at (0,0) {Realtà\\
			fisica};
		\node[draw, align=center] (Campionamento e discretizzazione) at (2,-1.5) {Campionamento e\\
			discretizzazione};
		\node[draw, text=blue, align=center] (Codifica) at (4,0) {Codifica};
		\node[draw, align=center] (Sistema digitale) at (6,-1.5) {Sistema\\
			digitale};
		\node[draw, text=blue, align=center] (Decodifica) at (8,0) {Decodifica};
		\node[draw, text=red, align=center] (Informazioni) at (9,-1.5) {Informazioni};

		\draw[->,draw] (Realtà fisica) to (Campionamento e discretizzazione);
		\draw[->,draw] (Campionamento e discretizzazione) to (Codifica);
		\draw[->,draw] (Codifica) to (Sistema digitale);
		\draw[->,draw] (Sistema digitale) to (Decodifica);
		\draw[->,draw] (Decodifica) to (Informazioni);
	\end{tikzpicture}
	\caption{Dalla realtà fisica al sistema digitale}
\end{figure}


\section{Sistemi di codifica}
Ogni sistema digitale lavora in base binaria, quindi entrano \( N \)  bit
ed escono \( M \)  bit. I bit in uscita devono essere codificati per
realizzare delle informazioni. Ci sono 2 tipi di informazioni:

\begin{itemize}
	\item \textbf{Informazioni intelleggibili}: sono già chiare agli esseri umani,
	      come un testo scritto.
	\item \textbf{Informazioni non intelleggibili}: hanno bisogno di macchine
	      per essere riprodotte, come le casse per l'audio.
\end{itemize}

\subsection{Codifica di informazioni non numeriche}
Ogni informazione deve avere un codice univoco in modo che il sistema
digitale non possa sbagliare a decodificarla. Date \( M \)  informazioni si
ricavano \( n = log_2{(M)} \)  codici disponibili per rappresentarle.

\begin{example}
	Con \( M=7 \) informazioni:
	\begin{itemize}
		\item \( n=log_2{(7)} \approx 3\; bit \)
		\item \( 2^3=8 \) codici disponibili
	\end{itemize}
\end{example}

\subsection{Numeri interi assoluti}
I numeri interi assoluti rappresentano solo i valori da \( 0 \) a \( 2^n-1 \),
dove \( n \) è il numero di bit disponibile.

La codifica da base decimale a base binaria prende il nome di \textbf{codifica
	a modulo}

\begin{example}
	\label{ex:57modulo}
	Si deve convertire il numero \( 57_{10} \) in base binaria
	\begin{center}
		\[ n=log_2{(57)} = 6\; bit\; (minimi)
 \]
 \[ \sum_{i=1}^{n-1} 2^n-1 = 63\; (codici\; massimi)\]
	\end{center}
	Si eseguono i seguenti passaggi:
	\begin{enumerate}
		\item Si sottraggono le potenze di 2 partendo da \( n-1 \).
		      \begin{itemize}
			      \item Se la potenza \( 2^i \) è minore o uguale del numero,
			            allora si moltiplica per 1.
			      \item Se la potenza \( 2^i \) è maggiore del numero,
			            allora si moltiplica per 0.
		      \end{itemize}
		\item Le sottrazioni continuano fino a quando si giunge a 0.
	\end{enumerate}
	\(57_{10}-{\textcolor{cyan}{1}}*2^{\textcolor{red}{5}}
		=25_{10}-{\textcolor{cyan}{1}}*2^{\textcolor{red}{4}}
		=9_{10}-{\textcolor{cyan}{1}}*2^{\textcolor{red}{3}}
		=1_{10}-{\textcolor{cyan}{0}}*2^{\textcolor{red}{2}}
		=1_{10}-{\textcolor{cyan}{0}}*2^{\textcolor{red}{1}}
		=1_{10}-{\textcolor{cyan}{1}}*2^{\textcolor{red}{0}}\)

    \begin{center}
       \( 57= \textcolor{cyan}{111001} \) 
   \end{center}
\end{example}

\subsection{Numeri interi relativi}
La codifica più ovvia per i numeri interi relativi è la codifica a
\textbf{modulo + segno}. Tuttavia rappresenta varie problematiche, per cui
si preferisce usare la codifica in \textbf{complemento a 2}.

\subsubsection{Codifica a modulo + segno}
\begin{center}
	Intervallo: \( -2^{n-1} \le N \le 2^{n-1}-1 \)
\end{center}
Il segno si rappresenta con un bit, 0 per il positivo e 1 per il negativo.
Il bit più significativo è il bit del segno, mentre i bit meno significativi
rappresentano il modulo.

\begin{figure}[H]
    \begin{center}
        \begin{tikzpicture}
            \draw[draw] (0, 0) rectangle (2,1) node[pos=.5, align=center] {1 bit:\\
                segno \( \pm \) };
            \draw[draw] (2, 0) rectangle (7,1) node[pos=.5, align=center] {7 bit: modulo};
        \end{tikzpicture}
    \end{center}
    \caption{Bit dedicati alla codifica a modulo + segno} 
\end{figure}
Considerando l'esempio \ref{ex:57modulo} si hanno le seguenti rappresentazioni:

\begin{center}
	\( +57_{10}=\textbf{0}|111001_2 \)\\
	\( -57_{10}=\textbf{1}|111001_2 \)
\end{center}
Sorge però un problema quando si vuole rappresentare il valore \( 0_{10} \),
che in binario risulterebbe:

\begin{center}
	\( +0_{10}=\textbf{0}|000000_2 \)\\
	\( -0_{10}=\textbf{1}|000000_2 \)
\end{center}
Inoltre le somme che passano dal positivo al negativo e viceversa risultano errate.

\subsubsection{Codifica in complemento a 2}
\begin{center}
	Intervallo: \( -2^{n-1} \le N \le 2^{n-1}-1 \)
\end{center}
La codifica in complemento a 2 rimuove tutti i problemi della codifica in modulo
+ segno. Questa codifica infatti rende le somme molto più semplici. La somma facile
infatti è l'obiettivo di questa codifica e parte dell'idea di trovare la
codifica di -1, pertanto si cerca di formulare \( -1+1=0 \).

\begin{table}[H]
    \begin{center}
        \begin{tabular}{ c|c }
            Obiettivo            & Risultato      \\
            \hline                                \\
            \( ????_2 \) \( + \) & \( 1111_2 + \) \\
            \( 0001_2 = \)       & \( 0001_2 = \) \\ [2ex]
            \hline                                \\
            \( 0000_2 = \)       & \( 0000_2 \)   \\
        \end{tabular}
    \end{center}
    \caption{Obiettivo della codifica in complemento a 2}
\end{table}

Se si considera il numero di bit \( n=4 \), allora l'intervallo di valori è
\( -2^3 \le N \le 2^3-1 \):

\begin{table}[H]
    \begin{center}
        \begin{tabular}{c|c}
            \( 0_{10} = 0000_{2}\) & \( -1_{10} = 1111_{2}\) \\
            \( 1_{10} = 0001_{2}\) & \( -2_{10} = 1110_{2}\) \\
            \( 2_{10} = 0010_{2}\) & \( -3_{10} = 1101_{2}\) \\
            \( 3_{10} = 0011_{2}\) & \( -4_{10} = 1100_{2}\) \\
            \( 4_{10} = 0100_{2}\) & \( -5_{10} = 1011_{2}\) \\
            \( 5_{10} = 0101_{2}\) & \( -6_{10} = 1010_{2}\) \\
            \( 6_{10} = 0110_{2}\) & \( -7_{10} = 1001_{2}\) \\
            \( 7_{10} = 0111_{2}\) & \( -8_{10} = 1000_{2}\) \\
        \end{tabular}
    \end{center}
    \caption{Codifica in complemento a 2 con \( n=4 \) bit}
\end{table}
I valori nel complemento a 2 ciclano, quindi se si somma 1 a 7 si ottiene -8.

\begin{example}
	Sottrazione con il complemento a 2: \( 43-17=25 \)
	\[
		n=7 \; bit
	\]
	\begin{enumerate}
		\item Per prima cosa si prende il valore assoluto del numero negativo
		      \( 17_{10} \) e si converte in binario.
		      \begin{center}
			      \( 17_{10}=0010001_{2} \)
		      \end{center}
		\item Si inverte il numero trovato.
		      \begin{center}
			      \( !(0010001_2) = 1101110_2 = -18_{10} \)
		      \end{center}
		\item Si somma 1 al numero trovato.
            \begin{table}[H]
                \begin{center}
                    \begin{tabular}{l}
                        \( 1101110\; + \) \\
                        \( 0000001 = \)   \\
                        \hline
                        \( 1101111 \)
                    \end{tabular}\\
                    \( 1101111_2 = -17_{10} \)
                \end{center}
                \caption{Somma di 1 al numero invertito}
            \end{table}
		\item Si somma il numero trovato al numero positivo.
            \begin{table}[H]
                \begin{center}
                    \begin{tabular}{l}
                        \( 0010001\; + \) \\
                        \( 1101111 = \)   \\
                        \hline
                        \( \textbf{1}0011010 \)
                    \end{tabular}
                \end{center}
               \caption{Somma del numero positivo con il numero negativo} 
            \end{table}
		\item Il risultato ottenuto è: \[
			      \textbf{1}0011010
		      \] Si osserva che c'è un bit in più rispetto a quelli disponibili (quello
		      in grassetto),
		      vuol dire che risulta in overflow\footnote{Indica il "traboccamento",
			      cioè se viene superato il limite massimo l'overfflow è un errore,
			      non perchè sia sbagliata la somma, ma perchè il risultato non è codificabile
			      con il numero di bit disponibili}, quindi si scarta il bit più significativo e
		      si ottiene:\[
			      0011010_2 = 26_{10}
		      \] che è il risultato corretto.
	\end{enumerate}
\end{example}

\paragraph{Estensione del numero con il complemento a 2}
\begin{itemize}
	\item Se un numero è \textbf{positivo} va esteso con gli \( \textbf{0} \)
        \begin{table}[H]
            \begin{center}
                \begin{tabular}{l|l}                                        \\
                    \( +57_{10}+ \)  & \( 0111001_2\;+ \)        \\
                    \( +7_{10}\;= \) & \( \textbf{0000}111_2= \) \\ \\
                    \hline                                       \\
                    \( +64_{10} \)   & \( 1000010_2 \)
                \end{tabular}
            \end{center}
           \caption{Estensione di un numero positivo} 
        \end{table}
	\item Se un numero è \textbf{negativo} va esteso con gli \( \textbf{1} \)
        \begin{table}[H]
            \begin{center}
                \begin{tabular}{l|l}                                        \\
                    \( +57_{10}+ \)  & \( 0111001_2\;+ \)        \\
                    \( -7_{10}\;= \) & \( \textbf{1111}111_2= \) \\ \\
                    \hline                                       \\
                    \( +50_{10} \)   & \( 10110010_2 \)
                \end{tabular}
            \end{center}
            \caption{Estensione di un numero negativo}
        \end{table}
\end{itemize}

\section{Numeri razionali}
I numeri razionali sono composti da una parte intera e una parte frazionaria.
Si possono codificare in 2 modi:
\begin{itemize}
	\item \textbf{Virgola fissa}(fixed point): viene usata maggiormente nei
	      sistemi embedded quando si sa a priori il numero più grande e la
	      precisione che si vuole ottenere
	\item \textbf{Virgola mobile}(floating point): viene usata maggiormente
	      nei sistemi general purpose.
\end{itemize}

\subsection{Codifica in virgola fissa}
\begin{example}
	Si hanno a disposizione 8 bit: 4 per la parte intera e 4 per la parte frazionaria.
	Vogliamo decodificare il numero \( 0110.1011_2 \):
	\Large\[
		\underbrace{\stackrel{2^{3}}{0}\;\stackrel{2^{2}}{1}\;\stackrel{2^{1}}{1}\;\stackrel{2^{0}}{0}}_{+6} .
		\underbrace{\stackrel{2^{-1}}{1}\;\stackrel{2^{-2}}{0}\;\stackrel{2^{-3}}{1}\;\stackrel{2^{-4}}{1}}_{\frac{1}{2}+\frac{1}{8}+\frac{1}{16}}
	\]
	\normalsize\[
		+6 + \frac{1}{2}+\frac{1}{8}+\frac{1}{16}= 6+\frac{11}{16} = \frac{107}{16} = 6.6875
	\]
\end{example}
Se si vuole codificare un numero da decimale a binario bisogna tenere in considerazione
che non è certo che il numero sia razionale anche in base 2, quindi bisogna
approssimare per rappresentarlo.

\begin{example}
	\label{ex:virgolaFissaDecBin}
	Prendiamo in considerazione \( +4 +\frac{3}{5} \), in questo caso bisogna andare
	"a tentoni" e trovare la rappresentazione binaria che approssima con il minor
	errore possibile.
	\[
		4_{10} = 0100_2
	\]
	\[
		0.1001 = \frac{9}{10} \Delta \frac{3}{80}
	\]
	\[
		0.0111 = \frac{7}{16} \Delta -\frac{4}{80}
	\]
	\[
		0.0110 = \frac{3}{8} \Delta \frac{9}{40}
	\]
	\[
		\underline{0.1010 = \frac{5}{8} \Delta -\frac{1}{40}}
	\]
	\( \Delta \) rappresenta l'errore, quindi la rappresentazione più vicina è
	\( 0100.1010_2 \). Però non è stato rappresentato \( \frac{3}{5} \), ma
	\( \frac{1}{2}+\frac{1}{16}=\frac{9}{16} \).
\end{example}
Questo metodo è pesante perchè bisogna controllare più alternative.

\subsubsection{Errore percentuale}
Bisogna decidere se calcolarlo rispetto alla parte intera o a quella frazionaria.
Nel seguente esempio viene calcolato l'errore percentuale rispetto alla parte
frazionaria dell'esempio \ref{ex:virgolaFissaDecBin}.
\begin{example}
	\[
		\frac{1}{40} : \frac{3}{5} = \frac{1}{40} * \frac{5}{3} = \frac{1}{24} \approx 0.052\%
	\]
\end{example}
Il massimo errore che si può fare è l'overflow.

\subsection{Codifica in virgola mobile}
Gli standard della virgola mobile sono: IEEE 754. Questo standard
è stato rivisto molte volte e ora viene usato da tutte le codifiche per i numeri in
virgola mobile.\\
Il numero viene separato in 3 parti:
\begin{itemize}
    \item \textbf{S}: Segno
    \item \textbf{e}: Esponente
	\item \textbf{M}: Mantissa
\end{itemize}
La struttura del numero è quindi:
\[
	N = \pm \cdot M^{\pm e}
\]
Questo permette di dividere il numero in modo da poter scegliere quanti bit dedicare
alla mantissa e quanti all'esponente. Si riscontrano però i seguenti problemi:
\begin{itemize}
	\item Bisogna scegliere la base in cui fare la codifica \(\to\)  base 2
	\item Bisogna scegliere la divisione di bit tra \emph{segno}, \emph{mantissa} e \emph{esponente} \( \to \)   \( 1\; S \), \( 23\; M \), \( 8\; e \)
	\item La rappresentazione deve essere univoca \( \to \)  \( 1.\; \ldots_2 \)
	\item Bisogna trovare un modo per rappresentare gli errori
\end{itemize}
Se la mantissa e la base sono in base 2 la moltiplicazione e la
divisione sono agevolate tramite l'utilizzo dello \emph{shift}.

\begin{itemize}
	\item \(0110 \cdot  2 = 1100\) è uno shift a sinistra in binario.
        \begin{figure}[H]
            \begin{center}
                \Large
                \begin{tikzpicture}
                    \node[align=left] (Prima1) at (0,0) {0};
                    \node[align=left] (Prima2) at (0.2,0) {1};
                    \node[align=left] (Prima3) at (0.4,0) {1};
                    \node[align=left] (Prima4) at (0.6,0) {0};

                    \node[align=left] (Dopo1) at (0,-1) {1};
                    \node[align=left] (Dopo2) at (0.2,-1) {1};
                    \node[align=left] (Dopo3) at (0.4,-1) {0};
                    \node[align=left] (Dopo4) at (0.6,-1) {0};

                    \draw[->, draw] (Prima2) to (Dopo1);
                    \draw[->, draw] (Prima3) to (Dopo2);
                    \draw[->, draw] (Prima4) to (Dopo3);
                \end{tikzpicture}
            \end{center}
            \caption{Shift a sinistra in binario}
        \end{figure}

	\item \(1010/2 = 0101\) è uno shift a destra in binario.
        \begin{figure}[H]
            \begin{center}
                \Large
                \begin{tikzpicture}
                    \node[align=left] (Prima1) at (0,0) {1};
                    \node[align=left] (Prima2) at (0.2,0) {0};
                    \node[align=left] (Prima3) at (0.4,0) {1};
                    \node[align=left] (Prima4) at (0.6,0) {0};

                    \node[align=left] (Dopo1) at (0,-1) {0};
                    \node[align=left] (Dopo2) at (0.2,-1) {1};
                    \node[align=left] (Dopo3) at (0.4,-1) {0};
                    \node[align=left] (Dopo4) at (0.6,-1) {1};

                    \draw[->, draw] (Prima1) to (Dopo2);
                    \draw[->, draw] (Prima2) to (Dopo3);
                    \draw[->, draw] (Prima3) to (Dopo4);
                \end{tikzpicture}
            \end{center}
            \caption{Shift a destra in binario}
        \end{figure}
\end{itemize}


\subsubsection{Divisione di bit tra segno, mantissa ed esponente}
Un numero è rappresentabile in 2 modi:
\begin{itemize}
	\item Singola precisione 32 bit \( \to  \) float
	\item Doppia precisione 64 bit \( \to  \) double
\end{itemize}

Prendiamo in considerazione 32 bit, ora dobbiamo decidere quanti bit dedicare
alla mantissa e all'esponente.
\[
	2^{\pm e}
\]
\begin{center}
	$|e| = 4 bit = 2^{+7}$\\
	$5 bit = 2^{+15}$\\
	$6 bit = 2^{+31}$\\
	$7 bit = 2^{+63}$\\
	$8 bit = 2^{+127}$
\end{center}
L'impatto dei bit sull'esponente è doppiamente esponenziale, quindi cresce tantissimo.

\begin{itemize}
	\item \textbf{8 bit} all'esponente, quindi l'esponente
	      può assumere valori da \( -127 \) a \( +127 \).
	\item \textbf{23 bit} alla mantissa, quindi la mantissa
	      può assumere valori da \( 0 \) a \( 2^{23}-1 \)
	\item \textbf{1 bit} al segno.
\end{itemize}

\begin{figure}[H]
    \begin{center}
        \begin{tikzpicture}
            \draw[draw] (0, 0) rectangle (1.6,1) node[pos=.5, align=center] {1 bit:\\
                segno \( \pm \) };
            \draw[draw] (1.6, 0) rectangle (5,1) node[pos=.5, align=center] {8 bit: esponente};
            \draw[draw] (5, 0) rectangle (10,1) node[pos=.5, align=center] {23 bit: mantissa};
        \end{tikzpicture}
    \end{center}
    \caption{Bit dedicati alla codifica in virgola mobile}
\end{figure}
Per la rappresentazione univoca la mantissa si codifica in virgola fissa.
Cioè si parte da una mantissa con un \textbf{punto fisso} e dividendo o moltiplicando (shift) si
può spostare la virgola per arrivare alla forma \textbf{1.00000...} e questa forma è la
rappresentazione univoca.

Questa operazioe si chiama \textbf{normalizzazione} e visto che la
rappresentazione è sempre la stessa l'\emph{1.} non viene rappresentato, quindi
viene inserito nella mantissa solo tutto ciò che viene dopo.
\begin{figure}[H]
	\begin{center}
		\( 11111111 \) \( \pm \infty \)\\
		\( 11111110 \) \( +127 \) \\
		\( \ldots \)\\
		\( 00000000 \) \( \pm 0 \)\\
		\( \ldots \)\\
		\( 00000001 \) \( -126 \) \\
		\( 00000000 \) \( -127 \)
	\end{center}
	\caption{Range dell'esponente}
\end{figure}
Si è deciso di codificare l'esponente in \textbf{Eccesso 127}. Quindi per
rappresentare lo zero si usa come esponente il minore numero possibile:
$1 \cdot 2^{-127} = 0$. Per codificare i numeri si somma 127 al numero desiderato
e visto che i numeri possibili ora vanno da -127 a +127 se codifichiamo
il risultato in modulo avremo dei numeri da 0 a 256.

\begin{figure}[H]
	\begin{example}
		Si vuole decodificare il seguente numero:
		\[1\:01110111\:0110...0\]
		\[M = -(1+\frac{1}{4}+\frac{1}{8})*2^e = -(\frac{11}{8})*2^{e}\]
		\[e = (1+2+4+16+32+64)-127=119-127=-8\]
		\[N = -\frac{11}{8} * 2^{-8}\]
	\end{example}
\end{figure}

\begin{figure}[H]
	\begin{example}
		Codifica $+(4+\frac{1}{2}+\frac{1}{16})*2^{+34}$
		\begin{enumerate}
			\item Sappiamo già che il numero è positivo quindi:
			      \[
				      S=0
			      \]
			\item Calcoliamo la mantissa:
			      \[
				      4+\frac{1}{2}+\frac{1}{16}= \underbrace{100}_{4_{10}}.
				      \underbrace{10010 \ldots 0}_{\frac{1}{2}+\frac{1}{16}}
			      \]
			\item La mantissa va normalizzata moltiplicando per 4:
			      \[
				      100.10010 \ldots 0 * 2^{+2} = 1.0010010 \ldots 0
			      \]
			      \[
				      M = 0010010 \ldots 0
			      \]
			\item Calcoliamo l'esponente:
                \[
                e = 34 + 2 = 36
                \] Si aggiunge 2 perchè abbiamo fatto lo shift di 2 bit.
                \[
                e = 36 + 127 = 163
                \] 
                \[
                    163_{10} = 10100011_2
                \] 
                \item Il numero in virgola mobile è:
                \[
                    0\:10100011\:0010010 \ldots 0
                \]
		\end{enumerate}
	\end{example}
\end{figure}

\begin{itemize}
	\item $0\:00000000\:0...0 = +0$
	\item $1\:00000000\:0...0 = -0$
\end{itemize}

Quando l'esponente è tutto 1 e la mantissa tutta 0 allora equivale a \( \pm \infty \)
in base al primo bit. Se invece la mantissa è diversa da 0 con esponente tutti 1
allora rappresenta un errore NaN.

%Lezione 4
\section{Modelli}
Per un progetto bisogna creare un \textbf{modello} che rappresenti il sistema.
Boole ha cercato di rappresentare tutte le algebre. Lo ha fatto attraverso
una quintupla: \( <B^{n}, \cdot, + ,\{0,1\}> \)
\begin{figure}[H]
	\centering
	\begin{tikzpicture}
		\node[draw, align=center] (Sistema digitale) at (0,0) {Sistema\\
			digitale};

		\draw[->, draw] (Sistema digitale) to (2,0);
		\draw[<-, draw] (Sistema digitale) to (-2,0);

		\node (A) at (-2,0.3) {A};
		\node (B) at (-2,-0.3) {B};
		\node (O) at (2,0.3) {O};
	\end{tikzpicture}
    \caption{Modello di un sistema digitale}
\end{figure}

\begin{itemize}
	\item \( B^n \) è l'insieme di valori
	\item \( \{0,1\} \) è l'alfabeto (sistema binario)
	\item "\( \cdot  \)" e "\( + \)" sono 2 operatori
\end{itemize}
Bool garantisce che si può creare qualsiasi funzione utilizzando soltanto i
2 operatori:
\[
	f(B^n) \to B^m
\]
\begin{example}
	Si vuole creare un modello con 2 bit in entrata e 1 in uscita:
	\[
		n=2 \; m=1
	\]
	\( O=1 \leftrightarrow A=B \)\\
	\( f(B^2) \to B \)
    \begin{figure}[H]
        \begin{center}
            \begin{tikzpicture}
                \draw[thick] (0,0) circle [x radius=0.5cm, y radius=1.5cm]
                    (2,0) circle [x radius=0.5cm, y radius=1.5cm];

                \node[align=center] (00) at (0,0.8) {00};
                \node[align=center] (11) at (0,0.3) {11};
                \node[align=center] (01) at (0,-0.2) {01};
                \node[align=center] (10) at (0,-0.7) {10};

                \node[align=center] (1) at (2,0.6) {1};
                \node[align=center] (0) at (2,-0.5) {0};

                \draw[->, draw] (00) to (1);
                \draw[->, draw] (11) to (1);
                \draw[->, draw] (01) to (0);
                \draw[->, draw] (10) to (0);
            \end{tikzpicture}
        \end{center}
        \caption{Modello di un sistema digitale}
    \end{figure}
	Per mappare i valori in ingresso con quelli di uscita si usa una
	\textbf{tabella di verità}:
    \begin{table}[H]
        \begin{center}
            \begin{tabular}{c|c}
                \( A \)  \( B \) & \( O \) \\
                \hline
                0        0       & 1       \\
                0        1       & 0       \\
                1        0       & 0       \\
                1        1       & 1       \\
            \end{tabular}
        \end{center}
        \caption{Tabella di verità}
    \end{table}
	Chiamiamo mintermine un punto dello spazio booleano in ingresso in cui la
	funzione vale 1. Il maxtermine è il contrario.
	L'insieme di mintermini \( \{m_0\footnote{\( m_n \): n è il valore in modulo
		del relativo numero binario, \( m \) sta per modulo. \( m_3 = 11_2 \) }, m_3\} \) si chiama \textbf{ON-SET}
	L'insieme dei maxtermini \( \{m_1, m_2\} \) si chiama \textbf{OFF-SET}. Basta
	uno dei due insiemi (ON-SET, OFF-SET) per definire la funzione.
	\[
		m_3 = A \cdot B
	\]
	Dire che \( m_3 \) è il prodotto delle due variabili è un modo corretto per
	rappresentarlo.
	\[
		m_0 = \bar{A} \cdot \bar{B}
	\]
	Per rappresentare il mintermine basta fare il prodotto delle variabili se
	valgono 1 o delle variabili negate se valgono 0.

	Per rappresentare la funzione si può usare la somma dei mintermini:
	\[
		O = m_0 + m_3 = \bar{A} \cdot \bar{B} + A \cdot B = 0
	\]
	Questa rappresentazione viene detta: \emph{Espressione in somma di prodotti}
	\begin{theorem}
		Dato un ON-SET c'è sempre una sola espressione in somma di prodotti che lo
		rappresenti.
	\end{theorem}
	\label{ex:modelloAB}
\end{example}

\subsection{Tabelle di verità}
\subsubsection{Operatore prodotto}
\begin{table}[H]
    \begin{center}
        \begin{tabular}{c|c}
            \( A \)  \( B \) & \( O \) \\
            \hline
            0        0       & 0       \\
            0        1       & 0       \\
            1        0       & 0       \\
            1        1       & 1       \\
        \end{tabular}
    \end{center}
    \caption{Tabella di verità dell'AND}
\end{table}

\subsubsection{Operatore somma}
\begin{table}[H]
    \begin{center}
        \begin{tabular}{c|c}
            \( A \)  \( B \) & \( O \) \\
            \hline
            0        0       & 0       \\
            0        1       & 1       \\
            1        0       & 1       \\
            1        1       & 1       \\
        \end{tabular}
    \end{center}
    \caption{Tabella di verità dell'OR}
\end{table}

\subsubsection{Operatore negazione}
\begin{table}[H]
    \begin{center}
        \begin{tabular}{c|c}
            \( A \) & \( O \) \\
            \hline
            0       & 1       \\
            1       & 0       \\
        \end{tabular}
    \end{center}
    \caption{Tabella di verità del NOT}
\end{table}

\section{Transistor}
È un "comando di accensione" che permette di accendere o spegnere un circuito.
\subsection{Transistor CMOS}
\subsubsection{Transistor N}
Mette in collegamento 2 punti:
\begin{itemize}
	\item Se la corrente è 0V allora non c'è collegamento
	\item Se la corrente è 3V allora c'è collegamento
\end{itemize}

\begin{figure}[H]
	\begin{center}
		\begin{circuitikz}[american,]
			\node (Vcc) at (0,0.3) {\( V_{cc} \) };
			\draw (0,0) -- (1,0) to[short,-*] ++(0,0) node[left] {}
			(2,0) -- (1,0)
			node[nmos,anchor=D] (nmos) {}
			(nmos.G) to[short] ++(0,0) node[left] {}
			(nmos.S) node[ground] {};
		\end{circuitikz}
	\end{center}
	\caption{Transistor N}
\end{figure}

\subsubsection{Transistor P}
Mette in collegamento 2 punti:
\begin{itemize}
	\item Se la corrente è 0V allora c'è collegamento
	\item Se la corrente è 3V allora non c'è collegamento
\end{itemize}

\begin{figure}[H]
	\begin{center}
		\begin{circuitikz}[american,]
			\node (Vcc) at (0,0.3) {\( V_{cc} \) };
			\draw (0,0) -- (1,0) to[short,-*] ++(0,0) node[left] {}
			(2,0) -- (1,0)
			node[pmos,anchor=S] (pmos) {}
			(pmos.G) to[short] ++(0,0) node[left] {}
			(pmos.D) node[ground] {};

		\end{circuitikz}
	\end{center}
	\caption{Transistor P}
\end{figure}
\subsubsection{Circuito di negazione (NOT)}
Si realizza con un transistor P e uno N in serie.
\begin{figure}[H]
	\begin{center}
		\begin{circuitikz}
			\node (Vcc) at (-1,0.3) {\( V_{cc} \) };
			\node (Vcc) at (1,0.3) {\( 3V \) };
			\draw (-1,0) -- (0,0) to[short,-*] ++(0,0) node[left] {}
			(1,0) -- (0,0);
			\draw (0,0) node[pmos, anchor=S] (pmos) {}
			(pmos.G) to[short] ++(0,0) node[left] {}
			(pmos.D) to[short] ++(0,0) node[left] {}
			(pmos.D) -- ++(0,0) to[short,-*] (0,-1.6) node[left] {}
			node[nmos,anchor=D] (nmos) {}
			(nmos.G) to[short] ++(0,0) node[left] {}
			(nmos.S) node[ground] {};
			\draw (-2, -1.6) node[above] {\( x \) } to[short,-*] (-0.99,-1.6) node[left] {}
			(pmos.G) -- ++(0,0) to[short,-*] (-0.99,-1.6) node[left] {}
			(0,-1.6) -- ++(0,0) to[short] (1.2,-1.6) node[above] {O}
			(nmos.G) -- ++(0,0) to[short] (-0.99,-1.6) node[left] {};
			\node (0V) at (0.6,-3.5) {\( 0V \) };
		\end{circuitikz}
	\end{center}
    \caption{Circuito di negazione}
\end{figure}
La tabella della verità è:
\begin{table}[H]
    \begin{center}
        \begin{tabular}{c|c}
            \( x \) & \( O \) \\
            \hline
            0V      & 3V      \\
            3V      & 0V      \\
        \end{tabular}
    \end{center}
    \caption{Tabella di verità del circuito}
\end{table}
Se assegnamo ad ogni valore un numero binario:
\begin{table}[H]
    \begin{center}
        \begin{tabular}{c|c}
            \( x \) & \( O \) \\
            \hline
            0       & 1       \\
            1       & 0       \\
        \end{tabular}
    \end{center}
    \caption{Tabella di verità del circuito in binario}
\end{table}
Si può notare che è la funzione di negazione rappresentata con la seguente
porta logica:
\begin{figure}[H]
	\begin{center}
		\begin{circuitikz}
			\draw (0,0) node[scale=0.7, not port] (not) {};
			\draw (not.in) node[left] {x};
			\draw (not.out) node[right] {O};
		\end{circuitikz}
	\end{center}
    \caption{Porta logica NOT}
\end{figure}

\subsubsection{Circuito del prodotto (AND)}
\begin{figure}[H]
    \begin{center}
        \begin{circuitikz}
            \node (x) at (-2,-0.23) {x};
            \node (y) at (-2,-2.77) {y};
            \node (O) at (1.2,-1.3) {O};

            \node (Vcc) at (-1.5,1.8) {\( V_{cc}=3V \) };

            \filldraw[black] (1,0) circle (1.5pt) node[anchor=west]{};
            \filldraw[black] (-0.28,-0.23) circle (1.5pt) node[anchor=west]{};
            \filldraw[black] (-0.98,-2.77) circle (1.5pt) node[anchor=west]{};
            \filldraw[black] (2,1.55) circle (1.5pt) node[anchor=west]{};
            \filldraw[black] (0,1.55) circle (1.5pt) node[anchor=west]{};

            \draw
                (0,0) node[pmos, anchor=D] (pmos1) {} (0,0) -- (2,0)
                (2,0) node[pmos, anchor=D] (pmos2) {} (2,0)
                (1,0) node[nmos, anchor=D] (nmos1) {} (1,-1)
                (1,-1.54) -- (1,-2) node[nmos, anchor=D] (nmos2) {} (1,-2)
                (nmos2.S) node[ground] {}
                (pmos1.G) to ++(0,-3.542)
                (pmos2.G) to ++(-1.3,0) -- ++(0, -1) to[short] (x)
                (nmos1.G) to ++(-0.3,0) -- ++(0,1)
                (nmos2.G) to[short] (y)
                (-2,1.55) -- ++(5,0)
                (nmos1.S) -- ++(2,0) -- ++(0,1.497)
                ;

            \begin{scope}[shift={(5,1.55)}]
                \draw (-2,0) -- (0,0) to[short,-*] ++(0,0) node[left] {}
                    (1,0) -- (0,0);
                \draw (0,0) node[pmos, anchor=S] (pmos) {}
                    (pmos.G) to[short] ++(0,0) node[left] {}
                    (pmos.D) to[short] ++(0,0) node[left] {}
                    (pmos.D) -- ++(0,0) to[short,-*] (0,-1.6) node[left] {}
                    node[nmos,anchor=D] (nmos) {}
                    (nmos.G) to[short] ++(0,0) node[left] {}
                    (nmos.S) node[ground] {};
                \draw (-2, -1.6) node[above] {} to[short,-*] (-0.99,-1.6) node[left] {}
                    (pmos.G) -- ++(0,0) to[short,-*] (-0.99,-1.6) node[left] {}
                    (0,-1.6) -- ++(0,0) to[short] (1.2,-1.6) node[above] {O}
                    (nmos.G) -- ++(0,0) to[short] (-0.99,-1.6) node[left] {};
                \node (0V) at (0.6,-3.5) {\( 0V \) };
            \end{scope}
            \draw (-2.5,-4.2) -- ++(0,-0.3) -- ++(5,0) node[below, xshift=-2.5cm] {Prodotto negato} -- ++(0,0.3);
            \draw (2.6,-4.2) -- ++(0,-0.3) -- ++(3.7,0) node[below, xshift=-1.85cm] {Porta logica NOT} -- ++(0,0.3);
        \end{circuitikz}
    \end{center}
    \caption{Circuito del prodotto}
\end{figure}
Il prodotto negato più il NOT è uguale ad un AND:
\begin{figure}[H]
    \begin{center}
        \begin{circuitikz}
            \draw (0,0) node[scale=0.7, and port] (and) {};
            \draw (and.in 1) node[left] {x};
            \draw (and.in 2) node[left] {y};
            \draw (and.out) node[right] {O};
        \end{circuitikz}
    \end{center}
    \caption{Porta logica AND}
\end{figure}
La tabella della verità è:
\begin{table}[H]
    \begin{center}
        \begin{tabular}{c|c}
            \( x \)  \( y \) & \( O \) \\
            \hline
            0        0       & 0       \\
            0        1       & 0       \\
            1        0       & 0       \\
            1        1       & 1       \\
        \end{tabular}
    \end{center}
    \caption{Tabella di verità del circuito}
\end{table}

\subsubsection{Circuito della somma (OR)}
\begin{figure}[H]
    \begin{center}
        \begin{circuitikz}
            \draw (0,0) node[scale=0.7, or port] (and) {};
            \draw (and.in 1) node[left] {x};
            \draw (and.in 2) node[left] {y};
            \draw (and.out) node[right] {O};
        \end{circuitikz}
    \end{center}
    \caption{Porta logica OR}
\end{figure}
La tabella della verità è:
\begin{table}[H]
    \begin{center}
        \begin{tabular}{c|c}
            \( x \)  \( y \) & \( O \) \\
            \hline
            0        0       & 0       \\
            0        1       & 1       \\
            1        0       & 1       \\
            1        1       & 1       \\
        \end{tabular}
    \end{center}
    \caption{Tabella di verità della somma}
\end{table}

\section{Espressione in somma di prodotti}
Il seguente circuito è un esempio di espressione in somma di prodotti dell'esempio \ref{ex:modelloAB}:
\begin{figure}[H]
    \begin{center}
        \begin{circuitikz}
            \draw (0,0) node[label=left:\( A \) ] (A) {}
                to[short, o-]
                (2,0)
                node[not port, anchor=in, scale=0.5,label=above:\( \bar{A} \) ] (not1) {}
                (0,-1)
                node[label=left:\( B \) ] (B) {}
                to[short, o-]
                (2,-1)
                node[not port, anchor=in, scale=0.5,label=below:\( \bar{B} \) ] (not2) {}
                (4,-0.5) node[and port, label={above, yshift=3mm}:{\( m_{0} = \bar{A} \cdot \bar{B} \)}, scale=0.5,] (and1) {}
                (not1.out) to[short] ++(0.25,0) |- (and1.in 1)
                (not2.out) to[short] ++(0.25,0) |- (and1.in 2)
                (2,-2.5) node[and port, anchor=in 1, label={below, yshift=-3mm}:{\( m_{3} = A \cdot B \)}, scale=0.5,] (and2) {}
                (and2.in 1) to[short] ++(-0.5,0)
                to[short, -*] (1.5,0)
                (and2.in 2) to[short] ++(-1,0)
                to[short, -*] (1,52 |- not2.in)
                (and1.out) to[short] ++(1.7,0)
                node[or port, anchor=in 1, label={above, yshift=3mm}:{\( O = m_{0} + m_{3} \)}, scale=0.5,] (or1) {}
                (or1.in 2) to[short] ++(-0.5,0) |- (and2.out)
                (or1.out) to[short, -o] ++(0.5,0) node[label=right:\( O \)] {}
                ;
        \end{circuitikz}
    \end{center}
    \caption{Circuito dell'espressione in somma di prodotti}
\end{figure}
I circuiti devono spesso tenere conto di alcune specifiche da ottimizzare:
\begin{itemize}
	\item \textbf{Area}: minor numero di porte logiche
	\item \textbf{Latency}: più porte logiche si attraversano più sarà il ritardo
	\item \textbf{Power}: più porte logiche si attraversano più sarà
	      il consumo
	\item \textbf{Safety}: più porte logiche si attraversano più sarà
	      la probabilità di errore
\end{itemize}
Prendiamo in considerazione la funzione \( f(B^3)\footnote{Il numero di funzioni booleane
	possibili è \( 2^{2^3} = 256 \) e il valore cresce esponenzialmente con
	l'aumento dei bit}\to B \):
    \begin{table}[H]
        \begin{center}
            \begin{tabular}{c|c}
                X Y Z   & O \\
                \hline
                0\;0\;0 & 0 \\
                0\;0\;1 & 1 \\
                0\;1\;0 & 0 \\
                0\;1\;1 & 1 \\
                1\;0\;0 & 0 \\
                1\;0\;1 & 1 \\
                1\;1\;0 & 0 \\
                1\;1\;1 & 1 \\
            \end{tabular}
        \end{center}
        \caption{Tabella di verità della funzione}
    \end{table}
ON-SET\(=\{ m_1,m_3,m_5,m_7 \} \)\\
La funzione rappresentata con un'espressione in somma di prodotti è:
\[ O=m_1+m_3+m_5+m_7 = \bar{X}\bar{Y}Z + \bar{X}YZ + X\bar{Y}Z + XYZ \]
Proviamo a stimare le dimensioni di questo circuito. Si utilizza il concetto
di \textbf{letterale} che è una coppia chiave-valore. La funzione \( O \)
è composta da 12 letterali e questo numero è in relazione con il numero di
transistor nel senso che se una funzione ha più letterali di un altra si può
già sapere che avrà bisogno di un minor numero di transistor.


\subsection{Tecniche di ottimizzazione}
La regola principale dell'ottimizzazione è l'\textbf{assorbimento}:
Preso un prodottp \( P \)  moltiplicato ad un letterale \( a \) e la somma di
questo prodotto, ma con il letterale negato \( \bar{a} \) allora il risultato
è \( P \cdot  (a+\bar{a}) \) dove \( (a+\bar{a}) \) fa sempre 1, quindi rimane
\( P \).
\[
	aP+\bar{a}P=P \cdot (a+\bar{a}) = P
\]

\[
    \underbrace{2 \cdot (|P|+1)}_{\text{Cardinalità prima dell'assorbimento}} \Rightarrow \underbrace{|P|}_{\text{Cardinalità dopo l'assorbimento}}
\]
Quindi se prendiamo come riferimento la funzione \( O \) si può applicare la
regola dell'assorbimento per ridurre il numero di letterali:
\begin{center}
	\begin{tikzpicture}
		\node (1) at (0,0) {\( \bar{X}\bar{Y}Z+\bar{X}YZ+X\bar{Y}Z+XYZ \)};
		\node (2) at (0,-1) {\( \bar{X}Z(\bar{Y}+Y)+XZ(\bar{Y}+Y) \)};

		\draw[->, draw] (-1.9, -0.2) to (-1.3, -0.7);
		\draw[->, draw] (-0.7, -0.2) to (-0.55,-0.7);
		\draw[->, draw] (0.65, -0.2) to (1, -0.7);
		\draw[->, draw] (1.9, -0.2) to (1.8, -0.7);

	\end{tikzpicture}
\end{center}
E riapplicando la regola si arriva al minimo:
\begin{center}
	\begin{tikzpicture}
		\node (3) at (0,-2) {\( \bar{X}Z+XZ \)};
		\node (4) at (0,-3) {\( Z(\bar{X}+X) \)};

		\draw[->, draw] (-0.7, -2.2) to (-0.3,-2.7);
		\draw[->, draw] (0.4, -2.2) to (0.5, -2.7);
	\end{tikzpicture}
\end{center}
\[
	Z
\]
\subsection{Terminologia}
Ogni mintermine è un prodotto (o implicante), ma dopo aver applicato la regola
di assorbimento non è più un mintermine, ma soltanto prodotto (o implicante).
\[
	\bar{X}\bar{Y}Z \to \bar{X}Z
\]
La \( Y \) non c'è più nel risultato dell'assorbimento, ciò vuol dire che non
ci interessa il suo valore perchè non varia il risultato. Si può scrivere sia
\(
11
\)
che
\(
1-1
\)\\
Quindi ad esempio:\\
\( Z=--1=4\; \)mintermini: \( \{ 001, 011, 101, 111 \} \)
\begin{definition}
	\textbf{Implicante primo} è un implicante non contenuto in nessun altro
	implicante
\end{definition}

\begin{figure}[H]
    \begin{definition}
        La \textbf{distanza di Hamming} è il numero di bit che differenziano 2 codici.
        \begin{center}
            \( 01 \textbf{10} \to 01 \textbf{01}\; \) distanza di Hamming = 2\\
            \( 01 \textbf{0} \to 01 \textbf{1}\; \) distanza di Hamming = 1
        \end{center}
    \end{definition}
\end{figure}
\section{Assorbimento svolto graficamente}
Prendendo come riferimento la funzione \( f(B^3)^1 \to B \)  definita precedentemente (che chiameremo \( O \)) 
si può guardare la funzione come se fosse sul piano cartesiano con centro in
un punto qualsiasi. Ogni punto adiacente al centro è un punto con distanza di
Hamming = 1.
\begin{figure}[H]
    \begin{center}
        \begin{tikzpicture}[x=0.5cm,y=0.5cm,z=0.3cm,>=stealth]
            \draw[->] (xyz cs:x=0) -- (xyz cs:x=6) node[above] {$x$};
            \draw[->] (xyz cs:y=0) -- (xyz cs:y=6) node[right] {$z$};
            \draw[->] (xyz cs:z=0) -- (xyz cs:z=6) node[above] {$y$};

            \node[below] (000) at (0,0,0) {\( 000 \)};
            \node[right] (001) at (0,0,6) {\( 001 \)};
            \node[left] (010) at (0,6,0) {\( 010 \)};
            \node[below] (011) at (6,0,0) {\( 011 \)};
        \end{tikzpicture}
    \end{center}
    \caption{Funzione rappresentata su un piano cartesiano}
\end{figure}
L'assorbimento può essere fatto soltanto tra gli ON-SET con distanza di
Hamming = 1.
Per effettuare l'assorbimento ci si posiziona nel punto di un mintermine e si
"guarda" in tutte le direzioni per eventuali altri mintermini con cui fare il
prodotto.

Nella seguente figura i vertici rossi rappresentano gli OFF-SET e i vertici
blu rappresentano gli ON-SET.
\begin{figure}[H]
	\begin{center}
		\begin{tikzpicture}
        \newcommand{\Depth}{3}
        \newcommand{\Height}{3}
        \newcommand{\Width}{3}

        \coordinate (O) at (0,0,0);
        \coordinate (A) at (0,\Width,0);
        \coordinate (B) at (0,\Width,\Height);
        \coordinate (C) at (0,0,\Height);
        \coordinate (D) at (\Depth,0,0);
        \coordinate (E) at (\Depth,\Width,0);
        \coordinate (F) at (\Depth,\Width,\Height);
        \coordinate (G) at (\Depth,0,\Height);

        \draw[] (O) -- (C) -- (G) -- (D) -- cycle;% Bottom Face
        \draw[] (O) -- (A) -- (E) -- (D) -- cycle;% Back Face
        \draw[] (O) -- (A) -- (B) -- (C) -- cycle;% Left Face
        \draw[opacity=0.8] (D) -- (E) -- (F) -- (G) -- cycle;% Right Face
        \draw[opacity=0.6] (C) -- (B) -- (F) -- (G) -- cycle;% Front Face
        \draw[opacity=0.8] (A) -- (B) -- (F) -- (E) -- cycle;% Top Face

        \draw[fill, red] (C) circle (2pt) node[below] {\( 000 \)};
        \draw[fill, red] (B) circle (2pt) node[left] {\( 010 \)};
        \draw[fill, red] (F) circle (2pt) node[right] {\( 110 \)};
        \draw[fill, red] (G) circle (2pt) node[below] {\( 100 \)};
        \draw[fill, blue] (O) circle (2pt) node[left] {\( 001 \)};
        \draw[fill, blue] (A) circle (2pt) node[above] {\( 011 \)};
        \draw[fill, blue] (E) circle (2pt) node[above] {\( 111 \)};
        \draw[fill, blue] (D) circle (2pt) node[right] {\( 101 \)};

        \draw[fill, red] (4, 3) rectangle ++(0.3, 0.3) node[below right, yshift=1mm] {OFF-SET}; 
        \draw[fill, blue] (4, 2.5) rectangle ++(0.3, 0.3) node[below right, yshift=1mm] {ON-SET}; 
    \end{tikzpicture}
	\end{center}
    \caption{Funzione rappresentata su un cubo}
\end{figure}
Si trascura la faccia del cubo con l'OFF-SET per rendere la rappresentazione più semplice.
Prendendo coppie di vertici dell'ON-SET sullo stesso lato del cubo si può fare il prodotto tra i 2 mintermini:
\begin{figure}[H]
    \begin{center}
        \begin{tikzpicture}
            \newcommand{\Depth}{3}
            \newcommand{\Height}{3}
            \newcommand{\Width}{3}

            \coordinate (O) at (0,0,0);
            \coordinate (A) at (0,\Width,0);
            \coordinate (B) at (0,\Width,\Height);
            \coordinate (C) at (0,0,\Height);
            \coordinate (D) at (\Depth,0,0);
            \coordinate (E) at (\Depth,\Width,0);
            \coordinate (F) at (\Depth,\Width,\Height);
            \coordinate (G) at (\Depth,0,\Height);

            \draw[] (O) -- (A) -- (E) -- (D) -- cycle;% Back Face

            \draw[fill, blue] (O) circle (2pt) node[below] {\( 001 \)};
            \draw[fill, blue] (A) circle (2pt) node[above] {\( 011 \)};
            \draw[fill, blue] (E) circle (2pt) node[above] {\( 111 \)};
            \draw[fill, blue] (D) circle (2pt) node[below] {\( 101 \)};

            \node[below, blue] (1) at (1.5,0,0) {\( \bar{Y}Z \)};
            \node[above, blue] (2) at (1.5,3,0) {\( YZ \)};
            \node[left, blue] (3) at (0,1.5,0) {\( \bar{X}Z \)};
            \node[right, blue] (4) at (3,1.5,0) {\( XZ \)};
        \end{tikzpicture}
    \end{center}
    \caption{Prima semplificazione} 
\end{figure}
Ora si può fare l'assorbimento anche tra i prodotti ottenuti dall'assorbimento:
\begin{figure}[H]
    \begin{center}
        \begin{tikzpicture}
            \newcommand{\Depth}{3}
            \newcommand{\Height}{3}
            \newcommand{\Width}{3}

            \coordinate (O) at (0,0,0);
            \coordinate (A) at (0,\Width,0);
            \coordinate (B) at (0,\Width,\Height);
            \coordinate (C) at (0,0,\Height);
            \coordinate (D) at (\Depth,0,0);
            \coordinate (E) at (\Depth,\Width,0);
            \coordinate (F) at (\Depth,\Width,\Height);
            \coordinate (G) at (\Depth,0,\Height);

            \draw[] (O) -- (A) -- (E) -- (D) -- cycle;% Back Face

            \draw[fill, blue] (O) circle (2pt) node[below] {\( 001 \)};
            \draw[fill, blue] (A) circle (2pt) node[above] {\( 011 \)};
            \draw[fill, blue] (E) circle (2pt) node[above] {\( 111 \)};
            \draw[fill, blue] (D) circle (2pt) node[below] {\( 101 \)};

            \node[below, blue] (1) at (1.5,0,0) {\( \bar{Y}Z \)};
            \node[above, blue] (2) at (1.5,3,0) {\( YZ \)};
            \node[left, blue] (3) at (0,1.5,0) {\( \bar{X}Z \)};
            \node[right, blue] (4) at (3,1.5,0) {\( XZ \)};

            \node[blue] (5) at (1.5,1.5,0) {\textbf{Z}};
        \end{tikzpicture}
    \end{center}
    \caption{Seconda semplificazione} 
\end{figure}
Si arriva quindi a dire che \( Z \) è un \textbf{implicante primo} perchè non c'è nessun
altro implicante che lo contiene.
\begin{figure}[H]
	\begin{define}
		Quando si parla di implicante si può anche dire \textbf{sottocubo} e
		l'implicante primo può essere chiamato anche \textbf{sottocubo di dimensione
			massima}.
		\begin{center}
			Implicante = Sottocubo\\
			Implicante primo = Sottocubo di dimensione massima
		\end{center}
	\end{define}
\end{figure}
Esistono condizioni favorevoli (come la funzione \( O \) ) in cui un implicante primo
contiene tutti i mintermini della funzione.\\
Ci sono più tipi di implicanti primi:
\begin{itemize}
	\item \textbf{Essenziali}: includono almeno un mintermine che non è coperto da nessun
	      altro implicante primo (fanno parte della soluzione finale).
	\item \textbf{Non essenziali}:  Implicanti primi che coprono mintermini
	      coperti anche da altri implicanti.
	      Si identificano con l'\textbf{algoritmo di copertura}
\end{itemize}
\subsection{Mappe di Karnaugh}
Karnaugh ha creato una mappa che permette di rappresentare su un piano tutte
le variabili booleane (nel caso della funzione \( O \)  si mettono i valori del cubo
nella tabella) in modo da poter fare l'assorbimento in modo più semplice. I valori
posti sopra le celle sono messi in modo che siano a distanza di Hamming = 1.
Nella seguente mappa di Karnaugh si possono vedere i valori della funzione \( O \):
\begin{table}[H]
    \begin{center}
        \begin{karnaugh-map}[4][2][1][\( Y \)][\( X \)][\( Z \)]
            \minterms{4,5,7,6}
            \autoterms[0]
            \implicant{4}{6}
        \end{karnaugh-map}
    \end{center}
    \caption{Mappa di Karnaugh della funzione \( O \)}
\end{table}
In questa mappa si può vedere che \( Z \) è un implicante primo
(o sottocubo di dimensione massima).
Le mappe di Karnaugh sono come una sfera, quindi se si va oltre il bordo si torna
dall'altra parte.

Un altro esempio di mappa di Karnaugh è il seguente:
\begin{example}
    Prendiamo in considerazione una funzione casuale a 4 variabili:
    \begin{table}[H]
        \begin{center}
            \begin{karnaugh-map}[4][4][1][\( Y \)][\( X \)][\( V \)][\( Z \)]
                \minterms{0,1,2,3,7,15,14,8,9,11,10}
                \autoterms[0]
                \implicantedge{0}{2}{8}{10}
                \implicant{15}{10}
                \implicant{3}{11}
            \end{karnaugh-map}    
        \end{center}
        \caption{Mappa di Karnaugh di una funzione casuale}
    \end{table}
    Si può verificare che ci sono 3 implicanti primi essenziali:
    \begin{itemize}
        \item \( \bar{V} \): essenziale
            \item \( XY \): essenziale perchè copre \( 1101 \)
                \item \( XZ \): essenziale perchè copre \( 1011 \) 
    \end{itemize}
    \[
    O=\bar{V}+XY+XZ\;\;\;(5\;letterali)
    \] 
    Per capire quali sono gli implicanti primi bisogna raggruppare gli 1 in rettangoli
    più grandi possibile, ma sempre di grandezza \( 2^n \) (2, 4, 8, 16, \( \ldots \)).
    Per ciascun raggruppamento bisogna trovare le variabili che non cambiano il loro valore.
    Per il raggruppamento rosso:
    \begin{itemize}
        \item \textbf{\( X \)} cambia valore, passando da \( 0 \)  in \( 0000 \) e \( 0100 \)
            a \( 1 \)  in \( 1100 \) e \( 1000 \), quindi deve essere esclusa.
        \item \textbf{\( Y \)} cambia valore, passando da \( 0 \)  in \( 0000 \) e \( 1000 \)
            a \( 1 \)  in \( 0100 \) e \( 1100 \), quindi deve essere esclusa.
        \item \textbf{\( Z \)} cambia valore, passando da \( 0 \)  in \( 0000 \)
            a \( 1 \)  in \( 0010 \), quindi deve essere esclusa.
        \item \textbf{\( \bar{V} \)} mantiene lo stesso stato in tutto il gruppo, quindi
            deve essere inclusa nel prodotto risultante
    \end{itemize}
    Lo stesso ragionamento viene applicato per tutti i gruppi, fino ad arrivare al risultato finale.
\end{example}
Le mappe di Karnaugh sono utili soltanto se le variabili sono meno di 5, altrimenti
bisogna usare più mappe.



\section{Metodo di Quine-McCluskey}
Questo metodo ha 2 versioni:
\begin{itemize}
    \item Funzioni completamente specificate
        \item Funzioni parzialmente specificate
\end{itemize}
Si divide in 2 fasi:
\begin{enumerate}
\item Si espande il più possibile il problema per cercare il massimo grado di minimizzazione.
    (ad esempio trattando un \emph{don't care} come 1 per permettere ulteriori ottimizzazioni)
    \item Bisogna capire quali servono veramente.
\end{enumerate}

\subsection{Esempio con funzione completamente specificata}
\begin{example}
    Prendiamo una funzione completamente specificata
   \[
       O = f(x,y,z,w) = \{ m_1, m_4, m_5, m_6, m_7, m_9, m_{11}, m_{14}, m_{15} \}
   \]  
   \begin{table}[H]
       \begin{center}
           \begin{tabular}{c|c}
               \( m \) & \( x\;y\;z\;w \)\\
               \hline
               \( 1 \) & \( 0\;0\;0\;1 \)\\ 
               \( 4 \) & \( 0\;1\;0\;0 \)\\
               \( 5 \) & \( 0\;1\;0\;1 \)\\
               \( 6 \) & \( 0\;1\;1\;0 \)\\
               \( 7 \) & \( 0\;1\;1\;1 \)\\
               \( 9 \) & \( 1\;0\;0\;1 \)\\ 
               \( 11 \) & \( 1\;0\;1\;1 \)\\
               \( 14 \) & \( 1\;1\;1\;0 \)\\
               \( 15 \) & \( 1\;1\;1\;1 \)\\
           \end{tabular}
       \end{center}
       \caption{Tabella dei mintermini}
       \label{tab:quine-mccluskey1}
   \end{table}
    
   36 Letterali.\\
   L'unico caso in cui due stringhe sono a distanza di Hamming \( =1 \) è quando il numero di \( 1 \) differisce di uno.\\
   Il metodo di Quine-McCluskey riordina le \( m \)  in base al numero di \( 1 \) che contengono,
   questo è il primo passo:
   \begin{table}[H]
       \begin{center}
           \begin{tabular}{c|c|c}
               \( m \) &  x y z w  &\\
               \hline
               \( 1 \) &  0 0 0 1&\(\surd \)\\ 
               \( 4 \) & 0 1 0 0&\(\surd \)\\
               \hline
               \( 5 \) &  0 1 0 1&\(\surd \)\\
               \( 6 \) & 0 1 1 0&\(\surd \)\\
               \( 9 \) & 1 0 0 1&\(\surd \)\\ 
               \hline
               \( 7 \) &  0 1 1 1& \(\surd \)\\
               \( 11 \) & 1 0 1 1&\(\surd \)\\
               \( 14 \) & 1 1 1 0&\(\surd \)\\
               \hline
               \( 15 \) & 1 1 1 1&\(\surd \)\\
           \end{tabular}
       \end{center}
       \caption{Tabella riordinata}
       \label{tab:quine-mccluskey2}
   \end{table}
   Si individuano i gruppi che sono a distanza di Hamming 1. Nel prossimo passo
   confrontiamo i gruppi con \( 1\;bit=1 \) e con \( 2\;bit=1 \), se sono a 
   distanza di Hamming 1 allora si mette \emph{don't care} nel bit che cambia.
   Nella prima colonna c'è la coppia di \( m \) che viene confrontata. 
   \begin{table}[H]
       \begin{center}
           \begin{tabular}{c|c|c}
               \( m \) & \( x\;y\;z\;w \)\\
               \hline
               \( 1,\; 5 \) & 0 - 0 1 & A \\ 
               \( 1,\;9 \) & - 0 0 1 & B \\
               \( 4,\;5 \) & 0 1 0 - & \(\surd \)\\
               \( 4,\;6 \) & 0 1 - 0 & \(\surd \)\\
               \hline
               \( 5,\;7 \) & 0 1 - 1 & \(\surd \)\\
               \( 6,\;7 \) & 1 0 1 - & \( \surd \)\\
               \( 6,\;14 \) & - 1 1 0 & \( \surd \)\\
               \( 9,\;11 \) & 1 0 - 1 & C \\
               \hline
               \( 7,\;15 \) & - 1 1 1&\(\surd \)\\
               \( 11,\;15 \) & 1 - 1 1 & D \\
               \( 14,\;15 \) & 1 1 1 - & \(\surd \)\\
           \end{tabular}
       \end{center}
       \caption{Prima semplificazione}
       \label{tab:quine-mccluskey3}
   \end{table}
   Tutti i mintermini della tabella \ref{tab:quine-mccluskey2} sono coperti da un implicante
   della tabella \ref{tab:quine-mccluskey3}.

   Ora si può semplificare anche la tabella \ref{tab:quine-mccluskey3} se i don't care
   sono nella stessa variabile:
   \begin{table}[H]
       \begin{center}
           \begin{tabular}{c|c|c}
               \( m \) & \( x\;y\;z\;w \)\\
               \hline
               \( 4,\; 5, \;6, \;7 \) &  0 1 - -  & E \\ 
               \( 6, \;7, \;14, \;15 \) & - 1 1 - & F\\
           \end{tabular}
       \end{center}
        \caption{Seconda semplificazione}
        \label{tab:quine-mccluskey4}
   \end{table}
   I valori senza \( \surd \) sono implicanti primi perchè non sono coperti da nessun altro implicante
   della tabella \ref{tab:quine-mccluskey4}. Anche i 2 valori nella tabella \ref{tab:quine-mccluskey4} sono
   implicanti primi.\\
   Implicanti primi: \( A,B,C,D,E,F \)
   \[
   A=0-01=\bar{X}\bar{Z}W
\]
   \[
       B=-001=\bar{Y}\bar{Z}W
   \]
   \[
       C=10-1=X\bar{Y}W
   \]
   \[
       D=1-11=XZW
   \]
   \[
       E=01--=\bar{X}Y
   \]
   \[
       F=-11-=YZ
   \]
   16 Letterali.\\
Ad ogni passo del metodo di Quine-McCluskey diminuisce il numero di letterali.

Ora bisogna trovare gli implicanti primi essenziali
\begin{table}[H]
    \begin{center}
        \begin{tabular}{c|c|c|c|c|c|c}
            \( m \) & \( A \) & \( B \) & \( C \) & \( D \) & \( E \) & \( F \)\\ 
            \hline
            \( 1 \) & 1 & 1 &  &  &  &   \\
            \( 4 \) &  &  &  &  & \textbf{1} &   \\
            \( 5 \) & 1 &  &  &  & 1 &   \\
            \( 6 \) &  &  &  &  & 1 & 1  \\
            \( 7 \) &  &  &  &  & 1 & 1  \\
            \( 9 \) &  & 1 & 1 &  &  &   \\
            \( 11 \) &  &  & 1 & 1 &  &  \\
            \( 14 \) &  &  &  &  &  & \textbf{1}  \\
            \( 15 \) &  &  &  & 1 &  & 1  \\
        \end{tabular}
    \end{center}
    \caption{Tabella con implicanti primi}
\end{table}
E ed F sono essenziali perchè coprono \( m_4 \) e \( m_{14} \). Inoltre E ed F coprono
anche \( m_5, m_6, m_7 \) e \( m_6, m_7, m_{14}, m_{15} \).  

Tenendo in mente le \( m \) coperte, la tabella diventa:
\begin{table}[H]
    \begin{center}
        \begin{tabular}{c|c|c|c|c}
        & A & B & C & D\\
        \hline
            \( m_1 \) & 1 & 1 &  &  \\ 
            \( m_9 \) &  & 1 & 1 &  \\
            \( m_{11} \) &  &  & 1 & 1 \\ 
        \end{tabular}
    \end{center}
    \caption{Tabella senza implicanti essenziali}
\end{table}
\paragraph{Eulistica} È un metodo per trovare la soluzione corretta, ma non garantisce
che sia ottima.

Se si cancella ad esempio \( m_1, m_9 \) perchè coperti da \( B \), allora \( B \)
domina \( A \) e \( C \) domina D per la regola di \textbf{dominanza per colonne}.
Prendendo la colonna con più elementi ho più probabilità di trovare la soluzione
ottima.
\[
    O=E+F+B+C = \bar{X}Y+YZ+\bar{Y}\bar{Z}W+X\bar{Y}W
\] 
10 Letterali.\\
La \textbf{pseudo-essenzialità} è l'essenzialità dopo aver già fatto un'ottimizzazione.
\end{example}
\begin{example}
    Dominanza per righe
    \begin{table}[H]
        \begin{center}
            \begin{tabular}{c|c|c|c|c}
            & A & B & C & D\\
            \hline 
                \( \alpha \) & 1 &  & 1 &  \\ 
                \( \beta \) & 1 &  &  & 1 \\
                \( \gamma \) &  & 1 & 1 & 1 \\
                \( \delta \) &  & 1 & 1 &  \\
                \( \epsilon \) & 1 & 1 &  & 1 \\
            \end{tabular}
        \end{center}
        \caption{Tabella con implicanti primi}
    \end{table}
    \begin{itemize}
        \item \( \beta \) dominato da \( \epsilon \) 
            \item \( \delta \) dominato da \( \gamma \) 
    \end{itemize}
    Dobbiamo prendere \( \beta \) e \( \delta \) perchè cancellando \( A \) e \( D \)
    si cancellano anche \( \gamma \) ed \( \epsilon \) perchè sono dominati.  
    La tabella diventa:
    \begin{table}[H]
        \begin{center}
            \begin{tabular}{c|c|c|c|c}
            & A & B & C & D\\
            \hline 
                \( \alpha \) & 1 && 1 &  \\ 
                \( \beta \) & 1 & &  & 1  \\
                \( \delta \) &  & \textbf{1} & 1 & \\
            \end{tabular}
        \end{center}
        \caption{Tabella senza implicanti essenziali}
    \end{table}
    Si fa finta che B e D siano essenziali (essenzialmente scelti a caso).
\end{example}


\subsection{Esempio con funzione parzialmente specificata}
Potrebbe uscire nel risultato un \emph{don't care}, ad esempio per condizioni di 
ingresso non utilizzate.

Prendiamo in considerazione una funzione booleana \( f(B^n)=B \) parzialmente
specificata che viene descritta tramite 3 insiemi:
\begin{itemize}
    \item \textbf{ON-SET}: insieme delle configurazioni per cui vale 1
    \item \textbf{DC-SET}: insieme delle configurazioni per le quali
        la funzione non è specificata
    \item \textbf{OFF-SET}: insieme delle configurazioni per cui vale 0
\end{itemize}
L'intersezione fra i 3 insiemi deve essere vuota, mentre l'unione è l'insieme
di tutte le configurazioni possibili.

Per conoscere tutti e 3 gli insiemi basta conoscerne 2 di essi.
\begin{example}
    Funzione parzialmente specificata
    \begin{table}[H]
        \begin{center}
            \begin{tabular}{c|c}
                x y z v & 0\\
                \hline
                0 0 0 0 & 0\\
                0 0 0 1 & 0\\
                0 0 1 0 & 0\\
                0 0 1 1 & -\\
                0 1 0 0 & 1\\
                0 1 0 1 & -\\
                0 1 1 0 & -\\
                0 1 1 1 & -\\
                1 0 0 0 & 0\\
                1 0 0 1 & 0\\
                1 0 1 0 & 1\\
                1 0 1 1 & 1\\
                1 1 0 0 & 0\\
                1 1 0 1 & 1\\
                1 1 1 0 & 1\\
                1 1 1 1 & 1\\
            \end{tabular}
        \end{center}
        \caption{Tabella della funzione parzialmente specificata}
    \end{table}
        \[ON-SET = \{ m_4,m_{10},m_{11},m_{13},m_{14},m_{15} \} \]
        \[
        DC-SET = \{ m_3,m_5,m_6,m_7 \}
        \] 
        Il primo passo è quello di ampliare il problema, quindi si considerano i
        don't care come 1, e poi rioridnare i mintermini in base al numero di 1.
        \begin{table}[H]
            \begin{center}
                \begin{tabular}{c|c|c}
                    m & x y z v &\\
                    \hline
                    4 & 0 1 0 0 & \( \surd \) \\
                    \hline
                    3 & 0 0 1 1 &\( \surd \) \\
                    5 & 0 1 0 1 &\( \surd \) \\
                    6 & 0 1 1 0 &\( \surd \) \\
                    10 & 1 0 1 0&\( \surd \) \\
                    \hline
                    7 & 0 1 1 1&\( \surd \) \\
                    11 & 1 0 1 1&\( \surd \) \\
                    13 & 1 1 0 1&\( \surd \) \\
                    14 & 1 1 1 0&\( \surd \) \\
                    \hline
                    15 & 1 1 1 1&\( \surd \) \\
                \end{tabular}
            \end{center}
            \caption{Tabella riordinata}
        \end{table}
        Il secondo passo è quello di tentare la semplificazione:
        \begin{table}[H]
            \begin{center}
                \begin{tabular}{c|c|c}
                    m & x y z v& \\
                    \hline
                    4, 5 & 0 1 0 -& \( \surd \) \\
                    4, 6 & 0 1 - 0& \( \surd \) \\
                    \hline
                    3, 7 & 0 - 1 1& \( \surd \) \\
                    3, 11 & - 0 1 1& \( \surd \) \\
                    5, 7 & 0 1 - 1& \( \surd \) \\
                    5, 13 & - 1 0 1& \( \surd \) \\
                    6, 7 & 0 1 1 -& \( \surd \) \\
                    6, 14 & - 1 1 0& \( \surd \) \\
                    10, 11 & 1 0 1 -& \( \surd \) \\
                    10, 14 & 1 - 1 0& \( \surd \) \\
                    \hline
                    7, 15 & - 1 1 1& \( \surd \) \\
                    11, 15 & 1 - 1 1& \( \surd \) \\
                    13, 15 & 1 1 - 1& \( \surd \) \\
                    14, 15 & 1 1 1 -& \( \surd \) \\
                \end{tabular}
            \end{center}
            \caption{Prima semplificazione}
        \end{table}
        Ora si applica di nuovo la semplificazione:
        \begin{table}[H]
            \begin{center}
                \begin{tabular}{c|c|c}
                    m & x y z v&\\
                    \hline
                    4, 5, 6, 7 & 0 1 - -& A\\
                    \hline
                    3, 7, 11, 15 & - - 1 1& B\\
                    5, 7, 13, 15 & - 1 - 1& C\\
                    6, 7, 14, 15 & - 1 1 -& D\\
                    10, 11, 14, 15 & 1 - 1 -& E\\
                \end{tabular}
            \end{center}
            \caption{Seconda semplificazione}
        \end{table}
        Visto che non si possono fare ulteriori semplificazioni \( A, B, C, D, E \)
        sono tutti implicanti primi.

        Ora si cerca di capire quali sono gli implicanti primi essenziali considerando
        però soltanto l'ON-SET:
        \begin{table}[H]
            \begin{center}
                \begin{tabular}{c|c|c|c|c|c}
                    m & A & B & C & D & E \\
                    \hline
                    \( m_4 \) & \textbf{1} &  &  &  &  \\ 
                    \hline
                    \( m_{10} \) &  &  &  &  & \textbf{1} \\
                    \hline
                    \( m_{11} \) &  & 1 &  &  & 1 \\
                    \hline
                    \( m_{13} \) &  &  & \textbf{1} &  &  \\
                    \hline
                    \( m_{14} \) &  &  &  & 1 & 1 \\
                    \hline
                    \( m_{15} \) &  & 1 & 1 & 1 & 1 
                \end{tabular}
            \end{center}
            \caption{Tabella con implicanti primi}
        \end{table}
        Si cancellano le righe \( A, C, E \) perchè sono implicanti primi essenziali,
        quindi si coprono anche tutte le righe delle colonne \( A, C, E \) che
        contengono 1. Si arriva quindi a coprire tutta la tabella e il risultato
        finale è:
        \[
        O = A + C + E
        \] 
\end{example}



\section{Circuiti Combinatori}
\begin{itemize}
    \item \textbf{PROM}: Programmable Read Only Memory (ROM)
        \item \textbf{PLA}: Programmable Logic Array, attivano diverse porte logiche
\end{itemize}
I circuiti a 2 livelli sono composti da 2 livelli di porte logiche:
\begin{enumerate}
    \item Porte AND
        \item Porte OR
\end{enumerate}

\subsubsection{PLA (Programmable Logic Array)}
\begin{example}
    Un esempio di PLA:
    \textcolor{blue}{\[
        O_1 = \bar{X}Y + YV + XZ
    \] }
    \textcolor{red}{\[
        O_2 = \bar{X}\bar{Y} + YV + X\bar{Z}
    \] }
    \begin{figure}[H]
        \begin{center}
            \begin{tikzpicture}
                \node (x) at (0,0) {\( X \)};
                \draw (x) -- ++(0,0.5) -- ++(-0.3,0) -- ++(0,0.3) node[buffer port, anchor=in, scale=0.35, yscale=1.3, rotate=90] (notx1) {};
                \draw (x) -- ++(0,0.5) -- ++(0.3,0) -- ++(0,0.3) node[not port, anchor=in, scale=0.35, yscale=1.3, rotate=90] (notx2) {};

                \node (y) at (1.2,0) {\( Y \)};
                \draw (y) -- ++(0,0.5) -- ++(-0.3,0) -- ++(0,0.3) node[buffer port, anchor=in, scale=0.35, yscale=1.3, rotate=90] (noty1) {};
                \draw (y) -- ++(0,0.5) -- ++(0.3,0) -- ++(0,0.3) node[not port, anchor=in, scale=0.35, yscale=1.3, rotate=90] (noty2) {};

                \node (z) at (2.4,0) {\( Z \)};
                \draw (z) -- ++(0,0.5) -- ++(-0.3,0) -- ++(0,0.3) node[not port, anchor=in, scale=0.35, yscale=1.3, rotate=90] (notz1) {};
                \draw (z) -- ++(0,0.5) -- ++(0.3,0) -- ++(0,0.3) node[buffer port, anchor=in, scale=0.35, yscale=1.3, rotate=90] (notz2) {};

                \node (v) at (3.6,0) {\( V \)};
                \draw (v) -- ++(0,0.5) -- ++(-0.3,0) -- ++(0,0.3) node[not port, anchor=in, scale=0.35, yscale=1.3, rotate=90] (notv1) {};
                \draw (v) -- ++(0,0.5) -- ++(0.3,0) -- ++(0,0.3) node[buffer port, anchor=in, scale=0.35, yscale=1.3, rotate=90] (notv2) {};


                \draw (notx1) -- ++(0,5);
                \draw (notx2) -- ++(0,5);

                \draw (noty1) -- ++(0,5);
                \draw (noty2) -- ++(0,5);

                \draw (notz1) -- ++(0,5);
                \draw (notz2) -- ++(0,5);

                \draw (notv1) -- ++(0,5);
                \draw (notv2) -- ++(0,5);

                \node[and port, anchor=out, scale=0.5] (and1) at (5.5,6.12) {\( p_1 \)};
                \draw (notx1.out |- 52, 52 |- and1.out) -- (4.6, 52 |- and1.out) |- (and1.in 1);
                \draw  (4.6, 52 |- and1.out) |- (and1.in 2);

                \node[and port, anchor=out, scale=0.5] (and2) at (5.5,5.12) {\( p_2 \)};
                \draw (notx1.out |- 52, 52 |- and2.out) -- (4.6, 52 |- and2.out) |- (and2.in 1);
                \draw  (4.6, 52 |- and2.out) |- (and2.in 2);

                \node[and port, anchor=out, scale=0.5] (and3) at (5.5,4.12) {\( p_3 \)};
                \draw (notx1.out |- 52, 52 |- and3.out) -- (4.6, 52 |- and3.out) |- (and3.in 1);
                \draw  (4.6, 52 |- and3.out) |- (and3.in 2);

                \node[and port, anchor=out, scale=0.5] (and4) at (5.5,3.12) {\( p_4 \)};
                \draw (notx1.out |- 52, 52 |- and4.out) -- (4.6, 52 |- and4.out) |- (and4.in 1);
                \draw  (4.6, 52 |- and4.out) |- (and4.in 2);

                \node[and port, anchor=out, scale=0.5] (and5) at (5.5,2.12) {\( p_5 \)};
                \draw (notx1.out |- 52, 52 |- and5.out) -- (4.6, 52 |- and5.out) |- (and5.in 1);
                \draw  (4.6, 52 |- and5.out) |- (and5.in 2);

                \node[or port, anchor=out, scale=0.5, rotate=-90] (or1) at (6.5,0.5) {};
                \node[or port, anchor=out, scale=0.5, rotate=-90] (or2) at (7.5,0.5) {};
                \node[below] at (or1.out) {\( O_1 \)};
                \node[below] at (or2.out) {\( O_2 \)};

                \draw (and1.out |- 52, 52 |- and1.out) -- (or2.out |- 52, 52 |- and1.out);
                \draw (and2.out |- 52, 52 |- and2.out) -- (or2.out |- 52, 52 |- and2.out);
                \draw (and3.out |- 52, 52 |- and3.out) -- (or2.out |- 52, 52 |- and3.out);
                \draw (and4.out |- 52, 52 |- and4.out) -- (or2.out |- 52, 52 |- and4.out);
                \draw (and5.out |- 52, 52 |- and5.out) -- (or2.out |- 52, 52 |- and5.out);

                \draw (or1.out |- 52, 52 |- or1.in 1) -- (or1.out |- 52, 52 |- and1.out);
                \draw (or1.out |- 52, 52 |- or1.in 1) |- (or1.in 1);
                \draw (or1.out |- 52, 52 |- or1.in 1) |- (or1.in 2);

                \draw (or2.out |- 52, 52 |- or2.in 1) -- (or2.out |- 52, 52 |- and1.out);
                \draw (or2.out |- 52, 52 |- or2.in 1) |- (or2.in 1);
                \draw (or2.out |- 52, 52 |- or2.in 1) |- (or2.in 2);

                \draw[fill, circle, red] (notx1.out |- 52, 52 |- and1.out) circle [radius=0.08] node[anchor=west] {};
                \draw[fill, circle, red] (notx2.out |- 52, 52 |- and2.out) circle [radius=0.08] node[anchor=west] {};
                \draw[fill, circle, red] (noty2.out |- 52, 52 |- and2.out) circle [radius=0.08] node[anchor=west] {};
                \draw[fill, circle, red] (notz2.out |- 52, 52 |- and1.out) circle [radius=0.08] node[anchor=west] {};

                \draw[fill, circle, red] (or2.out |- 52, 52 |- and1.out) circle [radius=0.08] node[anchor=west] {};
                \draw[fill, circle, red] (or2.out |- 52, 52 |- and2.out) circle [radius=0.08] node[anchor=west] {};
                \draw[fill, circle, red] (or2.out |- 52, 52 |- and4.out) circle [radius=0.08] node[anchor=west] {};


                \draw[fill, circle, blue] (notx1.out |- 52, 52 |- and3.out) circle [radius=0.08] node[anchor=west] {};
                \draw[fill, circle, blue] (notx2.out |- 52, 52 |- and5.out) circle [radius=0.08] node[anchor=west] {};
                \draw[fill, circle, blue] (noty1.out |- 52, 52 |- and4.out) circle [radius=0.08] node[anchor=west] {};
                \draw[fill, circle, blue] (noty1.out |- 52, 52 |- and5.out) circle [radius=0.08] node[anchor=west] {};
                \draw[fill, circle, blue] (notz1.out |- 52, 52 |- and3.out) circle [radius=0.08] node[anchor=west] {};
                \draw[fill, circle, blue] (notv1.out |- 52, 52 |- and4.out) circle [radius=0.08] node[anchor=west] {};

                \draw[fill, circle, blue] (or1.out |- 52, 52 |- and3.out) circle [radius=0.08] node[anchor=west] {};
                \draw[fill, circle, blue] (or1.out |- 52, 52 |- and4.out) circle [radius=0.08] node[anchor=west] {};
                \draw[fill, circle, blue] (or1.out |- 52, 52 |- and5.out) circle [radius=0.08] node[anchor=west] {};
            \end{tikzpicture}
        \end{center}
        \caption{PLA}
    \end{figure}
    Prende in input coppie di variabili e le assegna ad un array di AND e l'output
    di questi AND viene assegnato ad un array di OR.
\end{example}

\subsubsection{CPLD (Complex Programmable Logic Device)}
I CPLD attivano diversi PLA:
\begin{figure}[H]
   \begin{center}
    \begin{tikzpicture}
        \draw (-3,-2) rectangle (3, 2);
        \node[align=center, draw] at (0,0) (ip) {Interconnected\\
            programming};

        \node[align=center, draw] at (2,1) (pla1) {PLA};
        \draw (pla1) -- ++(0,0.5) node[above, draw, scale=0.6] {I/O};

        \node[align=center, draw] at (2,-1) (pla2) {PLA};
        \draw (pla2) -- ++(0,-0.5) node[below, draw, scale=0.6] {I/O};

        \node[align=center, draw] at (-2,1) (pla3) {PLA};
        \draw (pla3) -- ++(0,0.5) node[above, draw, scale=0.6] {I/O};

        \node[align=center, draw] at (-2,-1) (pla4) {PLA};
        \draw (pla4) -- ++(0,-0.5) node[below, draw, scale=0.6] {I/O};

        \draw (pla1) -- (ip);
        \draw (pla2) -- (ip);
        \draw (pla3) -- (ip);
        \draw (pla4) -- (ip);
    \end{tikzpicture}
   \end{center} 
   \caption{CPLD}
\end{figure}

\subsubsection{FPGA (Field Programmable Gate Array)}
I FPGA attivano diversi CPLD:
\begin{figure}[H]
   \begin{center}
    \begin{tikzpicture}
        \draw (0,0) rectangle ++(1,1);
        \draw (0,1.3) rectangle ++(0.2,0.2);
        \draw (0.4,1.3) rectangle ++(0.2,0.2);
        \draw (0.8,1.3) rectangle ++(0.2,0.2);

        \draw (0.1,1.3) -- (0.1, 1);
        \draw (0.5,1.3) -- (0.5, 1);
        \draw (0.9,1.3) -- (0.9, 1);

        \draw (1.5,0) rectangle ++(1,1);
        \draw (1.5,1.3) rectangle ++(0.2,0.2);
        \draw (1.9,1.3) rectangle ++(0.2,0.2);
        \draw (2.3,1.3) rectangle ++(0.2,0.2);

        \draw (1.6,1.3) -- (1.6, 1);
        \draw (2,1.3) -- (2, 1);
        \draw (2.4,1.3) -- (2.4, 1);

        \draw (3,0) rectangle ++(1,1);
        \draw (3,1.3) rectangle ++(0.2,0.2);
        \draw (3.4,1.3) rectangle ++(0.2,0.2);
        \draw (3.8,1.3) rectangle ++(0.2,0.2);

        \draw (3.1,1.3) -- (3.1, 1);
        \draw (3.5,1.3) -- (3.5, 1);
        \draw (3.9,1.3) -- (3.9, 1);

        \draw (0,-1.5) rectangle ++(1,1);

        \draw (1.5,-1.5) rectangle ++(1,1);

        \draw (3,-1.5) rectangle ++(1,1);


        \draw (0,-3) rectangle ++(1,1);

        \draw (1.5,-3) rectangle ++(1,1);

        \draw (3,-3) rectangle ++(1,1);

        \draw[<-] (4,1.4) -- ++(0.5, 0) node[right, scale=0.6] {I/O};
        \draw[<-] (4,0.5) -- ++(0.5, 0) node[right, scale=0.8, align=center] {Logic cell\\
            (Interconnected\\
        programming)};

        \draw (0.5,0) -- (0.5,-0.5);
        \draw (2,0) -- (2,-0.5);
        \draw (3.5,0) -- (3.5,-0.5);

        \draw (0.5,-1.5) -- (0.5,-2);
        \draw (2,-1.5) -- (2,-2);
        \draw (3.5,-1.5) -- (3.5,-2);

        \draw (1, 0.5) -- (1.5, 0.5);
        \draw (1,-1) -- (1.5, -1);
        \draw (1,-2.5) -- (1.5, -2.5);

        \draw (2.5, 0.5) -- (3, 0.5);
        \draw (2.5,-1) -- (3, -1);
        \draw (2.5,-2.5) -- (3, -2.5);
    \end{tikzpicture}
   \end{center} 
   \caption{FPGA}
\end{figure}


\subsubsection{SoC (System on Chip)}
I SoC attivano diversi CPLD
\begin{figure}[H]
   \begin{center}
    \begin{tikzpicture}
        \draw (-3,-2) rectangle (3, 1);
        \draw[<->, thick] (-2.5,-1.5) -- (2.5, -1.5);

        \node[draw] at (-1.5,0) (cpu) {CPU};
        \node[draw] at (1.5,0) (ram) {FPGA};

        \draw (cpu) -- (-1.5,-1.5);
        \draw (ram) -- (1.5,-1.5);

        \node[draw] at (0,-3) (ram) {RAM};
        \draw[<->] (ram) -- (0,-1.5);

        \node[draw] at (-2.95,0) (io1) {I\;\;O};
        \node[draw] at (-2.95,-1) (io2) {I\;\;O};
    \end{tikzpicture}
   \end{center} 
   \caption{SoC}
\end{figure}

% Laboratorio
\section{Laboratorio}
\subsection{SIS}
È il successore di \emph{Espresso} e permette di fare la sintesi di circuiti, cioè
si genera passo dopo passo il layout per il silicio.

Il modello di codice di SIS è il seguente:
\begin{lstlisting}[language=Verilog]
    .model <model-male> // nome della funzione
    .inputs <input-list> // elenco degli input
    .outputs <output-list> // elenco degli output

    .names // On-set/Off-set per ogni input
    <command> 
    ...
    <command>

    .end // il file deve essere 
\end{lstlisting}

\begin{example}
   Prendiamo in considerazoine la tabella di verità dell'
   implicazione logica:
   \begin{table}[H]
    \begin{center}
        \begin{tabular}{c|c}
            a b & a \(\implies\) b\\
            \hline
            0 0 & 1\\
            0 1 & 1\\
            1 0 & 0\\
            1 1 & 1\\
        \end{tabular}
    \end{center}
    \caption{Tabella di verità dell'implicazione logica}
   \end{table}
   che si può scrivere anche nel seguente modo:
      \begin{table}[H]
    \begin{center}
        \begin{tabular}{c|c}
            a b & a \(\implies\) b\\
            \hline
            0 - & 1\\
            1 0 & 0\\
            1 1 & 1\\
        \end{tabular}
    \end{center}
    \caption{Tabella di verità ridotta}
   \end{table}

\begin{lstlisting}[language=Verilog]
   .model IMPLIES
   .inputs I1 I2
   .outputs O

   .names I1 I2 O
   // si definisce l'on-set o l'off-set  
   0- 1
   11 1
   .end
\end{lstlisting}
\end{example}

Lista di comandi base:
\begin{itemize}
    \item \textbf{read\_blif}: carica il modello sis;
    \item \textbf{simulate [valori in bit, separati da spazi]}: esegue un passo di
        simulazione del circuito;
    \item \textbf{help}: mostra i comandi disponibili;
    \item \textbf{help [comando]}: mostra la descrizione del comando;
    \item \textbf{print\_stats}: fornisce informazioni sul circuito, quali numero di input
       (pi), output (po), elementi di memoria (latches), letterali (lits(sop)), numero di nodi (nodes);
    \item \textbf{quit}: esce da sis;
    \item \textbf{write\_blif [nome file]}: salva il modello sis in un file;
    \item \textbf{write\_blif}: stampa a video il file blif del circuito caricato in memoria
        senza dover lasciare l'ambiente SIS.
\end{itemize}

\section{Sintesi a N livelli}
\begin{figure}[h]
	\centering
	\begin{tikzpicture}[scale=0.6, domain=0:10]
		\coordinate (A) at (0,5);
		\coordinate (B) at (1,3);
		\coordinate (C) at (2,4);
		\coordinate (D) at (3,2);
		\coordinate (E) at (4,3);
		\coordinate (F) at (5,3);
		\coordinate (G) at (6,2);
		\coordinate (H) at (7,1);
		\coordinate (I) at (8,3);
		\coordinate (J) at (9,2);
		\coordinate (K) at (10,1);

		\draw [->] (0,0) -- (10,0) node[right] {$t$};
		\draw [->] (0,0) -- (0,5) node[above] {Ottimalità (area)};

		\draw [gray!50, ultra thin] (0,0) grid (10,5);
		\draw [blue, ultra thick] plot [smooth, tension=0.8] coordinates { (A) (B) (C) (D) (E) (F) (G) (H) (I) (J) (K) };

        \node[left, align=center] (ottimo) at (-1,3) {Ottimo\\
            locale};
        \draw [->] (ottimo) -- (B);
	\end{tikzpicture}
    \caption{Ottimalità nel tempo}
\end{figure}
\begin{define}
    Il cammino critico è il percorso più lungo che il segnale deve effettuare e indica il ritardo.
\end{define}
In un circuito a 2 livelli riducendo l'area si riduce anche il ritardo.
\begin{figure}[h]
	\centering
	\begin{tikzpicture}[scale=0.6, domain=2:8]
		\coordinate (D) at (3,1);
		\coordinate (F) at (5,2);
		\coordinate (G) at (6,3);
		\coordinate (I) at (8,4);

		\draw [->] (0,0) -- (10,0) node[below, align=center] {area\\
            (numero di letterali)};
		\draw [->] (0,0) -- (0,5) node[above] {ritardo};

		\draw [gray!50, ultra thin] (0,0) grid (10,5);
		\draw [red, thick] (D) -- (F) -- (G) -- (I);
        \draw [blue] (I) -- (D);

		\draw [fill, red] (D) circle [radius=0.1];
		\draw [fill, red] (F) circle [radius=0.1];
		\draw [fill, red] (G) circle [radius=0.1];
		\draw [fill, red] (I) circle [radius=0.1] node[black, right, align=center, scale=0.7] {Somma di\\
            letterali};
	\end{tikzpicture}
    \caption{Ottimalità di circuiti a 2 livelli}
\end{figure}

In circuiti a N livelli il grafico del ritardo e dell'area è un'iperbole:
\begin{figure}[H]
	\begin{center}
		\begin{tikzpicture}
			\draw[->] (-0.2, 0) -- (3, 0) node[below] {area};
			\draw[->] (0, -0.2) -- (0, 3) node[above] {ritardo};
			\draw[domain=0.35:3, smooth, variable=\x, blue, thick] plot ({\x}, {1/\x}) node [below right] {};

            \draw [fill] (1,1) circle [radius=0.05] node[below right] {};
            \draw [->] (1,1) -- ++(-0.2,0.2) node[right, align=center] {};
            \draw [->] (1,1) -- ++(0.2,-0.2) node[right, align=center] {};
		\end{tikzpicture}
	\end{center}
	\caption{Grafico di un circuito a N livelli}
\end{figure}
Quindi bisogna trovare un buon compromesso tra area e ritardo, perchè diminuendo troppo l'area
aumenta anche il ritardo.


\subsection{Network}
\paragraph{DAG} Direct Acyclic Graph. Non permettono la creazione di cicli (Acyclic).
\begin{figure}[H]
   \begin{center}
       \begin{tikzpicture}
           \draw (0,0) circle [radius=0.5];
           \draw (0,2) circle [radius=0.5];
           \draw (0,-2) circle [radius=0.5];
           \draw (2,0) circle [radius=0.5];
           \draw (-2,0) circle [radius=0.5];

           \draw [<-] (0,0.5) -- (0,1.5);
           \draw [->] (0,-0.5) -- (0,-1.5);
           \draw [->] (0.5,0) -- (1.5,0);
           \draw [<-] (-0.5,0) -- (-1.5,0);
           \draw [->] (-1.65,0.35) -- (-0.35,1.65);
       \end{tikzpicture}
   \end{center} 
   \caption{Esempio di DAG}
\end{figure}

Gli input sono dei nodi, e ogni nodo di ingresso avrà soltanto archi uscenti. I nodi di uscita
avranno solo archi entranti. Il numero di letterali è dato dalla somma dei
letterali di tutte le funzioni.
\begin{figure}[H]
    \begin{center}
        \begin{tikzpicture}
            \draw (0,3) circle [radius=0.3] node {X};
            \draw (0,2) circle [radius=0.3] node {Y};
            \draw (0,1) circle [radius=0.3] node {Z};
            \draw (0,0) circle [radius=0.3] node {V};

            \draw (2,2.5) circle [radius=0.3] node {A};
            \draw (2,1.5) circle [radius=0.3] node {B};
            \draw (2,0.5) circle [radius=0.3] node {C};

            \draw (4,2) circle [radius=0.3] node {D};
            \draw (4,1) circle [radius=0.3] node {E};

            \draw (6,2) circle [radius=0.3] node {W};
            \draw (6,1) circle [radius=0.3] node {O};

            % x to a
            \draw [->] (0.3,3) -- (1.7,2.57);
            % y to a
            \draw [->] (0.3,2) -- (1.7,2.43);
            % y to b
            \draw [->] (0.3,2) -- (1.7,1.6);
            % z to b
            \draw [->] (0.3,1) -- (1.7,1.5);
            % v to b
            \draw [->] (0.3,0) -- (1.7,1.4);
            % v to c
            \draw [->] (0.3,0) -- (1.7,0.5);

            % a to d
            \draw [->] (2.3,2.5) -- (3.7,2.1);
            % b to d
            \draw [->] (2.3,1.5) -- (3.7,1.9);
            % b to e
            \draw [->] (2.3,1.5) -- (3.7,1.1);
            % c to e
            \draw [->] (2.3,0.5) -- (3.7,0.9);
            % d to e
            \draw [->] (4,1.7) -- (4,1.3);

            % a to w
            \draw [->] (2.29,2.6) -- (5.7,2.2);
            % e to o
            \draw [->] (4.3,1) -- (5.7,1);
        \end{tikzpicture}
    \end{center}
    \caption{Esempio di network}
\end{figure}
Il numero di nodi può essere messo in relazione con il ritardo (più nodi ci sono più nodi devono
attraversare i segnali, quindi più ritardo).
\begin{itemize}
    \item Area: numero di letterali;
    \item Delay: numero di nodi;
\end{itemize}

\subsection{Algoritmi}
\begin{itemize}
    \item \textbf{simplify}(Quine-McCluskey):trova la minimizzazione massima per ogni nodo del network
    \item \textbf{full\_simplify}: è l'algoritmo più pesante per semplificare il circuito
        e utilizza BDB (Binady Decision Diagram) come struttura dati (struttura a grafo).
\end{itemize}
\subsection{Script}
In sis c'è una lista di \textbf{script} che permettono di minimizzare il circuito, ad
esempio:
\begin{itemize}
    \item \textbf{rugged}: permette di minimizzare il circuito;
    \item \textbf{sweep}: ripulisce il circuito dai nodi inutili
    \item \textbf{eliminate}: elimina un nodo dal circuito condensandolo nei nodi che lo
        circondano
\end{itemize}

\subsubsection{full\_simplify}
Prendiamo come esempio il seguente network:
\begin{figure}[H]
    \begin{center}
        \begin{tikzpicture}
            \node[draw, circle] at (0,2) (A) {A};
            \node[draw, circle] at (0,1) (B) {B};
            \node[draw, circle] at (0,0) (C) {C};

            \node[draw, ellipse] at (3,2) (X) {\( X=\bar{A}+B \) };
            \node[draw, ellipse] at (6,0.5) (Y) {\( Y=ABX+\bar{A}CX \) };
            \node[draw, ellipse] at (9.5,0.5) (O) {\( O \) };

            \draw[->] (A) -- (X);
            \draw[->] (B) -- (X);

            \draw[->] (X) -- (Y);
            \draw[->] (C) -- (Y);
            \draw[->] (A) -- (Y);
            \draw[->] (B) -- (Y);

            \draw[->] (Y) -- (O);
        \end{tikzpicture}
    \end{center}
    \caption{Esempio di network}
\end{figure}
Con un semplice \textbf{simplify} sul nodo \( X \) il circuito resta uguale.
Si può notare dalla mappa di Karnaugh del nodo \( X \) che tutti i mintermini sono coperti e
sono essenziali
\begin{table}[H]
    \begin{center}
        \begin{karnaugh-map}[4][4][1][\( B \)][\( A \)][\( X \)][\( C \)]
                \minterms{12,13,7,15}
                \autoterms[0]
                \implicant{12}{13}
                \implicant{7}{15}
            \end{karnaugh-map}    
    \end{center}
    \caption{Mappa di Karnaugh del nodo \( X \)}
\end{table}

Il \textbf{full\_simplify}, invece calcola i \textbf{controllability don't care set\footnote{Gli \textbf{observability don't care} sono valori di ingresso che non servono per calcolare l'uscita}}, che sarebbero
le configurazioni di ingresso che non si possono presentare. ad esempio: ABX= (0,0,0), 
(0,1,0), (1,0,1), (1,1,0).\\
Se prendiamo in considerazione la tabella di verità del nodo \( X \) si può ottenere il
controllability don't care set: 
\begin{table}[H]
    \begin{center}
        \begin{tabular}{c|c}
            A B & X\\
            \hline
            0 0 & 1\\
            0 1 & 1\\
            1 0 & 0\\
            1 1 & 1
        \end{tabular}
    \end{center}
    \caption{Tabella di verità del nodo \( X \)}
\end{table}
\begin{table}[H]
    \begin{center}
        \begin{tabular}{c}
            A B C X\\
            \hline
            0 0 - 0\\
            0 1 - 0\\
            1 0 - 1\\
            1 1 - 0
        \end{tabular}
    \end{center}
    \caption{Controllability don't care set}
\end{table}
Se si inseriscono questi don't care nella mappa di Karnaugh si osserva che sono disponibili
altri raggruppamenti:
\begin{table}[H]
    \begin{center}
        \begin{karnaugh-map}[4][4][1][\( B \)][\( A \)][\( X \)][\( C \)]
                \minterms{12,13,7,15}
                \indeterminants{0, 1, 3, 6, 14, 8, 9, 11}
                \maxterms{2, 4, 5, 10}
                \implicant{12}{9}
                \implicant{3}{11}
                \implicant{7}{14}
                \implicant{12}{14}
                \implicantedge{0}{1}{8}{9}
            \end{karnaugh-map}    
    \end{center}
    \caption{Mappa di Karnaugh del nodo \( X \) con i don't care}
\end{table}
Il risultato finale sarà:
\[
    Y = \color{red} \bar{A}C \color{black} + \color{green} AB \color{black}
\] 
Usando questi don´t care si può semplificare il circuito e si nota che il nodo X non
è più necessario, quindi si può eliminare (sweep) e il network finale sarà il seguente:
\begin{figure}[H]
    \begin{center}
        \begin{tikzpicture}
            \node[draw, circle] at (0,2) (A) {A};
            \node[draw, circle] at (0,1) (B) {B};
            \node[draw, circle] at (0,0) (C) {C};

            \node[draw, ellipse] at (4,1) (Y) {\( Y=\bar{A}C + AB \) };
            \node[draw, ellipse] at (7.5,1) (O) {\( O \) };

            \draw[->] (C) -- (Y);
            \draw[->] (A) -- (Y);
            \draw[->] (B) -- (Y);

            \draw[->] (Y) -- (O);
        \end{tikzpicture}
    \end{center}
\end{figure}

Per poter realizzare il circuito minimizzato a 2 livelli bisogna fare il technology mapping
che sarebbe l'ultimo passaggio per realizzare il network in qualcosa di reale.
\begin{itemize}
    \item \textbf{FPGA}: \( f(B^5) \to B \) 
    \item \textbf{ASIC}: libreria di porte logiche (composte da più porte elementari e date dal produttore)
\end{itemize}
L'algoritmo più famoso di technology mapping si chiama \textbf{tree mapping} e dopo l'applicazione
di questo algoritmo si avrà una misurazione per area, ritardo e potenza.

\section{Hardware design su FPGA con HDL}
\textbf{HDL} è un linguaggio di modellazione che permette di progettare circuiti su hardware.
\subsection{EDA (Electronic Design Automation)}
La legge di Moore dice che ogni due anni il numero di transistor nei circuiti raddoppia.

Con gli anni aumenta anche l'astrazione, che però comporta anche perdita di dettagli.

Con verilog simuliamo il circuito (test bench) creando così un golden model, che sarà il
modello di riferimento per realizzare il circuito con SIS. Nel caso in cui il modello fatto con sis
si comporta come il bengh test, allora esso è corretto soltanto rispetto a quel bench test.

Si potrebbe scrivere un modello usando un linguaggio di programmazione comune, il problema è che 
i linguaggi di programmazinoe sono sequenziali e quindi eseguono le istruzioni in sequenza.
Nei circuiti ogni porta logica continua a lavorare sui segnali che ha in ingresso, quindi
non è sequenziale e per rappresentare l'hardware serve un linguaggio parallelo (i linguaggi di 
programmazione non sono fatti per questo). Per questo motivo c'è una netta differenza tra il tempo
di simulazione e il tempo simulato (tempo reale). Un HDL che useremo è Verilog in cui tutto concorre
(quindi in parallelo) e non ci sono istruzioni sequenziali.
\subsection{Verilog}
L'elemento principale da rappresentare è il modulo, che ha un nome e un elenco di porte di ingresso
e di uscita. Le porte hanno 16 bit e sono messi in ordine dal 15 allo 0
\begin{lstlisting}[language=Verilog]
module foo(clk, xi, yi, done); // clock, input, output
    input [15:0] xi,yi; // input a 16 bit
    output done;

    // always esegue il blocco di codice quando si verifica un evento sull'argomento
    always @(posedge clk) // serve per descrivere al livello RTL, posedge verifica quando il clock passa da 0 a 1
        begin:
            if (!done) begin
                if (x == y) cd <= x;
                else (x > y) x <= x - y;
            end
        end
endmodule
\end{lstlisting}
Ai dati si può assegnare un valore tra i seguenti:
\begin{itemize}
    \item \textbf{0} bit falso
    \item \textbf{1} bit vero
    \item \textbf{X} dont'care o valore non definito
    \item \textbf{Z} stato di alta impedenza 
\end{itemize}
In verilog ci sono diversi layer di astrazione:
\begin{itemize}
    \item \textbf{Behavioral}: si descrive il circuito come un insieme di istruzioni
    \item \textbf{Data flow}: si descrive il circuito come un insieme di equazioni booleane
    \item \textbf{Gate level}: si istanziano le porte logiche
\end{itemize}
Inoltre si possono assegnare dei valori di partenza (initial statement) che vengono eseguiti
una sola volta all'inizio della simulazione.
\end{document}
