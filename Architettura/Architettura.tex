\documentclass[a4paper]{article}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{textcomp}
\usepackage[italian]{babel}
\usepackage{amsmath, amssymb}
\usepackage{amsfonts}
\usepackage{mdframed}
\usepackage{ntheorem}
\usepackage{xcolor}
\usepackage{graphicx}
\usepackage{tikz}
\graphicspath{{./figures/}}

\usepackage{import}
\usepackage{pdfpages}
\usepackage{transparent}
\usepackage{xcolor}

% Useful definitions frame
\theoremstyle{break}
\theoremheaderfont{\bfseries}
\newmdtheoremenv[%
	linecolor=gray,leftmargin=0,%
	rightmargin=0,
	innertopmargin=8pt,%
	innerbottommargin=8pt,
	ntheorem]{define}{Definizioni utili}[section]

% Example frame
\theoremstyle{break}
\theoremheaderfont{\bfseries}
\newmdtheoremenv[%
	linecolor=gray,leftmargin=0,%
	rightmargin=0,
	innertopmargin=8pt,%
	innerbottommargin=8pt,
	ntheorem]{example}{Esempio}[section]

% Important definition frame
\theoremstyle{break}
\theoremheaderfont{\bfseries}
\newmdtheoremenv[%
	linecolor=gray,leftmargin=0,%
	rightmargin=0,
	backgroundcolor=gray!40,%
	innertopmargin=8pt,%
	innerbottommargin=8pt,
	ntheorem]{definition}{Definizione}[section]

% Exercise frame
\theoremstyle{break}
\theoremheaderfont{\bfseries}
\newmdtheoremenv[%
	linecolor=gray,leftmargin=0,%
	rightmargin=0,
	innertopmargin=8pt,%
	innerbottommargin=8pt,
	ntheorem]{exercise}{Esercizio}[section]

% Theorem frame
\theoremstyle{break}
\theoremheaderfont{\bfseries}
\newmdtheoremenv[%
	linecolor=gray,leftmargin=0,%
	rightmargin=0,
	innertopmargin=8pt,
	innerbottommargin=8pt,
	ntheorem]{theorem}{Teorema}[section]


% figure support
\usepackage{import}
\usepackage{xifthen}
\pdfminorversion=7
\usepackage{pdfpages}
\usepackage{transparent}
\newcommand{\incfig}[1]{%
	\def\svgwidth{\columnwidth}
	\import{./figures/}{#1.pdf_tex}
}

\pdfsuppresswarningpagegroup=1

\begin{document}
\input{title.tex}

\tableofcontents
\pagebreak
\section{Introduzione}
L'informatica è nata per la risoluzione i problemi di calcolo, in particolare
quelli di calcolo numerico. Per questo motivo i primi computer erano macchine
che eseguivano operazioni aritmetiche. Per risolvere questi problemi si usano
degli algoritmi che sono una sequenza di istruzioni semplici che portano poi
a risolvere problemi di complessità variabile. Anche gli algoritmi hanno una
complessità che deve essere adeguata alla risoluzione del problema.

\subsection{Hardware}
Un algoritmo deve essere trasformato in un processo di calcolo automatico,
quindi deve essere implementato tramite hardware. Ci sono due tipi di hardware:
\begin{itemize}
	\item \textbf{Embedded} che è un hardware dedicato ad un singolo compito.
	      Ad esempio il microonde.
	\item \textbf{General purpose} non si sa l'utilizzo finale, quindi ha
	      funzionalità generali ampliate dal software installato. L'hardware
	      general purpose è programmabile attraverso il software. Un esempio
	      è il PC.
\end{itemize}

In base al tipo di hardware l'algoritmo viene implementato in diversi modi:
\begin{itemize}
	\item \textbf{Algoritmo} \( \to  \) \textbf{Software}: Tramite un linguaggio di programmazione
	\item \textbf{Algoritmo} \( \to  \)  \textbf{Hardware embedded}: Tramite linguaggi di basso livello
	      come C, Assembly o il sistema operativo.
	\item \textbf{Algoritmo} \( \to  \)  \textbf{Hardware}: Tramite sintesi logica
\end{itemize}

\subsection{Campionamento dei dati}
Ogni cosa nel mondo è rappresentabile da funzioni continue nel tempo \( f(t) \),
ma con risorse finite è impossibile rappresentare infiniti dati, bisogna quindi
campionarli.
\begin{figure}[h]
	\label{fig:f(t)}
	\centering
	\begin{tikzpicture}[scale=0.6, domain=0:10]
		\coordinate (A) at (0,5);
		\coordinate (B) at (1,5);
		\coordinate (C) at (2,2);
		\coordinate (D) at (3,4);
		\coordinate (E) at (4,1);
		\coordinate (F) at (5,3);
		\coordinate (G) at (6,2);
		\coordinate (H) at (7,4);
		\coordinate (I) at (8,3);
		\coordinate (J) at (9,2);
		\coordinate (K) at (10,5);

		\draw [->] (0,0) -- (10,0) node[right] {$t$};
		\draw [->] (0,0) -- (0,5) node[above] {$f(t)$};

		\draw [gray!50, ultra thin] (0,0) grid (10,5);
		\draw [blue, thick] plot [smooth, tension=1] coordinates { (A) (B) (C) (D) (E) (F) (G) (H) (I) (J) (K) };
		\draw [red, thick ] (A) -- (B) -- (C) -- (D) -- (E) -- (F) -- (G) -- (H) -- (I) -- (J) -- (K);

		\draw [fill] (A) circle [radius=0.1];
		\draw [fill] (B) circle [radius=0.1];
		\draw [fill] (C) circle [radius=0.1];
		\draw [fill] (D) circle [radius=0.1];
		\draw [fill] (E) circle [radius=0.1];
		\draw [fill] (F) circle [radius=0.1];
		\draw [fill] (G) circle [radius=0.1];
		\draw [fill] (H) circle [radius=0.1];
		\draw [fill] (I) circle [radius=0.1];
		\draw [fill] (J) circle [radius=0.1];
		\draw [fill] (K) circle [radius=0.1];

		\draw (0, -0.2) -- (1, -0.2) node[below, xshift=-10] {\( \Delta t \) };
	\end{tikzpicture}
	\caption{Funzione casuale continua nel tempo}
\end{figure}

Per campionare la funzione nella figura \ref{fig:f(t)} bisogna scegliere un intervallo di tempo \( \Delta t \) e prendere
un valore della funzione ogni \( \Delta t \). In questo caso le linee
verticali rappresentano il \textbf{campionamento}, mentre quelle orizzontali
reppresentano la \textbf{discretizzazione o quantizzazione}.
La linea rossa è una spezzata approssimata della funzione continua, infatti
per il teorema di Shannon:

\begin{theorem}
	Deciso il grado di errore da voler compiere, esistono una precisa frequenza di
	campionamento e un intervallo di discretizzazione che garantiscono
	quell'errore.
\end{theorem}

\section{Numeri razionali a virgola mobile}
Gli standard della virgola mobile sono: IEEE 754/85 e IEEE 754/19. Questo standard
è stato rivisto molte volte e ora viene usato da tutte le codifiche per i numeri in
virgola mobile.

Il numero viene separato in due parti: Mantissa (\( M \)) e una base (\(b\))
con un esponente ($e$).
\[
	N = +- M * b^{+-E}
\]
Questo permette di dividere il numero in modo da poter scegliere quanti bit dedicare
alla mantissa e quanti all'esponente.

Ci sono 2 problemi però:
\begin{itemize}
	\item bisogna scegliere la base in cui fare la codifica (base 2)
	\item divisione bit tra M e E (23 M, 8 E, 1 S)
	\item rappresentazione univoca (1.0...)
	\item bisogna trovare un modo per rappresentare gli errori
\end{itemize}

Un numero in base 10 si può rappresentare in più modi>
\(120_{10} = 12*10^{1} = 120 * 10^{0} = 1.20 * 10^{2}\)

Se la mantissa e la base sono in base 2 le operazioni tra numeri sono agevolate.

\(0110 * 2 = 1100\) è uno shift a sinistra in binario.

\(1010/2 = 0101\) è uno shift a destra in binario.

\subsection{Divisione tra bit con mantissa e base diversa}
Un numero è rappresentabile in 2 modi:
\begin{itemize}
	\item 32 bit (singola precisione / float)
	\item 64 bit (doppia precisione / double)
\end{itemize}

Prendiamo in considerazione 32 bit, ora dobbiamo decidere quanti bit dedicare alla
mantissa e alla base

$2^{+-E}$\\
$|E| = 4 bit = 2^{+7}$\\
$5 bit = 2^{+15}$\\
$6 bit = 2^{+31}$\\
$7 bit = 2^{+63}$\\
$8 bit = 2^{+127}$

L'impatto dei bit sull'esponente è doppiamente esponenziale, quindi cresce tantissimo.
Tra tutti i bit a disposizione ne dedichiamo 8 all'esponente, $32 - 8 = 24$ bit rimanenti,
quindi 23 bit vengono assegnati alla mantissa e 1 bit viene assegnato al segno.
\label{fig:disegno1}

Per la rappresentazione univoca la mantissa si codifica in virgola fissa.
Cioè si parte da una mantissa con un punto fisso e dividendo o moltiplicando (shift) si
può spostare la virgola per arrivare alla forma 1.00000... e questa forma è la
rappresentazione univoca. Questa operazioe si chiama normalizzazione e visto che la
rappresentazione è sempre la stessa l'1. non viene rappresentato, quindi
viene inserito nella mantissa solo tutto ciò che viene dopo l'1. .
\label{fig:disegno2}

Se lavorassimo con un esponente in complemento a due ci sarebbe il seguente problema:
$00000000000...0 = 1*2^{0}=1$

Allora si è deciso di codificare l'esponente in Eccesso 127. Quindi per rappresentare
lo zero si usa come esponente il minore numero possibile: $1*2^{127} = 0$
Per codificare i numeri si somma 127 al numero desiderato e visto che i numeri possibili
ora vanno da -127 a +127 se codifichiamo il risultato in modulo avremo dei numeri
da 0 a 256.

\begin{example}
	$1\:01110111\:0110...0$\\
	$M = -(1+1/4+1/8)*2 = -(11/8)*2^{E}$\\
	$E = (1+2+4+16+32+64)-127=119-127=-8$\\
	$N = -11/8 * 2^{-8}$
\end{example}
\begin{exercise}
	Codifica $+(4+\frac{1}{2}+\frac{1}{16})*2^{+34}$
\end{exercise}

\begin{itemize}
	\item $0\:00000000\:0...0 = +0$
	\item $1\:00000000\:0...0 = -0$
\end{itemize}

Quando l'esponente è tutto 1 e la mantissa tutta 0 allora equivale a $infinito$
+ o - in base al primo bit. Se invece la mantissa è diversa da 0 con esponente tutti 1
allora rappresenta un errore NaN.

Somma:\\
\label{es2}

\end{document}
