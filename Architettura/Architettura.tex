\documentclass[a4paper]{article}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{textcomp}
\usepackage[italian]{babel}
\usepackage{amsmath, amssymb}
\usepackage{amsfonts}
\usepackage{mdframed}
\usepackage{float}
\usepackage{xcolor}
\usepackage{listings}
\usepackage{graphicx}
\usepackage{tikz}
\usepackage{circuitikz}
\usepackage[label=corner]{karnaugh-map}
\graphicspath{{./figures/}}

\usepackage{ntheorem}
\newtheorem{theorem}{Teorema}

\usepackage{import}
\usepackage{pdfpages}
\usepackage{transparent}
\usepackage{xcolor}

% Code blocks
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.95}

\lstdefinestyle{mystyle}{
	backgroundcolor=\color{backcolour},
	commentstyle=\color{codegreen},
	keywordstyle=\color{magenta},
	numberstyle=\tiny\color{codegray},
	stringstyle=\color{codepurple},
	basicstyle=\ttfamily\footnotesize,
	breakatwhitespace=false,
	breaklines=true,
	captionpos=b,
	keepspaces=true,
	numbers=left,
	numbersep=5pt,
	showspaces=false,
	showstringspaces=false,
	showtabs=false,
	tabsize=2
}

\lstset{style=mystyle}

% Useful definitions frame
\theoremstyle{break}
\theoremheaderfont{\bfseries}
\newmdtheoremenv[%
	linecolor=gray,leftmargin=0,%
	rightmargin=0,
	innertopmargin=8pt,%
	innerbottommargin=8pt,
	ntheorem]{define}{Definizioni utili}[section]

% Example frame
\theoremstyle{break}
\theoremheaderfont{\bfseries}
\newmdtheoremenv[%
	linecolor=gray,leftmargin=0,%
	rightmargin=0,
	innertopmargin=8pt,%
	innerbottommargin=8pt,
	ntheorem]{example}{Esempio}[section]

% Important definition frame
\theoremstyle{break}
\theoremheaderfont{\bfseries}
\newmdtheoremenv[%
	linecolor=gray,leftmargin=0,%
	rightmargin=0,
	backgroundcolor=gray!40,%
	innertopmargin=8pt,%
	innerbottommargin=8pt,
	ntheorem]{definition}{Definizione}[section]

% Exercise frame
\theoremstyle{break}
\theoremheaderfont{\bfseries}
\newmdtheoremenv[%
	linecolor=gray,leftmargin=0,%
	rightmargin=0,
	innertopmargin=8pt,%
	innerbottommargin=8pt,
	ntheorem]{exercise}{Esercizio}[section]

% figure support
\usepackage{import}
\usepackage{xifthen}
\pdfminorversion=7
\usepackage{pdfpages}
\usepackage{transparent}
\newcommand{\incfig}[1]{%
	\def\svgwidth{\columnwidth}
	\import{./figures/}{#1.pdf_tex}
}

\pdfsuppresswarningpagegroup=1

\begin{document}
\input{title.tex}

\tableofcontents
\pagebreak
\section{Introduzione}
L'informatica è nata per la risoluzione di problemi di calcolo, in particolare
quelli di calcolo numerico. Per questo motivo i primi computer erano macchine
che eseguivano operazioni aritmetiche. Per risolvere questi problemi si usano
degli algoritmi che sono una sequenza di istruzioni semplici che portano poi
a risolvere problemi di complessità variabile. Anche gli algoritmi hanno una
complessità che deve essere adeguata alla risoluzione del problema.

\subsection{Hardware}
Un algoritmo deve essere trasformato in un processo di calcolo automatico,
quindi deve essere implementato tramite hardware. Ci sono due tipi di hardware:
\begin{itemize}
	\item \textbf{Embedded} che è un hardware dedicato ad un singolo compito.
	      Ad esempio il microonde.
	\item \textbf{General purpose} non si sa l'utilizzo finale, quindi ha
	      funzionalità generali ampliate dal software installato. L'hardware
	      general purpose è programmabile attraverso il software. Un esempio
	      è il PC.
\end{itemize}

In base al tipo di hardware l'algoritmo viene implementato in diversi modi:
\begin{itemize}
	\item \textbf{Algoritmo} \( \to  \) \textbf{Software}: Tramite un linguaggio di programmazione
	\item \textbf{Algoritmo} \( \to  \)  \textbf{Hardware embedded}: Tramite linguaggi di basso livello
	      come C, Assembly o il sistema operativo.
	\item \textbf{Algoritmo} \( \to  \)  \textbf{Hardware}: Tramite sintesi logica
\end{itemize}

\subsection{Campionamento dei dati}
Ogni cosa nel mondo è rappresentabile da funzioni continue nel tempo \( f(t) \),
ma con risorse finite è impossibile rappresentare infiniti dati, bisogna quindi
campionarli.

\begin{figure}[h]
	\centering
	\begin{tikzpicture}[scale=0.6, domain=0:10]
		\coordinate (A) at (0,4);
		\coordinate (B) at (1,4);
		\coordinate (C) at (2,2);
		\coordinate (D) at (3,4);
		\coordinate (E) at (4,1);
		\coordinate (F) at (5,3);
		\coordinate (G) at (6,2);
		\coordinate (H) at (7,4);
		\coordinate (I) at (8,3);
		\coordinate (J) at (9,2);
		\coordinate (K) at (10,5);

		\draw [->] (0,0) -- (10,0) node[right] {$t$};
		\draw [->] (0,0) -- (0,5) node[above] {$f(t)$};

		\draw [gray!50, ultra thin] (0,0) grid (10,5);
		\draw [blue, ultra thick] plot [smooth, tension=1] coordinates { (A) (B) (C) (D) (E) (F) (G) (H) (I) (J) (K) };
		\draw [red, thick ] (A) -- (B) -- (C) -- (D) -- (E) -- (F) -- (G) -- (H) -- (I) -- (J) -- (K);

		\draw [fill] (A) circle [radius=0.1];
		\draw [fill] (B) circle [radius=0.1];
		\draw [fill] (C) circle [radius=0.1];
		\draw [fill] (D) circle [radius=0.1];
		\draw [fill] (E) circle [radius=0.1];
		\draw [fill] (F) circle [radius=0.1];
		\draw [fill] (G) circle [radius=0.1];
		\draw [fill] (H) circle [radius=0.1];
		\draw [fill] (I) circle [radius=0.1];
		\draw [fill] (J) circle [radius=0.1];
		\draw [fill] (K) circle [radius=0.1];

		\draw (0, -0.2) -- (1, -0.2) node[below, xshift=-10] {\( \Delta t \) };
	\end{tikzpicture}
    \caption{Funzione casuale continua nel tempo}
    \label{fig:f(t)}
\end{figure}
Per campionare la funzione nella figura \ref{fig:f(t)} bisogna scegliere un intervallo di tempo \( \Delta t \) e prendere
un valore della funzione ogni \( \Delta t \). In questo caso le linee
verticali rappresentano il \textbf{campionamento}, mentre quelle orizzontali
reppresentano la \textbf{discretizzazione o quantizzazione}.
La linea rossa è una spezzata approssimata della funzione continua, infatti
per il teorema di Shannon:

\begin{theorem}
	Deciso il grado di errore da voler compiere, esistono una precisa frequenza di
	campionamento e un intervallo di discretizzazione che garantiscono
	quell'errore.
\end{theorem}
Il sistema di calcolo è ora diventato digitale, cioè elabora i segnali numerici
in ingresso per produrre segnali numerici in uscita.

\begin{figure}[h]
	\centering
	\begin{tikzpicture}
		\node[draw, text=red, align=center] (Realtà fisica) at (0,0) {Realtà\\
			fisica};
		\node[draw, align=center] (Campionamento e discretizzazione) at (2,-1.5) {Campionamento e\\
			discretizzazione};
		\node[draw, text=blue, align=center] (Codifica) at (4,0) {Codifica};
		\node[draw, align=center] (Sistema digitale) at (6,-1.5) {Sistema\\
			digitale};
		\node[draw, text=blue, align=center] (Decodifica) at (8,0) {Decodifica};
		\node[draw, text=red, align=center] (Informazioni) at (9,-1.5) {Informazioni};

		\draw[->,draw] (Realtà fisica) to (Campionamento e discretizzazione);
		\draw[->,draw] (Campionamento e discretizzazione) to (Codifica);
		\draw[->,draw] (Codifica) to (Sistema digitale);
		\draw[->,draw] (Sistema digitale) to (Decodifica);
		\draw[->,draw] (Decodifica) to (Informazioni);
	\end{tikzpicture}
	\caption{Dalla realtà fisica al sistema digitale}
\end{figure}


\section{Sistemi di codifica}
Ogni sistema digitale lavora in base binaria, quindi entrano \( N \)  bit
ed escono \( M \)  bit. I bit in uscita devono essere codificati per
realizzare delle informazioni. Ci sono 2 tipi di informazioni:

\begin{itemize}
	\item \textbf{Informazioni intelleggibili}: sono già chiare agli esseri umani,
	      come un testo scritto.
	\item \textbf{Informazioni non intelleggibili}: hanno bisogno di macchine
	      per essere riprodotte, come le casse per l'audio.
\end{itemize}

\subsection{Codifica di informazioni non numeriche}
Ogni informazione deve avere un codice univoco in modo che il sistema
digitale non possa sbagliare a decodificarla. Date \( M \)  informazioni si
ricavano \( n = log_2{(M)} \)  codici disponibili per rappresentarle.

\begin{example}
	Con \( M=7 \) informazioni:
	\begin{itemize}
		\item \( n=log_2{(7)} \approx 3\; bit \)
		\item \( 2^3=8 \) codici disponibili
	\end{itemize}
\end{example}

\subsection{Numeri interi assoluti}
I numeri interi assoluti rappresentano solo i valori da \( 0 \) a \( 2^n-1 \),
dove \( n \) è il numero di bit disponibile.

La codifica da base decimale a base binaria prende il nome di \textbf{codifica
	a modulo}

\begin{example}
	\label{ex:57modulo}
	Si deve convertire il numero \( 57_{10} \) in base binaria
	\begin{center}
		\[ n=log_2{(57)} = 6\; bit\; (minimi)
 \]
 \[ \sum_{i=1}^{n-1} 2^n-1 = 63\; (codici\; massimi)\]
	\end{center}
	Si eseguono i seguenti passaggi:
	\begin{enumerate}
		\item Si sottraggono le potenze di 2 partendo da \( n-1 \).
		      \begin{itemize}
			      \item Se la potenza \( 2^i \) è minore o uguale del numero,
			            allora si moltiplica per 1.
			      \item Se la potenza \( 2^i \) è maggiore del numero,
			            allora si moltiplica per 0.
		      \end{itemize}
		\item Le sottrazioni continuano fino a quando si giunge a 0.
	\end{enumerate}
	\(57_{10}-{\textcolor{cyan}{1}}*2^{\textcolor{red}{5}}
		=25_{10}-{\textcolor{cyan}{1}}*2^{\textcolor{red}{4}}
		=9_{10}-{\textcolor{cyan}{1}}*2^{\textcolor{red}{3}}
		=1_{10}-{\textcolor{cyan}{0}}*2^{\textcolor{red}{2}}
		=1_{10}-{\textcolor{cyan}{0}}*2^{\textcolor{red}{1}}
		=1_{10}-{\textcolor{cyan}{1}}*2^{\textcolor{red}{0}}\)

    \begin{center}
       \( 57= \textcolor{cyan}{111001} \) 
   \end{center}
\end{example}

\subsection{Numeri interi relativi}
La codifica più ovvia per i numeri interi relativi è la codifica a
\textbf{modulo + segno}. Tuttavia rappresenta varie problematiche, per cui
si preferisce usare la codifica in \textbf{complemento a 2}.

\subsubsection{Codifica a modulo + segno}
\begin{center}
	Intervallo: \( -2^{n-1} \le N \le 2^{n-1}-1 \)
\end{center}
Il segno si rappresenta con un bit, 0 per il positivo e 1 per il negativo.
Il bit più significativo è il bit del segno, mentre i bit meno significativi
rappresentano il modulo.

\begin{center}
	\begin{tikzpicture}
		\draw[draw] (0, 0) rectangle (2,1) node[pos=.5, align=center] {1 bit:\\
				segno \( \pm \) };
		\draw[draw] (2, 0) rectangle (7,1) node[pos=.5, align=center] {7 bit: modulo};
	\end{tikzpicture}
\end{center}
Considerando l'esempio \ref{ex:57modulo} si hanno le seguenti rappresentazioni:

\begin{center}
	\( +57_{10}=\textbf{0}|111001_2 \)\\
	\( -57_{10}=\textbf{1}|111001_2 \)
\end{center}
Sorge però un problema quando si vuole rappresentare il valore \( 0_{10} \),
che in binario risulterebbe:

\begin{center}
	\( +0_{10}=\textbf{0}|000000_2 \)\\
	\( -0_{10}=\textbf{1}|000000_2 \)
\end{center}
Inoltre le somme che passano dal positivo al negativo e viceversa risultano errate.

\subsubsection{Codifica in complemento a 2}
\begin{center}
	Intervallo: \( -2^{n-1} \le N \le 2^{n-1}-1 \)
\end{center}
La codifica in complemento a 2 rimuove tutti i problemi della codifica in modulo
+ segno. Questa codifica infatti rende le somme molto più semplici. La somma facile
infatti è l'obiettivo di questa codifica e parte dell'idea di trovare la
codifica di -1, pertanto si cerca di formulare \( -1+1=0 \).

\begin{center}
	\begin{tabular}{ c|c }
		Obiettivo            & Risultato      \\
		\hline                                \\
		\( ????_2 \) \( + \) & \( 1111_2 + \) \\
		\( 0001_2 = \)       & \( 0001_2 = \) \\ [2ex]
		\hline                                \\
		\( 0000_2 = \)       & \( 0000_2 \)   \\
	\end{tabular}
\end{center}

Se si considera il numero di bit \( n=4 \), allora l'intervallo di valori è
\( -2^3 \le N \le 2^3-1 \):

\begin{center}
	\begin{tabular}{c|c}
		\( 0_{10} = 0000_{2}\) & \( -1_{10} = 1111_{2}\) \\
		\( 1_{10} = 0001_{2}\) & \( -2_{10} = 1110_{2}\) \\
		\( 2_{10} = 0010_{2}\) & \( -3_{10} = 1101_{2}\) \\
		\( 3_{10} = 0011_{2}\) & \( -4_{10} = 1100_{2}\) \\
		\( 4_{10} = 0100_{2}\) & \( -5_{10} = 1011_{2}\) \\
		\( 5_{10} = 0101_{2}\) & \( -6_{10} = 1010_{2}\) \\
		\( 6_{10} = 0110_{2}\) & \( -7_{10} = 1001_{2}\) \\
		\( 7_{10} = 0111_{2}\) & \( -8_{10} = 1000_{2}\) \\
	\end{tabular}
\end{center}
I valori nel complemento a 2 ciclano, quindi se si somma 1 a 7 si ottiene -8.

\begin{example}
	Sottrazione con il complemento a 2: \( 43-17=25 \)
	\[
		n=7 \; bit
	\]
	\begin{enumerate}
		\item Per prima cosa si prende il valore assoluto del numero negativo
		      \( 17_{10} \) e si converte in binario.
		      \begin{center}
			      \( 17_{10}=0010001_{2} \)
		      \end{center}
		\item Si inverte il numero trovato.
		      \begin{center}
			      \( !(0010001_2) = 1101110_2 = -18_{10} \)
		      \end{center}
		\item Si somma 1 al numero trovato.
		      \begin{center}
			      \begin{tabular}{l}
				      \( 1101110\; + \) \\
				      \( 0000001 = \)   \\
				      \hline
				      \( 1101111 \)
			      \end{tabular}\\
			      \( 1101111_2 = -17_{10} \)
		      \end{center}
		\item Si somma il numero trovato al numero positivo.
		      \begin{center}
			      \begin{tabular}{l}
				      \( 0010001\; + \) \\
				      \( 1101111 = \)   \\
				      \hline
				      \( \textbf{1}0011010 \)
			      \end{tabular}
		      \end{center}
		\item Il risultato ottenuto è: \[
			      \textbf{1}0011010
		      \] Si osserva che c'è un bit in più rispetto a quelli disponibili (quello
		      in grassetto),
		      vuol dire che risulta in overflow\footnote{Indica il "traboccamento",
			      cioè se viene superato il limite massimo l'overfflow è un errore,
			      non perchè sia sbagliata la somma, ma perchè il risultato non è codificabile
			      con il numero di bit disponibili}, quindi si scarta il bit più significativo e
		      si ottiene:\[
			      0011010_2 = 26_{10}
		      \] che è il risultato corretto.
	\end{enumerate}
\end{example}

\paragraph{Estensione del numero con il complemento a 2}
\begin{itemize}
	\item Se un numero è \textbf{positivo} va esteso con gli \( \textbf{0} \)
	      \begin{center}
		      \begin{tabular}{l|l}                                        \\
			      \( +57_{10}+ \)  & \( 0111001_2\;+ \)        \\
			      \( +7_{10}\;= \) & \( \textbf{0000}111_2= \) \\ \\
			      \hline                                       \\
			      \( +64_{10} \)   & \( 1000010_2 \)
		      \end{tabular}
	      \end{center}
	\item Se un numero è \textbf{negativo} va esteso con gli \( \textbf{1} \)
	      \begin{center}
		      \begin{tabular}{l|l}                                        \\
			      \( +57_{10}+ \)  & \( 0111001_2\;+ \)        \\
			      \( -7_{10}\;= \) & \( \textbf{1111}111_2= \) \\ \\
			      \hline                                       \\
			      \( +50_{10} \)   & \( 10110010_2 \)
		      \end{tabular}
	      \end{center}
\end{itemize}

\section{Numeri razionali}
I numeri razionali sono composti da una parte intera e una parte frazionaria.
Si possono codificare in 2 modi:
\begin{itemize}
	\item \textbf{Virgola fissa}(fixed point): viene usata maggiormente nei
	      sistemi embedded quando si sa a priori il numero più grande e la
	      precisione che si vuole ottenere
	\item \textbf{Virgola mobile}(floating point): viene usata maggiormente
	      nei sistemi general purpose.
\end{itemize}

\subsection{Codifica in virgola fissa}
\begin{example}
	Si hanno a disposizione 8 bit: 4 per la parte intera e 4 per la parte frazionaria.
	Vogliamo decodificare il numero \( 0110.1011_2 \):
	\Large\[
		\underbrace{\stackrel{2^{3}}{0}\;\stackrel{2^{2}}{1}\;\stackrel{2^{1}}{1}\;\stackrel{2^{0}}{0}}_{+6} .
		\underbrace{\stackrel{2^{-1}}{1}\;\stackrel{2^{-2}}{0}\;\stackrel{2^{-3}}{1}\;\stackrel{2^{-4}}{1}}_{\frac{1}{2}+\frac{1}{8}+\frac{1}{16}}
	\]
	\normalsize\[
		+6 + \frac{1}{2}+\frac{1}{8}+\frac{1}{16}= 6+\frac{11}{16} = \frac{107}{16} = 6.6875
	\]
\end{example}
Se si vuole codificare un numero da decimale a binario bisogna tenere in considerazione
che non è certo che il numero sia razionale anche in base 2, quindi bisogna
approssimare per rappresentarlo.

\begin{example}
	\label{ex:virgolaFissaDecBin}
	Prendiamo in considerazione \( +4 +\frac{3}{5} \), in questo caso bisogna andare
	"a tentoni" e trovare la rappresentazione binaria che approssima con il minor
	errore possibile.
	\[
		4_{10} = 0100_2
	\]
	\[
		0.1001 = \frac{9}{10} \Delta \frac{3}{80}
	\]
	\[
		0.0111 = \frac{7}{16} \Delta -\frac{4}{80}
	\]
	\[
		0.0110 = \frac{3}{8} \Delta \frac{9}{40}
	\]
	\[
		\underline{0.1010 = \frac{5}{8} \Delta -\frac{1}{40}}
	\]
	\( \Delta \) rappresenta l'errore, quindi la rappresentazione più vicina è
	\( 0100.1010_2 \). Però non è stato rappresentato \( \frac{3}{5} \), ma
	\( \frac{1}{2}+\frac{1}{16}=\frac{9}{16} \).
\end{example}
Questo metodo è pesante perchè bisogna controllare più alternative.

\subsubsection{Errore percentuale}
Bisogna decidere se calcolarlo rispetto alla parte intera o a quella frazionaria.
Nel seguente esempio viene calcolato l'errore percentuale rispetto alla parte
frazionaria dell'esempio \ref{ex:virgolaFissaDecBin}.
\begin{example}
	\[
		\frac{1}{40} : \frac{3}{5} = \frac{1}{40} * \frac{5}{3} = \frac{1}{24} \approx 0.052\%
	\]
\end{example}
Il massimo errore che si può fare è l'overflow.

\subsection{Codifica in virgola mobile}
Gli standard della virgola mobile sono: IEEE 754. Questo standard
è stato rivisto molte volte e ora viene usato da tutte le codifiche per i numeri in
virgola mobile.\\
Il numero viene separato in 3 parti:
\begin{itemize}
    \item \textbf{S}: Segno
    \item \textbf{e}: Esponente
	\item \textbf{M}: Mantissa
\end{itemize}
La struttura del numero è quindi:
\[
	N = \pm \cdot M^{\pm e}
\]
Questo permette di dividere il numero in modo da poter scegliere quanti bit dedicare
alla mantissa e quanti all'esponente. Si riscontrano però i seguenti problemi:
\begin{itemize}
	\item Bisogna scegliere la base in cui fare la codifica \(\to\)  base 2
	\item Bisogna scegliere la divisione di bit tra \emph{segno}, \emph{mantissa} e \emph{esponente} \( \to \)   \( 1\; S \), \( 23\; M \), \( 8\; e \)
	\item La rappresentazione deve essere univoca \( \to \)  \( 1.\; \ldots_2 \)
	\item Bisogna trovare un modo per rappresentare gli errori
\end{itemize}
Se la mantissa e la base sono in base 2 la moltiplicazione e la
divisione sono agevolate tramite l'utilizzo dello \emph{shift}.

\begin{itemize}
	\item \(0110 \cdot  2 = 1100\) è uno shift a sinistra in binario.
	      \begin{center}
		      \Large
		      \begin{tikzpicture}
			      \node[align=left] (Prima1) at (0,0) {0};
			      \node[align=left] (Prima2) at (0.2,0) {1};
			      \node[align=left] (Prima3) at (0.4,0) {1};
			      \node[align=left] (Prima4) at (0.6,0) {0};

			      \node[align=left] (Dopo1) at (0,-1) {1};
			      \node[align=left] (Dopo2) at (0.2,-1) {1};
			      \node[align=left] (Dopo3) at (0.4,-1) {0};
			      \node[align=left] (Dopo4) at (0.6,-1) {0};

			      \draw[->, draw] (Prima2) to (Dopo1);
			      \draw[->, draw] (Prima3) to (Dopo2);
			      \draw[->, draw] (Prima4) to (Dopo3);
		      \end{tikzpicture}
	      \end{center}

	\item \(1010/2 = 0101\) è uno shift a destra in binario.
	      \begin{center}
		      \Large
		      \begin{tikzpicture}
			      \node[align=left] (Prima1) at (0,0) {1};
			      \node[align=left] (Prima2) at (0.2,0) {0};
			      \node[align=left] (Prima3) at (0.4,0) {1};
			      \node[align=left] (Prima4) at (0.6,0) {0};

			      \node[align=left] (Dopo1) at (0,-1) {0};
			      \node[align=left] (Dopo2) at (0.2,-1) {1};
			      \node[align=left] (Dopo3) at (0.4,-1) {0};
			      \node[align=left] (Dopo4) at (0.6,-1) {1};

			      \draw[->, draw] (Prima1) to (Dopo2);
			      \draw[->, draw] (Prima2) to (Dopo3);
			      \draw[->, draw] (Prima3) to (Dopo4);
		      \end{tikzpicture}
	      \end{center}

\end{itemize}


\subsubsection{Divisione di bit tra segno, mantissa ed esponente}
Un numero è rappresentabile in 2 modi:
\begin{itemize}
	\item Singola precisione 32 bit \( \to  \) float
	\item Doppia precisione 64 bit \( \to  \) double
\end{itemize}

Prendiamo in considerazione 32 bit, ora dobbiamo decidere quanti bit dedicare
alla mantissa e all'esponente.
\[
	2^{\pm e}
\]
\begin{center}
	$|e| = 4 bit = 2^{+7}$\\
	$5 bit = 2^{+15}$\\
	$6 bit = 2^{+31}$\\
	$7 bit = 2^{+63}$\\
	$8 bit = 2^{+127}$
\end{center}
L'impatto dei bit sull'esponente è doppiamente esponenziale, quindi cresce tantissimo.

\begin{itemize}
	\item \textbf{8 bit} all'esponente, quindi l'esponente
	      può assumere valori da \( -127 \) a \( +127 \).
	\item \textbf{23 bit} alla mantissa, quindi la mantissa
	      può assumere valori da \( 0 \) a \( 2^{23}-1 \)
	\item \textbf{1 bit} al segno.
\end{itemize}

\begin{center}
	\begin{tikzpicture}
		\draw[draw] (0, 0) rectangle (1.6,1) node[pos=.5, align=center] {1 bit:\\
				segno \( \pm \) };
		\draw[draw] (1.6, 0) rectangle (5,1) node[pos=.5, align=center] {8 bit: esponente};
		\draw[draw] (5, 0) rectangle (10,1) node[pos=.5, align=center] {23 bit: mantissa};
	\end{tikzpicture}
\end{center}
Per la rappresentazione univoca la mantissa si codifica in virgola fissa.
Cioè si parte da una mantissa con un \textbf{punto fisso} e dividendo o moltiplicando (shift) si
può spostare la virgola per arrivare alla forma \textbf{1.00000...} e questa forma è la
rappresentazione univoca.

Questa operazioe si chiama \textbf{normalizzazione} e visto che la
rappresentazione è sempre la stessa l'\emph{1.} non viene rappresentato, quindi
viene inserito nella mantissa solo tutto ciò che viene dopo.
\begin{figure}[H]
	\begin{center}
		\( 11111111 \) \( \pm \infty \)\\
		\( 11111110 \) \( +127 \) \\
		\( \ldots \)\\
		\( 00000000 \) \( \pm 0 \)\\
		\( \ldots \)\\
		\( 00000001 \) \( -126 \) \\
		\( 00000000 \) \( -127 \)
	\end{center}
	\caption{Range dell'esponente}
\end{figure}
Si è deciso di codificare l'esponente in \textbf{Eccesso 127}. Quindi per
rappresentare lo zero si usa come esponente il minore numero possibile:
$1 \cdot 2^{-127} = 0$. Per codificare i numeri si somma 127 al numero desiderato
e visto che i numeri possibili ora vanno da -127 a +127 se codifichiamo
il risultato in modulo avremo dei numeri da 0 a 256.

\begin{figure}[H]
	\begin{example}
		Si vuole decodificare il seguente numero:
		\[1\:01110111\:0110...0\]
		\[M = -(1+\frac{1}{4}+\frac{1}{8})*2^e = -(\frac{11}{8})*2^{e}\]
		\[e = (1+2+4+16+32+64)-127=119-127=-8\]
		\[N = -\frac{11}{8} * 2^{-8}\]
	\end{example}
\end{figure}

\begin{figure}[H]
	\begin{example}
		Codifica $+(4+\frac{1}{2}+\frac{1}{16})*2^{+34}$
		\begin{enumerate}
			\item Sappiamo già che il numero è positivo quindi:
			      \[
				      S=0
			      \]
			\item Calcoliamo la mantissa:
			      \[
				      4+\frac{1}{2}+\frac{1}{16}= \underbrace{100}_{4_{10}}.
				      \underbrace{10010 \ldots 0}_{\frac{1}{2}+\frac{1}{16}}
			      \]
			\item La mantissa va normalizzata moltiplicando per 4:
			      \[
				      100.10010 \ldots 0 * 2^{+2} = 1.0010010 \ldots 0
			      \]
			      \[
				      M = 0010010 \ldots 0
			      \]
			\item Calcoliamo l'esponente:
                \[
                e = 34 + 2 = 36
                \] Si aggiunge 2 perchè abbiamo fatto lo shift di 2 bit.
                \[
                e = 36 + 127 = 163
                \] 
                \[
                    163_{10} = 10100011_2
                \] 
                \item Il numero in virgola mobile è:
                \[
                    0\:10100011\:0010010 \ldots 0
                \]
		\end{enumerate}
	\end{example}
\end{figure}

\begin{itemize}
	\item $0\:00000000\:0...0 = +0$
	\item $1\:00000000\:0...0 = -0$
\end{itemize}

Quando l'esponente è tutto 1 e la mantissa tutta 0 allora equivale a \( \pm \infty \)
in base al primo bit. Se invece la mantissa è diversa da 0 con esponente tutti 1
allora rappresenta un errore NaN.

Somma:\\
\label{es2}


%Lezione 4
\section{Modelli}
Per un progetto bisogna creare un \textbf{modello} che rappresenti il sistema.
Boole ha cercato di rappresentare tutte le algebre. Lo ha fatto attraverso
una quintupla: \( <B^{n}, \cdot, + ,\{0,1\}> \)
\begin{figure}[H]
	\centering
	\begin{tikzpicture}
		\node[draw, align=center] (Sistema digitale) at (0,0) {Sistema\\
			digitale};

		\draw[->, draw] (Sistema digitale) to (2,0);
		\draw[<-, draw] (Sistema digitale) to (-2,0);

		\node (A) at (-2,0.3) {A};
		\node (B) at (-2,-0.3) {B};
		\node (O) at (2,0.3) {O};
	\end{tikzpicture}
\end{figure}

\begin{itemize}
	\item \( B^n \) è l'insieme di valori
	\item \( \{0,1\} \) è l'alfabeto (sistema binario)
	\item "\( \cdot  \)" e "\( + \)" sono 2 operatori
\end{itemize}
Bool garantisce che si può creare qualsiasi funzione utilizzando soltanto i
2 operatori:
\[
	f(B^n) \to B^m
\]
\begin{example}
	Si vuole creare un modello con 2 bit in entrata e 1 in uscita:
	\[
		n=2 \; m=1
	\]
	\( O=1 \leftrightarrow A=B \)\\
	\( f(B^2) \to B \)
	\begin{center}
		\begin{tikzpicture}
			\draw[thick] (0,0) circle [x radius=0.5cm, y radius=1.5cm]
			(2,0) circle [x radius=0.5cm, y radius=1.5cm];

			\node[align=center] (00) at (0,0.8) {00};
			\node[align=center] (11) at (0,0.3) {11};
			\node[align=center] (01) at (0,-0.2) {01};
			\node[align=center] (10) at (0,-0.7) {10};

			\node[align=center] (1) at (2,0.6) {1};
			\node[align=center] (0) at (2,-0.5) {0};

			\draw[->, draw] (00) to (1);
			\draw[->, draw] (11) to (1);
			\draw[->, draw] (01) to (0);
			\draw[->, draw] (10) to (0);
		\end{tikzpicture}
	\end{center}
	Per mappare i valori in ingresso con quelli di uscita si usa una
	\textbf{tabella di verità}:
	\begin{center}
		\begin{tabular}{c|c|c}
			\( A \) & \( B \) & \( O \) \\
			\hline
			0       & 0       & 1       \\
			0       & 1       & 0       \\
			1       & 0       & 0       \\
			1       & 1       & 1       \\
		\end{tabular}
	\end{center}
	Chiamiamo mintermine un punto dello spazio booleano in ingresso in cui la
	funzione vale 1. Il maxtermine è il contrario.
	L'insieme di mintermini \( \{m_0\footnote{\( m_n \): n è il valore in modulo
		del relativo numero binario, \( m \) sta per modulo. \( m_3 = 11_2 \) }, m_3\} \) si chiama \textbf{ON-SET}
	L'insieme dei maxtermini \( \{m_1, m_2\} \) si chiama \textbf{OFF-SET}. Basta
	uno dei due insiemi (ON-SET, OFF-SET) per definire la funzione.
	\[
		m_3 = A \cdot B
	\]
	Dire che \( m_3 \) è il prodotto delle due variabili è un modo corretto per
	rappresentarlo.
	\[
		m_0 = \bar{A} \cdot \bar{B}
	\]
	Per rappresentare il mintermine basta fare il prodotto delle variabili se
	valgono 1 o delle variabili negate se valgono 0.

	Per rappresentare la funzione si può usare la somma dei mintermini:
	\[
		O = m_0 + m_3 = \bar{A} \cdot \bar{B} + A \cdot B = 0
	\]
	Questa rappresentazione viene detta: \emph{Espressione in somma di prodotti}
	\begin{theorem}
		Dato un ON-SET c'è sempre una sola espressione in somma di prodotti che lo
		rappresenti.
	\end{theorem}
	\label{ex:modelloAB}
\end{example}

\subsection{Tabelle di verità}
\subsubsection{Operatore prodotto}
\begin{center}
	\begin{tabular}{c|c|c}
		\( A \) & \( B \) & \( O \) \\
		\hline
		0       & 0       & 0       \\
		0       & 1       & 0       \\
		1       & 0       & 0       \\
		1       & 1       & 1       \\
	\end{tabular}
\end{center}

\subsubsection{Operatore somma}
\begin{center}
	\begin{tabular}{c|c|c}
		\( A \) & \( B \) & \( O \) \\
		\hline
		0       & 0       & 0       \\
		0       & 1       & 1       \\
		1       & 0       & 1       \\
		1       & 1       & 1       \\
	\end{tabular}
\end{center}

\subsubsection{Operatore negazione}
\begin{center}
	\begin{tabular}{c|c}
		\( A \) & \( O \) \\
		\hline
		0       & 1       \\
		1       & 0       \\
	\end{tabular}
\end{center}

\section{Transistor}
È un "comando di accensione" che permette di accendere o spegnere un circuito.
\subsection{Transistor CMOS}
\subsubsection{Transistor N}
Mette in collegamento 2 punti:
\begin{itemize}
	\item Se la corrente è 0V allora non c'è collegamento
	\item Se la corrente è 3V allora c'è collegamento
\end{itemize}

\begin{figure}[H]
	\begin{center}
		\begin{circuitikz}[american,]
			\node (Vcc) at (0,0.3) {\( V_{cc} \) };
			\draw (0,0) -- (1,0) to[short,-*] ++(0,0) node[left] {}
			(2,0) -- (1,0)
			node[nmos,anchor=D] (nmos) {}
			(nmos.G) to[short] ++(0,0) node[left] {}
			(nmos.S) node[ground] {};
		\end{circuitikz}
	\end{center}
	\caption{Transistor N}
\end{figure}

\subsubsection{Transistor P}
Mette in collegamento 2 punti:
\begin{itemize}
	\item Se la corrente è 0V allora c'è collegamento
	\item Se la corrente è 3V allora non c'è collegamento
\end{itemize}

\begin{figure}[H]
	\begin{center}
		\begin{circuitikz}[american,]
			\node (Vcc) at (0,0.3) {\( V_{cc} \) };
			\draw (0,0) -- (1,0) to[short,-*] ++(0,0) node[left] {}
			(2,0) -- (1,0)
			node[pmos,anchor=S] (pmos) {}
			(pmos.G) to[short] ++(0,0) node[left] {}
			(pmos.D) node[ground] {};

		\end{circuitikz}
	\end{center}
	\caption{Transistor P}
\end{figure}
\subsubsection{Circuito di negazione (NOT)}
Si realizza con un transistor P e uno N in serie.
\begin{figure}[H]
	\begin{center}
		\begin{circuitikz}
			\node (Vcc) at (-1,0.3) {\( V_{cc} \) };
			\node (Vcc) at (1,0.3) {\( 3V \) };
			\draw (-1,0) -- (0,0) to[short,-*] ++(0,0) node[left] {}
			(1,0) -- (0,0);
			\draw (0,0) node[pmos, anchor=S] (pmos) {}
			(pmos.G) to[short] ++(0,0) node[left] {}
			(pmos.D) to[short] ++(0,0) node[left] {}
			(pmos.D) -- ++(0,0) to[short,-*] (0,-1.6) node[left] {}
			node[nmos,anchor=D] (nmos) {}
			(nmos.G) to[short] ++(0,0) node[left] {}
			(nmos.S) node[ground] {};
			\draw (-2, -1.6) node[above] {\( x \) } to[short,-*] (-0.99,-1.6) node[left] {}
			(pmos.G) -- ++(0,0) to[short,-*] (-0.99,-1.6) node[left] {}
			(0,-1.6) -- ++(0,0) to[short] (1.2,-1.6) node[above] {O}
			(nmos.G) -- ++(0,0) to[short] (-0.99,-1.6) node[left] {};
			\node (0V) at (0.6,-3.5) {\( 0V \) };
		\end{circuitikz}
	\end{center}
\end{figure}
La tabella della verità è:
\begin{center}
	\begin{tabular}{c|c}
		\( x \) & \( O \) \\
		\hline
		0V      & 3V      \\
		3V      & 0V      \\
	\end{tabular}
\end{center}
Se assegnamo ad ogni valore un numero binario:
\begin{center}
	\begin{tabular}{c|c}
		\( x \) & \( O \) \\
		\hline
		0       & 1       \\
		1       & 0       \\
	\end{tabular}
\end{center}
Si può notare che è la funzione di negazione rappresentata con la seguente
porta logica:
\begin{figure}[H]
	\begin{center}
		\begin{circuitikz}
			\draw (0,0) node[scale=0.7, not port] (not) {};
			\draw (not.in) node[left] {x};
			\draw (not.out) node[right] {O};
		\end{circuitikz}
	\end{center}
\end{figure}

\subsubsection{Circuito del prodotto (AND)}
\begin{center}
	\begin{circuitikz}
		\node (x) at (-2,-0.23) {x};
		\node (y) at (-2,-2.77) {y};
		\node (O) at (1.2,-1.3) {O};

		\node (Vcc) at (-1.5,1.8) {\( V_{cc}=3V \) };

		\filldraw[black] (1,0) circle (1.5pt) node[anchor=west]{};
		\filldraw[black] (-0.28,-0.23) circle (1.5pt) node[anchor=west]{};
		\filldraw[black] (-0.98,-2.77) circle (1.5pt) node[anchor=west]{};
		\filldraw[black] (2,1.55) circle (1.5pt) node[anchor=west]{};
		\filldraw[black] (0,1.55) circle (1.5pt) node[anchor=west]{};

		\draw
		(0,0) node[pmos, anchor=D] (pmos1) {} (0,0) -- (2,0)
		(2,0) node[pmos, anchor=D] (pmos2) {} (2,0)
		(1,0) node[nmos, anchor=D] (nmos1) {} (1,-1)
		(1,-1.54) -- (1,-2) node[nmos, anchor=D] (nmos2) {} (1,-2)
		(nmos2.S) node[ground] {}
		(pmos1.G) to ++(0,-3.542)
		(pmos2.G) to ++(-1.3,0) -- ++(0, -1) to[short] (x)
		(nmos1.G) to ++(-0.3,0) -- ++(0,1)
		(nmos2.G) to[short] (y)
		(-2,1.55) -- ++(5,0)
		(nmos1.S) -- ++(2,0) -- ++(0,1.497)
		;

		\begin{scope}[shift={(5,1.55)}]
			\draw (-2,0) -- (0,0) to[short,-*] ++(0,0) node[left] {}
			(1,0) -- (0,0);
			\draw (0,0) node[pmos, anchor=S] (pmos) {}
			(pmos.G) to[short] ++(0,0) node[left] {}
			(pmos.D) to[short] ++(0,0) node[left] {}
			(pmos.D) -- ++(0,0) to[short,-*] (0,-1.6) node[left] {}
			node[nmos,anchor=D] (nmos) {}
			(nmos.G) to[short] ++(0,0) node[left] {}
			(nmos.S) node[ground] {};
			\draw (-2, -1.6) node[above] {} to[short,-*] (-0.99,-1.6) node[left] {}
			(pmos.G) -- ++(0,0) to[short,-*] (-0.99,-1.6) node[left] {}
			(0,-1.6) -- ++(0,0) to[short] (1.2,-1.6) node[above] {O}
			(nmos.G) -- ++(0,0) to[short] (-0.99,-1.6) node[left] {};
			\node (0V) at (0.6,-3.5) {\( 0V \) };
		\end{scope}
		\draw (-2.5,-4.2) -- ++(0,-0.3) -- ++(5,0) node[below, xshift=-2.5cm] {Prodotto negato} -- ++(0,0.3);
		\draw (2.6,-4.2) -- ++(0,-0.3) -- ++(3.7,0) node[below, xshift=-1.85cm] {Porta logica NOT} -- ++(0,0.3);
	\end{circuitikz}
\end{center}
Il prodotto negato più il NOT è uguale ad un AND:
\begin{center}
	\begin{circuitikz}
		\draw (0,0) node[scale=0.7, and port] (and) {};
		\draw (and.in 1) node[left] {x};
		\draw (and.in 2) node[left] {y};
		\draw (and.out) node[right] {O};
	\end{circuitikz}
\end{center}
La tabella della verità è:
\begin{center}
	\begin{tabular}{c|c|c}
		\( x \) & \( y \) & \( O \) \\
		\hline
		0       & 0       & 0       \\
		0       & 1       & 0       \\
		1       & 0       & 0       \\
		1       & 1       & 1       \\
	\end{tabular}
\end{center}

\subsubsection{Circuito della somma (OR)}
\begin{center}
	\begin{circuitikz}
		\draw (0,0) node[scale=0.7, or port] (and) {};
		\draw (and.in 1) node[left] {x};
		\draw (and.in 2) node[left] {y};
		\draw (and.out) node[right] {O};
	\end{circuitikz}
\end{center}
La tabella della verità è:
\begin{center}
	\begin{tabular}{c|c|c}
		\( x \) & \( y \) & \( O \) \\
		\hline
		0       & 0       & 0       \\
		0       & 1       & 1       \\
		1       & 0       & 1       \\
		1       & 1       & 1       \\
	\end{tabular}
\end{center}

\section{Espressione in somma di prodotti}
Il seguente circuito è un esempio di espressione in somma di prodotti dell'esempio \ref{ex:modelloAB}:
\begin{center}
	\begin{circuitikz}
		\draw (0,0) node[label=left:\( A \) ] (A) {}
		to[short, o-]
		(2,0)
		node[not port, anchor=in, scale=0.5,label=above:\( \bar{A} \) ] (not1) {}
		(0,-1)
		node[label=left:\( B \) ] (B) {}
		to[short, o-]
		(2,-1)
		node[not port, anchor=in, scale=0.5,label=below:\( \bar{B} \) ] (not2) {}
		(4,-0.5) node[and port, label={above, yshift=3mm}:{\( m_{0} = \bar{A} \cdot \bar{B} \)}, scale=0.5,] (and1) {}
		(not1.out) to[short] ++(0.25,0) |- (and1.in 1)
		(not2.out) to[short] ++(0.25,0) |- (and1.in 2)
		(2,-2.5) node[and port, anchor=in 1, label={below, yshift=-3mm}:{\( m_{3} = A \cdot B \)}, scale=0.5,] (and2) {}
		(and2.in 1) to[short] ++(-0.5,0)
		to[short, -*] (1.5,0)
		(and2.in 2) to[short] ++(-1,0)
		to[short, -*] (1,52 |- not2.in)
		(and1.out) to[short] ++(1.7,0)
		node[or port, anchor=in 1, label={above, yshift=3mm}:{\( O = m_{0} + m_{3} \)}, scale=0.5,] (or1) {}
		(or1.in 2) to[short] ++(-0.5,0) |- (and2.out)
		(or1.out) to[short, -o] ++(0.5,0) node[label=right:\( O \)] {}
		;
	\end{circuitikz}
\end{center}
I circuiti devono spesso tenere conto di alcune specifiche da ottimizzare:
\begin{itemize}
	\item \textbf{Area}: minor numero di porte logiche
	\item \textbf{Latency}: più porte logiche si attraversano più sarà il ritardo
	\item \textbf{Power}: più porte logiche si attraversano più sarà
	      il consumo
	\item \textbf{Safety}: più porte logiche si attraversano più sarà
	      la probabilità di errore
\end{itemize}
Prendiamo in considerazione la funzione \( f(B^3)\footnote{Il numero di funzioni booleane
	possibili è \( 2^{2^3} = 256 \) e il valore cresce esponenzialmente con
	l'aumento dei bit}\to B \):
\begin{center}
	\begin{tabular}{c|c}
		X Y Z   & O \\
		\hline
		0\;0\;0 & 0 \\
		0\;0\;1 & 1 \\
		0\;1\;0 & 0 \\
		0\;1\;1 & 1 \\
		1\;0\;0 & 0 \\
		1\;0\;1 & 1 \\
		1\;1\;0 & 0 \\
		1\;1\;1 & 1 \\
	\end{tabular}
\end{center}
ON-SET\(=\{ m_1,m_3,m_5,m_7 \} \)\\
La funzione rappresentata con un'espressione in somma di prodotti è:
\[ O=m_1+m_3+m_5+m_7 = \bar{X}\bar{Y}Z + \bar{X}YZ + X\bar{Y}Z + XYZ \]
Proviamo a stimare le dimensioni di questo circuito. Si utilizza il concetto
di \textbf{letterale} che è una coppia chiave-valore. La funzione \( O \)
è composta da 12 letterali e questo numero è in relazione con il numero di
transistor nel senso che se una funzione ha più letterali di un altra si può
già sapere che avrà bisogno di un minor numero di transistor.


\subsection{Tecniche di ottimizzazione}
La regola principale dell'ottimizzazione è l'\textbf{assorbimento}:
Preso un prodottp \( P \)  moltiplicato ad un letterale \( a \) e la somma di
questo prodotto, ma con il letterale negato \( \bar{a} \) allora il risultato
è \( P \cdot  (a+\bar{a}) \) dove \( (a+\bar{a}) \) fa sempre 1, quindi rimane
\( P \).
\[
	aP+\bar{a}P=P \cdot (a+\bar{a}) = P
\]

\[
    \underbrace{2 \cdot (|P|+1)}_{\text{Cardinalità prima dell'assorbimento}} \Rightarrow \underbrace{|P|}_{\text{Cardinalità dopo l'assorbimento}}
\]
Quindi se prendiamo come riferimento la funzione \( O \) si può applicare la
regola dell'assorbimento per ridurre il numero di letterali:
\begin{center}
	\begin{tikzpicture}
		\node (1) at (0,0) {\( \bar{X}\bar{Y}Z+\bar{X}YZ+X\bar{Y}Z+XYZ \)};
		\node (2) at (0,-1) {\( \bar{X}Z(\bar{Y}+Y)+XZ(\bar{Y}+Y) \)};

		\draw[->, draw] (-1.9, -0.2) to (-1.3, -0.7);
		\draw[->, draw] (-0.7, -0.2) to (-0.55,-0.7);
		\draw[->, draw] (0.65, -0.2) to (1, -0.7);
		\draw[->, draw] (1.9, -0.2) to (1.8, -0.7);

	\end{tikzpicture}
\end{center}
E riapplicando la regola si arriva al minimo:
\begin{center}
	\begin{tikzpicture}
		\node (3) at (0,-2) {\( \bar{X}Z+XZ \)};
		\node (4) at (0,-3) {\( Z(\bar{X}+X) \)};

		\draw[->, draw] (-0.7, -2.2) to (-0.3,-2.7);
		\draw[->, draw] (0.4, -2.2) to (0.5, -2.7);
	\end{tikzpicture}
\end{center}
\[
	Z
\]
\subsection{Terminologia}
Ogni mintermine è un prodotto (o implicante), ma dopo aver applicato la regola
di assorbimento non è più un mintermine, ma soltanto prodotto (o implicante).
\[
	\bar{X}\bar{Y}Z \to \bar{X}Z
\]
La \( Y \) non c'è più nel risultato dell'assorbimento, ciò vuol dire che non
ci interessa il suo valore perchè non varia il risultato. Si può scrivere sia
\(
11
\)
che
\(
1-1
\)\\
Quindi ad esempio:\\
\( Z=--1=4\; \)mintermini: \( \{ 001, 011, 101, 111 \} \)
\begin{definition}
	\textbf{Implicante primo} è un implicante non contenuto in nessun altro
	implicante
\end{definition}

\begin{figure}[H]
    \begin{definition}
        La \textbf{distanza di Hamming} è il numero di bit che differenziano 2 codici.
        \begin{center}
            \( 01 \textbf{10} \to 01 \textbf{01}\; \) distanza di Hamming = 2\\
            \( 01 \textbf{0} \to 01 \textbf{1}\; \) distanza di Hamming = 1
        \end{center}
    \end{definition}
\end{figure}
\section{Assorbimento svolto graficamente}
Prendendo come riferimento la funzione \( f(B^3)^1 \to B \)  definita precedentemente (che chiameremo \( O \)) 
si può guardare la funzione come se fosse sul piano cartesiano con centro in
un punto qualsiasi. Ogni punto adiacente al centro è un punto con distanza di
Hamming = 1.
\begin{center}
	\begin{tikzpicture}[x=0.5cm,y=0.5cm,z=0.3cm,>=stealth]
		\draw[->] (xyz cs:x=0) -- (xyz cs:x=6) node[above] {$x$};
		\draw[->] (xyz cs:y=0) -- (xyz cs:y=6) node[right] {$z$};
		\draw[->] (xyz cs:z=0) -- (xyz cs:z=6) node[above] {$y$};

		\node[below] (000) at (0,0,0) {\( 000 \)};
		\node[right] (001) at (0,0,6) {\( 001 \)};
		\node[left] (010) at (0,6,0) {\( 010 \)};
		\node[below] (011) at (6,0,0) {\( 011 \)};
	\end{tikzpicture}
\end{center}
L'assorbimento può essere fatto soltanto tra gli ON-SET con distanza di
Hamming = 1.
Per effettuare l'assorbimento ci si posiziona nel punto di un mintermine e si
"guarda" in tutte le direzioni per eventuali altri mintermini con cui fare il
prodotto.

Nella seguente figura i vertici rossi rappresentano gli OFF-SET e i vertici
blu rappresentano gli ON-SET.
\begin{figure}[H]
	\begin{center}
		\begin{tikzpicture}
        \newcommand{\Depth}{3}
        \newcommand{\Height}{3}
        \newcommand{\Width}{3}

        \coordinate (O) at (0,0,0);
        \coordinate (A) at (0,\Width,0);
        \coordinate (B) at (0,\Width,\Height);
        \coordinate (C) at (0,0,\Height);
        \coordinate (D) at (\Depth,0,0);
        \coordinate (E) at (\Depth,\Width,0);
        \coordinate (F) at (\Depth,\Width,\Height);
        \coordinate (G) at (\Depth,0,\Height);

        \draw[] (O) -- (C) -- (G) -- (D) -- cycle;% Bottom Face
        \draw[] (O) -- (A) -- (E) -- (D) -- cycle;% Back Face
        \draw[] (O) -- (A) -- (B) -- (C) -- cycle;% Left Face
        \draw[opacity=0.8] (D) -- (E) -- (F) -- (G) -- cycle;% Right Face
        \draw[opacity=0.6] (C) -- (B) -- (F) -- (G) -- cycle;% Front Face
        \draw[opacity=0.8] (A) -- (B) -- (F) -- (E) -- cycle;% Top Face

        \draw[fill, red] (C) circle (2pt) node[below] {\( 000 \)};
        \draw[fill, red] (B) circle (2pt) node[left] {\( 010 \)};
        \draw[fill, red] (F) circle (2pt) node[right] {\( 110 \)};
        \draw[fill, red] (G) circle (2pt) node[below] {\( 100 \)};
        \draw[fill, blue] (O) circle (2pt) node[left] {\( 001 \)};
        \draw[fill, blue] (A) circle (2pt) node[above] {\( 011 \)};
        \draw[fill, blue] (E) circle (2pt) node[above] {\( 111 \)};
        \draw[fill, blue] (D) circle (2pt) node[right] {\( 101 \)};

        \draw[fill, red] (4, 3) rectangle ++(0.3, 0.3) node[below right, yshift=1mm] {OFF-SET}; 
        \draw[fill, blue] (4, 2.5) rectangle ++(0.3, 0.3) node[below right, yshift=1mm] {ON-SET}; 
    \end{tikzpicture}
	\end{center}
\end{figure}
Si trascura la faccia del cubo con l'OFF-SET per rendere la rappresentazione più semplice.
Prendendo coppie di vertici dell'ON-SET sullo stesso lato del cubo si può fare il prodotto tra i 2 mintermini:
\begin{center}
    \begin{tikzpicture}
        \newcommand{\Depth}{3}
        \newcommand{\Height}{3}
        \newcommand{\Width}{3}

        \coordinate (O) at (0,0,0);
        \coordinate (A) at (0,\Width,0);
        \coordinate (B) at (0,\Width,\Height);
        \coordinate (C) at (0,0,\Height);
        \coordinate (D) at (\Depth,0,0);
        \coordinate (E) at (\Depth,\Width,0);
        \coordinate (F) at (\Depth,\Width,\Height);
        \coordinate (G) at (\Depth,0,\Height);

        \draw[] (O) -- (A) -- (E) -- (D) -- cycle;% Back Face

        \draw[fill, blue] (O) circle (2pt) node[below] {\( 001 \)};
        \draw[fill, blue] (A) circle (2pt) node[above] {\( 011 \)};
        \draw[fill, blue] (E) circle (2pt) node[above] {\( 111 \)};
        \draw[fill, blue] (D) circle (2pt) node[below] {\( 101 \)};

        \node[below, blue] (1) at (1.5,0,0) {\( \bar{Y}Z \)};
        \node[above, blue] (2) at (1.5,3,0) {\( YZ \)};
        \node[left, blue] (3) at (0,1.5,0) {\( \bar{X}Z \)};
        \node[right, blue] (4) at (3,1.5,0) {\( XZ \)};
    \end{tikzpicture}
\end{center}
Ora si può fare l'assorbimento anche tra i prodotti ottenuti dall'assorbimento:
\begin{center}
    \begin{tikzpicture}
        \newcommand{\Depth}{3}
        \newcommand{\Height}{3}
        \newcommand{\Width}{3}

        \coordinate (O) at (0,0,0);
        \coordinate (A) at (0,\Width,0);
        \coordinate (B) at (0,\Width,\Height);
        \coordinate (C) at (0,0,\Height);
        \coordinate (D) at (\Depth,0,0);
        \coordinate (E) at (\Depth,\Width,0);
        \coordinate (F) at (\Depth,\Width,\Height);
        \coordinate (G) at (\Depth,0,\Height);

        \draw[] (O) -- (A) -- (E) -- (D) -- cycle;% Back Face

        \draw[fill, blue] (O) circle (2pt) node[below] {\( 001 \)};
        \draw[fill, blue] (A) circle (2pt) node[above] {\( 011 \)};
        \draw[fill, blue] (E) circle (2pt) node[above] {\( 111 \)};
        \draw[fill, blue] (D) circle (2pt) node[below] {\( 101 \)};

        \node[below, blue] (1) at (1.5,0,0) {\( \bar{Y}Z \)};
        \node[above, blue] (2) at (1.5,3,0) {\( YZ \)};
        \node[left, blue] (3) at (0,1.5,0) {\( \bar{X}Z \)};
        \node[right, blue] (4) at (3,1.5,0) {\( XZ \)};

        \node[blue] (5) at (1.5,1.5,0) {\textbf{Z}};
    \end{tikzpicture}
\end{center}
Si arriva quindi a dire che \( Z \) è un \textbf{implicante primo} perchè non c'è nessun
altro implicante che lo contiene.
\begin{figure}[H]
	\begin{define}
		Quando si parla di implicante si può anche dire \textbf{sottocubo} e
		l'implicante primo può essere chiamato anche \textbf{sottocubo di dimensione
			massima}.
		\begin{center}
			Implicante = Sottocubo\\
			Implicante primo = Sottocubo di dimensione massima
		\end{center}
	\end{define}
\end{figure}
Esistono condizioni favorevoli (come la funzione \( O \) ) in cui un implicante primo
contiene tutti i mintermini della funzione.\\
Ci sono più tipi di implicanti primi:
\begin{itemize}
	\item \textbf{Essenziali}: includono almeno un mintermine che non è coperto da nessun
	      altro implicante primo (fanno parte della soluzione finale).
	\item \textbf{Non essenziali}:  Implicanti primi che coprono mintermini
	      coperti anche da altri implicanti.
	      Si identificano con l'\textbf{algoritmo di copertura}
\end{itemize}
\subsection{Mappe di Karnaugh}
Karnaugh ha creato una mappa che permette di rappresentare su un piano tutte
le variabili booleane (nel caso della funzione \( O \)  si mettono i valori del cubo
nella tabella) in modo da poter fare l'assorbimento in modo più semplice. I valori
posti sopra le celle sono messi in modo che siano a distanza di Hamming = 1.
Nella seguente mappa di Karnaugh si possono vedere i valori della funzione \( O \):
\begin{center}
    \begin{karnaugh-map}[4][2][1][\( Y \)][\( X \)][\( Z \)]
        \minterms{4,5,7,6}
        \autoterms[0]
        \implicant{4}{6}
    \end{karnaugh-map}
\end{center}
In questa mappa si può vedere che \( Z \) è un implicante primo
(o sottocubo di dimensione massima).
Le mappe di Karnaugh sono come una sfera, quindi se si va oltre il bordo si torna
dall'altra parte.

Un altro esempio di mappa di Karnaugh è il seguente:
\begin{example}
    Prendiamo in considerazione una funzione casuale a 4 variabili:
    \begin{center}
        \begin{karnaugh-map}[4][4][1][\( Y \)][\( X \)][\( V \)][\( Z \)]
          \minterms{0,1,2,3,7,15,14,8,9,11,10}
          \autoterms[0]
          \implicantedge{0}{2}{8}{10}
          \implicant{15}{10}
          \implicant{3}{11}
        \end{karnaugh-map}    
    \end{center}
    Si può verificare che ci sono 3 implicanti primi essenziali:
    \begin{itemize}
        \item \( \bar{V} \): essenziale
            \item \( XY \): essenziale perchè copre \( 1101 \)
                \item \( XZ \): essenziale perchè copre \( 1011 \) 
    \end{itemize}
    \[
    O=\bar{V}+XY+XZ\;\;\;(5\;letterali)
    \] 
    Per capire quali sono gli implicanti primi bisogna raggruppare gli 1 in rettangoli
    più grandi possibile, ma sempre di grandezza \( 2^n \) (2, 4, 8, 16, \( \ldots \)).
    Per ciascun raggruppamento bisogna trovare le variabili che non cambiano il loro valore.
    Per il raggruppamento rosso:
    \begin{itemize}
        \item \textbf{\( X \)} cambia valore, passando da \( 0 \)  in \( 0000 \) e \( 0100 \)
            a \( 1 \)  in \( 1100 \) e \( 1000 \), quindi deve essere esclusa.
        \item \textbf{\( Y \)} cambia valore, passando da \( 0 \)  in \( 0000 \) e \( 1000 \)
            a \( 1 \)  in \( 0100 \) e \( 1100 \), quindi deve essere esclusa.
        \item \textbf{\( Z \)} cambia valore, passando da \( 0 \)  in \( 0000 \)
            a \( 1 \)  in \( 0010 \), quindi deve essere esclusa.
        \item \textbf{\( \bar{V} \)} mantiene lo stesso stato in tutto il gruppo, quindi
            deve essere inclusa nel prodotto risultante
    \end{itemize}
    Lo stesso ragionamento viene applicato per tutti i gruppi, fino ad arrivare al risultato finale.
\end{example}
Le mappe di Karnaugh sono utili soltanto se le variabili sono meno di 5, altrimenti
bisogna usare più mappe.



\section{Metodo di Quine-McCluskey}
Questo metodo ha 2 versioni:
\begin{itemize}
    \item Funzioni completamente specificate
        \item Funzioni parzialmente specificate
\end{itemize}
Si divide in 2 fasi:
\begin{enumerate}
\item Si espande il più possibile il problema per cercare il massimo grado di minimizzazione.
    (ad esempio trattando un \emph{don't care} come 1 per permettere ulteriori ottimizzazioni)
    \item Bisogna capire quali servono veramente.
\end{enumerate}

\subsection{Esempio con funzione completamente specificata}
\begin{example}
    Prendiamo una funzione completamente specificata
   \[
       O = f(x,y,z,w) = \{ m_1, m_4, m_5, m_6, m_7, m_9, m_{11}, m_{14}, m_{15} \}
   \]  
   \begin{table}[H]
       \begin{center}
           \begin{tabular}{c|c}
               \( m \) & \( x\;y\;z\;w \)\\
               \hline
               \( 1 \) & \( 0\;0\;0\;1 \)\\ 
               \( 4 \) & \( 0\;1\;0\;0 \)\\
               \( 5 \) & \( 0\;1\;0\;1 \)\\
               \( 6 \) & \( 0\;1\;1\;0 \)\\
               \( 7 \) & \( 0\;1\;1\;1 \)\\
               \( 9 \) & \( 1\;0\;0\;1 \)\\ 
               \( 11 \) & \( 1\;0\;1\;1 \)\\
               \( 14 \) & \( 1\;1\;1\;0 \)\\
               \( 15 \) & \( 1\;1\;1\;1 \)\\
           \end{tabular}
       \end{center}
       \caption{Tabella dei mintermini}
       \label{tab:quine-mccluskey1}
   \end{table}
    
   36 Letterali.\\
   L'unico caso in cui due stringhe sono a distanza di Hamming \( =1 \) è quando il numero di \( 1 \) differisce di uno.\\
   Il metodo di Quine-McCluskey riordina le \( m \)  in base al numero di \( 1 \) che contengono,
   questo è il primo passo:
   \begin{table}[H]
       \begin{center}
           \begin{tabular}{c|c|c}
               \( m \) &  x y z w  &\\
               \hline
               \( 1 \) &  0 0 0 1&\(\surd \)\\ 
               \( 4 \) & 0 1 0 0&\(\surd \)\\
               \hline
               \( 5 \) &  0 1 0 1&\(\surd \)\\
               \( 6 \) & 0 1 1 0&\(\surd \)\\
               \( 9 \) & 1 0 0 1&\(\surd \)\\ 
               \hline
               \( 7 \) &  0 1 1 1& \(\surd \)\\
               \( 11 \) & 1 0 1 1&\(\surd \)\\
               \( 14 \) & 1 1 1 0&\(\surd \)\\
               \hline
               \( 15 \) & 1 1 1 1&\(\surd \)\\
           \end{tabular}
       \end{center}
       \caption{Tabella riordinata}
       \label{tab:quine-mccluskey2}
   \end{table}
   Si individuano i gruppi che sono a distanza di Hamming 1. Nel prossimo passo
   confrontiamo i gruppi con \( 1\;bit=1 \) e con \( 2\;bit=1 \), se sono a 
   distanza di Hamming 1 allora si mette \emph{don't care} nel bit che cambia.
   Nella prima colonna c'è la coppia di \( m \) che viene confrontata. 
   \begin{table}[H]
       \begin{center}
           \begin{tabular}{c|c|c}
               \( m \) & \( x\;y\;z\;w \)\\
               \hline
               \( 1,\; 5 \) & 0 - 0 1 & A \\ 
               \( 1,\;9 \) & - 0 0 1 & B \\
               \( 4,\;5 \) & 0 1 0 - & \(\surd \)\\
               \( 4,\;6 \) & 0 1 - 0 & \(\surd \)\\
               \hline
               \( 5,\;7 \) & 0 1 - 1 & \(\surd \)\\
               \( 6,\;7 \) & 1 0 1 - & \( \surd \)\\
               \( 6,\;14 \) & - 1 1 0 & \( \surd \)\\
               \( 9,\;11 \) & 1 0 - 1 & C \\
               \hline
               \( 7,\;15 \) & - 1 1 1&\(\surd \)\\
               \( 11,\;15 \) & 1 - 1 1 & D \\
               \( 14,\;15 \) & 1 1 1 - & \(\surd \)\\
           \end{tabular}
       \end{center}
       \caption{Prima semplificazione}
       \label{tab:quine-mccluskey3}
   \end{table}
   Tutti i mintermini della tabella \ref{tab:quine-mccluskey2} sono coperti da un implicante
   della tabella \ref{tab:quine-mccluskey3}.

   Ora si può semplificare anche la tabella \ref{tab:quine-mccluskey3} se i don't care
   sono nella stessa variabile:
   \begin{table}[H]
       \begin{center}
           \begin{tabular}{c|c|c}
               \( m \) & \( x\;y\;z\;w \)\\
               \hline
               \( 4,\; 5, \;6, \;7 \) &  0 1 - -  & E \\ 
               \( 6, \;7, \;14, \;15 \) & - 1 1 - & F\\
           \end{tabular}
       \end{center}
        \caption{Seconda semplificazione}
        \label{tab:quine-mccluskey4}
   \end{table}
   I valori senza \( \surd \) sono implicanti primi perchè non sono coperti da nessun altro implicante
   della tabella \ref{tab:quine-mccluskey4}. Anche i 2 valori nella tabella \ref{tab:quine-mccluskey4} sono
   implicanti primi.\\
   Implicanti primi: \( A,B,C,D,E,F \)
   \[
   A=0-01=\bar{X}\bar{Z}W
\]
   \[
       B=-001=\bar{Y}\bar{Z}W
   \]
   \[
       C=10-1=X\bar{Y}W
   \]
   \[
       D=1-11=XZW
   \]
   \[
       E=01--=\bar{X}Y
   \]
   \[
       F=-11-=YZ
   \]
   16 Letterali.\\
Ad ogni passo del metodo di Quine-McCluskey diminuisce il numero di letterali.

Ora bisogna trovare gli implicanti primi essenziali
\begin{table}[H]
    \begin{center}
        \begin{tabular}{c|c|c|c|c|c|c}
            \( m \) & \( A \) & \( B \) & \( C \) & \( D \) & \( E \) & \( F \)\\ 
            \hline
            \( 1 \) & 1 & 1 &  &  &  &   \\
            \( 4 \) &  &  &  &  & \textbf{1} &   \\
            \( 5 \) & 1 &  &  &  & 1 &   \\
            \( 6 \) &  &  &  &  & 1 & 1  \\
            \( 7 \) &  &  &  &  & 1 & 1  \\
            \( 9 \) &  & 1 & 1 &  &  &   \\
            \( 11 \) &  &  & 1 & 1 &  &  \\
            \( 14 \) &  &  &  &  &  & \textbf{1}  \\
            \( 15 \) &  &  &  & 1 &  & 1  \\
        \end{tabular}
    \end{center}
    \caption{Tabella con implicanti primi}
\end{table}
E ed F sono essenziali perchè coprono \( m_4 \) e \( m_{14} \). Inoltre E ed F coprono
anche \( m_5, m_6, m_7 \) e \( m_6, m_7, m_{14}, m_{15} \).  

Tenendo in mente le \( m \) coperte, la tabella diventa:
\begin{table}[H]
    \begin{center}
        \begin{tabular}{c|c|c|c|c}
        & A & B & C & D\\
        \hline
            \( m_1 \) & 1 & 1 &  &  \\ 
            \( m_9 \) &  & 1 & 1 &  \\
            \( m_{11} \) &  &  & 1 & 1 \\ 
        \end{tabular}
    \end{center}
    \caption{Tabella senza implicanti essenziali}
\end{table}
\paragraph{Eulistica} È un metodo per trovare la soluzione corretta, ma non garantisce
che sia ottima.

Se si cancella ad esempio \( m_1, m_9 \) perchè coperti da \( B \), allora \( B \)
domina \( A \) e \( C \) domina D per la regola di \textbf{dominanza per colonne}.
Prendendo la colonna con più elementi ho più probabilità di trovare la soluzione
ottima.
\[
    O=E+F+B+C = \bar{X}Y+YZ+\bar{Y}\bar{Z}W+X\bar{Y}W
\] 
10 Letterali.\\
La \textbf{pseudo-essenzialità} è l'essenzialità dopo aver già fatto un'ottimizzazione.
\end{example}
\begin{example}
    Dominanza per righe
    \begin{center}
        \begin{tabular}{c|c|c|c|c}
            & A & B & C & D\\
            \hline 
            \( \alpha \) & 1 &  & 1 &  \\ 
            \( \beta \) & 1 &  &  & 1 \\
            \( \gamma \) &  & 1 & 1 & 1 \\
            \( \delta \) &  & 1 & 1 &  \\
            \( \epsilon \) & 1 & 1 &  & 1 \\
        \end{tabular}
    \end{center}
    \begin{itemize}
        \item \( \beta \) dominato da \( \epsilon \) 
            \item \( \delta \) dominato da \( \gamma \) 
    \end{itemize}
    Dobbiamo prendere \( \beta \) e \( \delta \) perchè cancellando \( A \) e \( D \)
    si cancellano anche \( \gamma \) ed \( \epsilon \) perchè sono dominati.  
    La tabella diventa:
    \begin{center}
               \begin{tabular}{c|c|c|c|c}
            & A & B & C & D\\
            \hline 
            \( \alpha \) & 1 & \vline & 1 &  \\ 
            \( \beta \) & 1 & \vline &  & 1  \\
             \( \delta \) &  & \textbf{1} \vline & 1 & \\
        \end{tabular}
    \end{center}
    Si fa finta che B e D siano essenziali (essenzialmente scelti a caso).
\end{example}


\subsection{Esempio con funzione parzialmente specificata}
Potrebbe uscire nel risultato un \emph{don't care}, ad esempio per condizioni di 
ingresso non utilizzate.

Prendiamo in considerazione una funzione booleana \( f(B^n)=B \) parzialmente
specificata che viene descritta tramite 3 insiemi:
\begin{itemize}
    \item \textbf{ON-SET}: insieme delle configurazioni per cui vale 1
    \item \textbf{DC-SET}: insieme delle configurazioni per le quali
        la funzione non è specificata
    \item \textbf{OFF-SET}: insieme delle configurazioni per cui vale 0
\end{itemize}
L'intersezione fra i 3 insiemi deve essere vuota, mentre l'unione è l'insieme
di tutte le configurazioni possibili.

Per conoscere tutti e 3 gli insiemi basta conoscerne 2 di essi.
\begin{example}
    Funzione parzialmente specificata
        \begin{center}
            \begin{tabular}{c|c}
                x y z v & 0\\
                \hline
                0 0 0 0 & 0\\
                0 0 0 1 & 0\\
                0 0 1 0 & 0\\
                0 0 1 1 & -\\
                0 1 0 0 & 1\\
                0 1 0 1 & -\\
                0 1 1 0 & -\\
                0 1 1 1 & -\\
                1 0 0 0 & 0\\
                1 0 0 1 & 0\\
                1 0 1 0 & 1\\
                1 0 1 1 & 1\\
                1 1 0 0 & 0\\
                1 1 0 1 & 1\\
                1 1 1 0 & 1\\
                1 1 1 1 & 1\\
            \end{tabular}
        \end{center}
        \[ON-SET = \{ m_4,m_{10},m_{11},m_{13},m_{14},m_{15} \} \]
        \[
        DC-SET = \{ m_3,m_5,m_6,m_7 \}
        \] 
        Il primo passo è quello di ampliare il problema, quindi si considerano i
        don't care come 1, e poi rioridnare i mintermini in base al numero di 1.
        \begin{center}
            \begin{tabular}{c|c|c}
                m & x y z v &\\
                \hline
                4 & 0 1 0 0 & \( \surd \) \\
                \hline
                3 & 0 0 1 1 &\( \surd \) \\
                5 & 0 1 0 1 &\( \surd \) \\
                6 & 0 1 1 0 &\( \surd \) \\
                10 & 1 0 1 0&\( \surd \) \\
                \hline
                7 & 0 1 1 1&\( \surd \) \\
                11 & 1 0 1 1&\( \surd \) \\
                13 & 1 1 0 1&\( \surd \) \\
                14 & 1 1 1 0&\( \surd \) \\
                \hline
                15 & 1 1 1 1&\( \surd \) \\
            \end{tabular}
        \end{center}
        Il secondo passo è quello di tentare la semplificazione:
        \begin{center}
            \begin{tabular}{c|c|c}
                m & x y z v& \\
                \hline
                4, 5 & 0 1 0 -& \( \surd \) \\
                4, 6 & 0 1 - 0& \( \surd \) \\
                \hline
                3, 7 & 0 - 1 1& \( \surd \) \\
                3, 11 & - 0 1 1& \( \surd \) \\
                5, 7 & 0 1 - 1& \( \surd \) \\
                5, 13 & - 1 0 1& \( \surd \) \\
                6, 7 & 0 1 1 -& \( \surd \) \\
                6, 14 & - 1 1 0& \( \surd \) \\
                10, 11 & 1 0 1 -& \( \surd \) \\
                10, 14 & 1 - 1 0& \( \surd \) \\
                \hline
                7, 15 & - 1 1 1& \( \surd \) \\
                11, 15 & 1 - 1 1& \( \surd \) \\
                13, 15 & 1 1 - 1& \( \surd \) \\
                14, 15 & 1 1 1 -& \( \surd \) \\
            \end{tabular}
        \end{center}
        Ora si applica di nuovo la semplificazione:
        \begin{center}
            \begin{tabular}{c|c|c}
                m & x y z v&\\
                \hline
                4, 5, 6, 7 & 0 1 - -& A\\
                \hline
                3, 7, 11, 15 & - - 1 1& B\\
                5, 7, 13, 15 & - 1 - 1& C\\
                6, 7, 14, 15 & - 1 1 -& D\\
                10, 11, 14, 15 & 1 - 1 -& E\\
            \end{tabular}
        \end{center}
        Visto che non si possono fare ulteriori semplificazioni \( A, B, C, D, E \)
        sono tutti implicanti primi.

        Ora si cerca di capire quali sono gli implicanti primi essenziali considerando
        però soltanto l'ON-SET:
        \begin{center}
            \begin{tabular}{c|c|c|c|c|c}
                m & A & B & C & D & E \\
                \hline
                \( m_4 \) & \textbf{1} &  &  &  &  \\ 
                \hline
                \( m_{10} \) &  &  &  &  & \textbf{1} \\
                \hline
                \( m_{11} \) &  & 1 &  &  & 1 \\
                \hline
                \( m_{13} \) &  &  & \textbf{1} &  &  \\
                \hline
                \( m_{14} \) &  &  &  & 1 & 1 \\
                \hline
                \( m_{15} \) &  & 1 & 1 & 1 & 1 
            \end{tabular}
        \end{center}
        Si cancellano le righe \( A, C, E \) perchè sono implicanti primi essenziali,
        quindi si coprono anche tutte le righe delle colonne \( A, C, E \) che
        contengono 1. Si arriva quindi a coprire tutta la tabella e il risultato
        finale è:
        \[
        O = A + C + E
        \] 
\end{example}



\section{Circuiti Combinatori}
\begin{itemize}
    \item \textbf{PROM}: Programmable Read Only Memory (ROM)
        \item \textbf{PLA}: Programmable Logic Array, attivano diverse porte logiche
\end{itemize}
I circuiti a 2 livelli sono composti da 2 livelli di porte logiche:
\begin{enumerate}
    \item Porte AND
        \item Porte OR
\end{enumerate}

\subsubsection{PLA (Programmable Logic Array)}
\begin{example}
    Un esempio di PLA:
    \textcolor{blue}{\[
        O_1 = \bar{X}Y + YV + XZ
    \] }
    \textcolor{red}{\[
        O_2 = \bar{X}\bar{Y} + YV + X\bar{Z}
    \] }
    \begin{center}
        \begin{tikzpicture}
            \node (x) at (0,0) {\( X \)};
            \draw (x) -- ++(0,0.5) -- ++(-0.3,0) -- ++(0,0.3) node[buffer port, anchor=in, scale=0.35, yscale=1.3, rotate=90] (notx1) {};
            \draw (x) -- ++(0,0.5) -- ++(0.3,0) -- ++(0,0.3) node[not port, anchor=in, scale=0.35, yscale=1.3, rotate=90] (notx2) {};

            \node (y) at (1.2,0) {\( Y \)};
            \draw (y) -- ++(0,0.5) -- ++(-0.3,0) -- ++(0,0.3) node[buffer port, anchor=in, scale=0.35, yscale=1.3, rotate=90] (noty1) {};
            \draw (y) -- ++(0,0.5) -- ++(0.3,0) -- ++(0,0.3) node[not port, anchor=in, scale=0.35, yscale=1.3, rotate=90] (noty2) {};

            \node (z) at (2.4,0) {\( Z \)};
            \draw (z) -- ++(0,0.5) -- ++(-0.3,0) -- ++(0,0.3) node[not port, anchor=in, scale=0.35, yscale=1.3, rotate=90] (notz1) {};
            \draw (z) -- ++(0,0.5) -- ++(0.3,0) -- ++(0,0.3) node[buffer port, anchor=in, scale=0.35, yscale=1.3, rotate=90] (notz2) {};

            \node (v) at (3.6,0) {\( V \)};
            \draw (v) -- ++(0,0.5) -- ++(-0.3,0) -- ++(0,0.3) node[not port, anchor=in, scale=0.35, yscale=1.3, rotate=90] (notv1) {};
            \draw (v) -- ++(0,0.5) -- ++(0.3,0) -- ++(0,0.3) node[buffer port, anchor=in, scale=0.35, yscale=1.3, rotate=90] (notv2) {};


            \draw (notx1) -- ++(0,5);
            \draw (notx2) -- ++(0,5);

            \draw (noty1) -- ++(0,5);
            \draw (noty2) -- ++(0,5);

            \draw (notz1) -- ++(0,5);
            \draw (notz2) -- ++(0,5);

            \draw (notv1) -- ++(0,5);
            \draw (notv2) -- ++(0,5);

            \node[and port, anchor=out, scale=0.5] (and1) at (5.5,6.12) {\( p_1 \)};
            \draw (notx1.out |- 52, 52 |- and1.out) -- (4.6, 52 |- and1.out) |- (and1.in 1);
            \draw  (4.6, 52 |- and1.out) |- (and1.in 2);

            \node[and port, anchor=out, scale=0.5] (and2) at (5.5,5.12) {\( p_2 \)};
            \draw (notx1.out |- 52, 52 |- and2.out) -- (4.6, 52 |- and2.out) |- (and2.in 1);
            \draw  (4.6, 52 |- and2.out) |- (and2.in 2);

            \node[and port, anchor=out, scale=0.5] (and3) at (5.5,4.12) {\( p_3 \)};
            \draw (notx1.out |- 52, 52 |- and3.out) -- (4.6, 52 |- and3.out) |- (and3.in 1);
            \draw  (4.6, 52 |- and3.out) |- (and3.in 2);

            \node[and port, anchor=out, scale=0.5] (and4) at (5.5,3.12) {\( p_4 \)};
            \draw (notx1.out |- 52, 52 |- and4.out) -- (4.6, 52 |- and4.out) |- (and4.in 1);
            \draw  (4.6, 52 |- and4.out) |- (and4.in 2);

            \node[and port, anchor=out, scale=0.5] (and5) at (5.5,2.12) {\( p_5 \)};
            \draw (notx1.out |- 52, 52 |- and5.out) -- (4.6, 52 |- and5.out) |- (and5.in 1);
            \draw  (4.6, 52 |- and5.out) |- (and5.in 2);

            \node[or port, anchor=out, scale=0.5, rotate=-90] (or1) at (6.5,0.5) {};
            \node[or port, anchor=out, scale=0.5, rotate=-90] (or2) at (7.5,0.5) {};
            \node[below] at (or1.out) {\( O_1 \)};
            \node[below] at (or2.out) {\( O_2 \)};
 
            \draw (and1.out |- 52, 52 |- and1.out) -- (or2.out |- 52, 52 |- and1.out);
            \draw (and2.out |- 52, 52 |- and2.out) -- (or2.out |- 52, 52 |- and2.out);
            \draw (and3.out |- 52, 52 |- and3.out) -- (or2.out |- 52, 52 |- and3.out);
            \draw (and4.out |- 52, 52 |- and4.out) -- (or2.out |- 52, 52 |- and4.out);
            \draw (and5.out |- 52, 52 |- and5.out) -- (or2.out |- 52, 52 |- and5.out);

            \draw (or1.out |- 52, 52 |- or1.in 1) -- (or1.out |- 52, 52 |- and1.out);
            \draw (or1.out |- 52, 52 |- or1.in 1) |- (or1.in 1);
            \draw (or1.out |- 52, 52 |- or1.in 1) |- (or1.in 2);

            \draw (or2.out |- 52, 52 |- or2.in 1) -- (or2.out |- 52, 52 |- and1.out);
            \draw (or2.out |- 52, 52 |- or2.in 1) |- (or2.in 1);
            \draw (or2.out |- 52, 52 |- or2.in 1) |- (or2.in 2);

            \draw[fill, circle, red] (notx1.out |- 52, 52 |- and1.out) circle [radius=0.08] node[anchor=west] {};
            \draw[fill, circle, red] (notx2.out |- 52, 52 |- and2.out) circle [radius=0.08] node[anchor=west] {};
            \draw[fill, circle, red] (noty2.out |- 52, 52 |- and2.out) circle [radius=0.08] node[anchor=west] {};
            \draw[fill, circle, red] (notz2.out |- 52, 52 |- and1.out) circle [radius=0.08] node[anchor=west] {};

            \draw[fill, circle, red] (or2.out |- 52, 52 |- and1.out) circle [radius=0.08] node[anchor=west] {};
            \draw[fill, circle, red] (or2.out |- 52, 52 |- and2.out) circle [radius=0.08] node[anchor=west] {};
            \draw[fill, circle, red] (or2.out |- 52, 52 |- and4.out) circle [radius=0.08] node[anchor=west] {};


            \draw[fill, circle, blue] (notx1.out |- 52, 52 |- and3.out) circle [radius=0.08] node[anchor=west] {};
            \draw[fill, circle, blue] (notx2.out |- 52, 52 |- and5.out) circle [radius=0.08] node[anchor=west] {};
            \draw[fill, circle, blue] (noty1.out |- 52, 52 |- and4.out) circle [radius=0.08] node[anchor=west] {};
            \draw[fill, circle, blue] (noty1.out |- 52, 52 |- and5.out) circle [radius=0.08] node[anchor=west] {};
            \draw[fill, circle, blue] (notz1.out |- 52, 52 |- and3.out) circle [radius=0.08] node[anchor=west] {};
            \draw[fill, circle, blue] (notv1.out |- 52, 52 |- and4.out) circle [radius=0.08] node[anchor=west] {};

            \draw[fill, circle, blue] (or1.out |- 52, 52 |- and3.out) circle [radius=0.08] node[anchor=west] {};
            \draw[fill, circle, blue] (or1.out |- 52, 52 |- and4.out) circle [radius=0.08] node[anchor=west] {};
            \draw[fill, circle, blue] (or1.out |- 52, 52 |- and5.out) circle [radius=0.08] node[anchor=west] {};
        \end{tikzpicture}
    \end{center}
\end{example}

\subsubsection{CPLD (Complex Programmable Logic Device)}
I CPLD ttivano diversi PLA.
\label{D2}

\subsubsection{FPGA (Field Programmable Gate Array)}
\label{D3}


\subsubsection{SoC (System on Chip)}
\label{D4}



% Laboratorio
\section{Laboratorio}
\subsection{SIS}
È il successore di \emph{Espresso} e permette di fare la sintesi di circuiti, cioè
si genera passo dopo passo il layout per il silicio.

Il modello di codice di SIS è il seguente:
\begin{lstlisting}[language=Verilog]
    .model <model-male> # nome della funzione
    .inputs <input-list> # elenco degli input
    .outputs <output-list> # elenco degli output
    .names # On-set/Off-set per ogni input
    <command> 
    ...
    <command>
    .end # il file deve essere 
\end{lstlisting}

\begin{example}
   Prendiamo in considerazoine la tabella di verità dell'
   implicazione logica:
   \begin{table}[H]
    \begin{center}
        \begin{tabular}{c|c}
            a b & a \(\implies\) b\\
            \hline
            0 0 & 1\\
            0 1 & 1\\
            1 0 & 0\\
            1 1 & 1\\
        \end{tabular}
    \end{center}
   \end{table}
   che si può scrivere anche nel seguente modo:
      \begin{table}[H]
    \begin{center}
        \begin{tabular}{c|c}
            a b & a \(\implies\) b\\
            \hline
            0 - & 1\\
            1 0 & 0\\
            1 1 & 1\\
        \end{tabular}
    \end{center}
   \end{table}

\begin{lstlisting}[language=Verilog]
   .model IMPLIES
   .inputs I1 I2
   .outputs O

   .names I1 I2 O
   # si definisce l'on-set o l'off-set  
   0- 1
   11 1
   .end
\end{lstlisting}
\end{example}

Lista di comandi base:
\begin{itemize}
    \item \textbf{read\_blif}: carica il modello sis,
    \item \textbf{simulate [valori in bit, separati da spazi]}: esegue un passo di
        simulazione del circuito,
    \item \textbf{help}: mostra i comandi disponibili,
    \item \textbf{help [comando]}: mostra la descrizione del comando,
    \item \textbf{print\_stats}: fornisce informazioni sul circuito, quali numero di input
       (pi), output (po), porte logiche (gates), numero di mintermini (minterms),
    \item \textbf{quit}: esce da sis,
    \item \textbf{read\_blif [nome file]}: carica il modello sis,
    \item \textbf{write\_blif [nome file]}: salva il modello sis in un file,
\end{itemize}
\end{document}
