\documentclass[a4paper]{article}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{textcomp}
\usepackage[italian]{babel}
\usepackage{amsmath, amssymb}
\usepackage{amsfonts}
\usepackage{mdframed}
\usepackage{float}
\usepackage{xcolor}
\usepackage{graphicx}
\usepackage{tikz}
\usepackage{circuitikz}
\graphicspath{{./figures/}}

\usepackage{ntheorem}
\newtheorem{theorem}{Teorema}

\usepackage{import}
\usepackage{pdfpages}
\usepackage{transparent}
\usepackage{xcolor}

% Useful definitions frame
\theoremstyle{break}
\theoremheaderfont{\bfseries}
\newmdtheoremenv[%
	linecolor=gray,leftmargin=0,%
	rightmargin=0,
	innertopmargin=8pt,%
	innerbottommargin=8pt,
	ntheorem]{define}{Definizioni utili}[section]

% Example frame
\theoremstyle{break}
\theoremheaderfont{\bfseries}
\newmdtheoremenv[%
	linecolor=gray,leftmargin=0,%
	rightmargin=0,
	innertopmargin=8pt,%
	innerbottommargin=8pt,
	ntheorem]{example}{Esempio}[section]

% Important definition frame
\theoremstyle{break}
\theoremheaderfont{\bfseries}
\newmdtheoremenv[%
	linecolor=gray,leftmargin=0,%
	rightmargin=0,
	backgroundcolor=gray!40,%
	innertopmargin=8pt,%
	innerbottommargin=8pt,
	ntheorem]{definition}{Definizione}[section]

% Exercise frame
\theoremstyle{break}
\theoremheaderfont{\bfseries}
\newmdtheoremenv[%
	linecolor=gray,leftmargin=0,%
	rightmargin=0,
	innertopmargin=8pt,%
	innerbottommargin=8pt,
	ntheorem]{exercise}{Esercizio}[section]

% figure support
\usepackage{import}
\usepackage{xifthen}
\pdfminorversion=7
\usepackage{pdfpages}
\usepackage{transparent}
\newcommand{\incfig}[1]{%
	\def\svgwidth{\columnwidth}
	\import{./figures/}{#1.pdf_tex}
}

\pdfsuppresswarningpagegroup=1

\begin{document}
\input{title.tex}

\tableofcontents
\pagebreak
\section{Introduzione}
L'informatica è nata per la risoluzione i problemi di calcolo, in particolare
quelli di calcolo numerico. Per questo motivo i primi computer erano macchine
che eseguivano operazioni aritmetiche. Per risolvere questi problemi si usano
degli algoritmi che sono una sequenza di istruzioni semplici che portano poi
a risolvere problemi di complessità variabile. Anche gli algoritmi hanno una
complessità che deve essere adeguata alla risoluzione del problema.

\subsection{Hardware}
Un algoritmo deve essere trasformato in un processo di calcolo automatico,
quindi deve essere implementato tramite hardware. Ci sono due tipi di hardware:
\begin{itemize}
	\item \textbf{Embedded} che è un hardware dedicato ad un singolo compito.
	      Ad esempio il microonde.
	\item \textbf{General purpose} non si sa l'utilizzo finale, quindi ha
	      funzionalità generali ampliate dal software installato. L'hardware
	      general purpose è programmabile attraverso il software. Un esempio
	      è il PC.
\end{itemize}

In base al tipo di hardware l'algoritmo viene implementato in diversi modi:
\begin{itemize}
	\item \textbf{Algoritmo} \( \to  \) \textbf{Software}: Tramite un linguaggio di programmazione
	\item \textbf{Algoritmo} \( \to  \)  \textbf{Hardware embedded}: Tramite linguaggi di basso livello
	      come C, Assembly o il sistema operativo.
	\item \textbf{Algoritmo} \( \to  \)  \textbf{Hardware}: Tramite sintesi logica
\end{itemize}

\subsection{Campionamento dei dati}
Ogni cosa nel mondo è rappresentabile da funzioni continue nel tempo \( f(t) \),
ma con risorse finite è impossibile rappresentare infiniti dati, bisogna quindi
campionarli.

\begin{figure}[h]
	\label{fig:f(t)}
	\centering
	\begin{tikzpicture}[scale=0.6, domain=0:10]
		\coordinate (A) at (0,4);
		\coordinate (B) at (1,4);
		\coordinate (C) at (2,2);
		\coordinate (D) at (3,4);
		\coordinate (E) at (4,1);
		\coordinate (F) at (5,3);
		\coordinate (G) at (6,2);
		\coordinate (H) at (7,4);
		\coordinate (I) at (8,3);
		\coordinate (J) at (9,2);
		\coordinate (K) at (10,5);

		\draw [->] (0,0) -- (10,0) node[right] {$t$};
		\draw [->] (0,0) -- (0,5) node[above] {$f(t)$};

		\draw [gray!50, ultra thin] (0,0) grid (10,5);
		\draw [blue, ultra thick] plot [smooth, tension=1] coordinates { (A) (B) (C) (D) (E) (F) (G) (H) (I) (J) (K) };
		\draw [red, thick ] (A) -- (B) -- (C) -- (D) -- (E) -- (F) -- (G) -- (H) -- (I) -- (J) -- (K);

		\draw [fill] (A) circle [radius=0.1];
		\draw [fill] (B) circle [radius=0.1];
		\draw [fill] (C) circle [radius=0.1];
		\draw [fill] (D) circle [radius=0.1];
		\draw [fill] (E) circle [radius=0.1];
		\draw [fill] (F) circle [radius=0.1];
		\draw [fill] (G) circle [radius=0.1];
		\draw [fill] (H) circle [radius=0.1];
		\draw [fill] (I) circle [radius=0.1];
		\draw [fill] (J) circle [radius=0.1];
		\draw [fill] (K) circle [radius=0.1];

		\draw (0, -0.2) -- (1, -0.2) node[below, xshift=-10] {\( \Delta t \) };
	\end{tikzpicture}
	\caption{Funzione casuale continua nel tempo}
\end{figure}
Per campionare la funzione nella figura \ref{fig:f(t)} bisogna scegliere un intervallo di tempo \( \Delta t \) e prendere
un valore della funzione ogni \( \Delta t \). In questo caso le linee
verticali rappresentano il \textbf{campionamento}, mentre quelle orizzontali
reppresentano la \textbf{discretizzazione o quantizzazione}.
La linea rossa è una spezzata approssimata della funzione continua, infatti
per il teorema di Shannon:

\begin{theorem}
	Deciso il grado di errore da voler compiere, esistono una precisa frequenza di
	campionamento e un intervallo di discretizzazione che garantiscono
	quell'errore.
\end{theorem}
Il sistema di calcolo è ora diventato digitale, cioè elabora i segnali numerici
in ingresso per produrre segnali numerici in uscita.

\begin{figure}[h]
	\centering
	\begin{tikzpicture}
		\node[draw, text=red, align=center] (Realtà fisica) at (0,0) {Realtà\\
			fisica};
		\node[draw, align=center] (Campionamento e discretizzazione) at (2,-1.5) {Campionamento e\\
			discretizzazione};
		\node[draw, text=blue, align=center] (Codifica) at (4,0) {Codifica};
		\node[draw, align=center] (Sistema digitale) at (6,-1.5) {Sistema\\
			digitale};
		\node[draw, text=blue, align=center] (Decodifica) at (8,0) {Decodifica};
		\node[draw, text=red, align=center] (Informazioni) at (9,-1.5) {Informazioni};

		\draw[->,draw] (Realtà fisica) to (Campionamento e discretizzazione);
		\draw[->,draw] (Campionamento e discretizzazione) to (Codifica);
		\draw[->,draw] (Codifica) to (Sistema digitale);
		\draw[->,draw] (Sistema digitale) to (Decodifica);
		\draw[->,draw] (Decodifica) to (Informazioni);
	\end{tikzpicture}
	\caption{Dalla realtà fisica al sistema digitale}
\end{figure}


\section{Sistemi di codifica}
Ogni sistema digitale lavora in base binaria, quindi entrano \( N \)  bit
ed escono \( M \)  bit. I bit in uscita devono essere codificati per
realizzare delle informazioni. Ci sono 2 tipi di informazioni:

\begin{itemize}
	\item \textbf{Informazioni intelleggibili}: sono già chiare agli esseri umani,
	      come un testo scritto.
	\item \textbf{Informazioni non intelleggibili}: hanno bisogno di macchine
	      per essere riprodotte, come le casse per l'audio.
\end{itemize}

\subsection{Codifica di informazioni non numeriche}
Ogni informazione deve avere un codice univoco in modo che il sistema
digitale non possa sbagliare a decodificarla. Date \( M \)  informazioni si
ricavano \( n = log_2{(M)} \)  codici disponibili per rappresentarle.

\begin{example}
	Con \( M=7 \) informazioni:
	\begin{itemize}
		\item \( n=log_2{(7)} \approx 3\; bit \)
		\item \( 2^3=8 \) codici disponibili
	\end{itemize}
\end{example}

\subsection{Numeri interi assoluti}
I numeri interi assoluti rappresentano solo i valori da \( 0 \) a \( 2^n-1 \),
dove \( n \) è il numero di bit disponibile.

La codifica da base decimale a base binaria prende il nome di \textbf{codifica
	a modulo}

\begin{example}
	\label{ex:57modulo}
	Si deve convertire il numero \( 57_{10} \) in base binaria
	\begin{center}
		\( n=log_2{(57)} = 6 \) bit (minimi)\\
		\( \sum_{i=1}^{n-1} 2^n-1 = 63 \) (codici massimi)
	\end{center}
	Si eseguono i seguenti passaggi:
	\begin{enumerate}
		\item Si sottraggono le potenze di 2 partendo da \( n-1 \).
		      \begin{itemize}
			      \item Se la potenza \( 2^i \) è minore o uguale del numero,
			            allora si moltiplica per 1.
			      \item Se la potenza \( 2^i \) è maggiore del numero,
			            allora si moltiplica per 0.
		      \end{itemize}
		\item Le sottrazioni continuano fino a quando si giunge a 0.
	\end{enumerate}
	\(57_{10}-{\textcolor{cyan}{1}}*2^{\textcolor{red}{5}}
		=25_{10}-{\textcolor{cyan}{1}}*2^{\textcolor{red}{4}}
		=9_{10}-{\textcolor{cyan}{1}}*2^{\textcolor{red}{3}}
		=1_{10}-{\textcolor{cyan}{0}}*2^{\textcolor{red}{2}}
		=1_{10}-{\textcolor{cyan}{0}}*2^{\textcolor{red}{1}}
		=1_{10}-{\textcolor{cyan}{1}}*2^{\textcolor{red}{0}}\)
\end{example}

\subsection{Numeri interi relativi}
La codifica più ovvia per i numeri interi relativi è la codifica a
\textbf{modulo + segno}. Tuttavia rappresenta varie problematiche, per cui
si preferisce usare la codifica in \textbf{complemento a 2}.

\subsubsection{Codifica a modulo + segno}
\begin{center}
	Intervallo: \( -2^{n-1} \le N \le 2^{n-1}-1 \)
\end{center}
Il segno si rappresenta con un bit, 0 per il positivo e 1 per il negativo.
Il bit più significativo è il bit del segno, mentre i bit meno significativi
rappresentano il modulo.

\begin{center}
	\begin{tikzpicture}
		\draw[draw] (0, 0) rectangle (2,1) node[pos=.5, align=center] {1 bit:\\
				segno \( \pm \) };
		\draw[draw] (2, 0) rectangle (7,1) node[pos=.5, align=center] {7 bit: modulo};
	\end{tikzpicture}
\end{center}
Considerando l'esempio \ref{ex:57modulo} si hanno le seguenti rappresentazioni:

\begin{center}
	\( +57_{10}=\textbf{0}|111001_2 \)\\
	\( -57_{10}=\textbf{1}|111001_2 \)
\end{center}
Sorge però un problema quando si vuole rappresentare il valore \( 0_{10} \),
che in binario risulterebbe:

\begin{center}
	\( +0_{10}=\textbf{0}|000000_2 \)\\
	\( -0_{10}=\textbf{1}|000000_2 \)
\end{center}
Inoltre le somme che passano dal positivo al negativo e viceversa risultano errate.

\subsubsection{Codifica in complemento a 2}
\begin{center}
	Intervallo: \( -2^{n-1} \le N \le 2^{n-1}-1 \)
\end{center}
La codifica in complemento a 2 rimuove tutti i problemi della codifica in modulo
+ segno. Questa codifica infatti rende le somme molto più semplici. La somma facile
infatti è l'obiettivo di questa codifica e parte dell'idea di trovare la
codifica di -1, pertanto si cerca di formulare \( -1+1=0 \).

\begin{center}
	\begin{tabular}{ c|c }
		Obiettivo            & Risultato      \\
		\hline                                \\
		\( ????_2 \) \( + \) & \( 1111_2 + \) \\
		\( 0001_2 = \)       & \( 0001_2 = \) \\ [2ex]
		\hline                                \\
		\( 0000_2 = \)       & \( 0000_2 \)   \\
	\end{tabular}
\end{center}

Se si considera il numero di bit \( n=4 \), allora l'intervallo di valori è
\( -2^3 \le N \le 2^3-1 \):

\begin{center}
	\begin{tabular}{c|c}
		\( 0_{10} = 0000_{2}\) & \( -1_{10} = 1111_{2}\) \\
		\( 1_{10} = 0001_{2}\) & \( -2_{10} = 1110_{2}\) \\
		\( 2_{10} = 0010_{2}\) & \( -3_{10} = 1101_{2}\) \\
		\( 3_{10} = 0011_{2}\) & \( -4_{10} = 1100_{2}\) \\
		\( 4_{10} = 0100_{2}\) & \( -5_{10} = 1011_{2}\) \\
		\( 5_{10} = 0101_{2}\) & \( -6_{10} = 1010_{2}\) \\
		\( 6_{10} = 0110_{2}\) & \( -7_{10} = 1001_{2}\) \\
		\( 7_{10} = 0111_{2}\) & \( -8_{10} = 1000_{2}\) \\
	\end{tabular}
\end{center}
I valori nel complemento a 2 ciclano, quindi se si somma 1 a 7 si ottiene -8.

\begin{example}
	Sottrazione con il complemento a 2: \( 43-17=25 \)
	\[
		n=7 \; bit
	\]
	\begin{enumerate}
		\item Per prima cosa si prende il valore assoluto del numero negativo
		      \( 17_{10} \) e si converte in binario.
		      \begin{center}
			      \( 17_{10}=0010001_{2} \)
		      \end{center}
		\item Si inverte il numero trovato.
		      \begin{center}
			      \( !(0010001_2) = 1101110_2 = -18_{10} \)
		      \end{center}
		\item Si somma 1 al numero trovato.
		      \begin{center}
			      \begin{tabular}{l}
				      \( 1101110\; + \) \\
				      \( 0000001 = \)   \\
				      \hline
				      \( 1101111 \)
			      \end{tabular}\\
			      \( 1101111_2 = -17_{10} \)
		      \end{center}
		\item Si somma il numero trovato al numero positivo.
		      \begin{center}
			      \begin{tabular}{l}
				      \( 0010001\; + \) \\
				      \( 1101111 = \)   \\
				      \hline
				      \( \textbf{1}0011010 \)
			      \end{tabular}
		      \end{center}
		\item Il risultato ottenuto è: \[
			      \textbf{1}0011010
		      \] Si osserva che c'è un bit in più rispetto a quelli disponibili (quello
		      in grassetto),
		      vuol dire che risulta in overflow\footnote{Indica il "traboccamento",
			      cioè se viene superato il limite massimo l'overfflow è un errore,
			      non perchè sia sbagliata la somma, ma perchè il risultato non è codificabile
			      con il numero di bit disponibili}, quindi si scarta il bit più significativo e
		      si ottiene:\[
			      0011010_2 = 26_{10}
		      \] che è il risultato corretto.
	\end{enumerate}
\end{example}

\paragraph{Estensione del numero con il complemento a 2}
\begin{itemize}
	\item Se un numero è \textbf{positivo} va esteso con gli \( \textbf{0} \)
	      \begin{center}
		      \begin{tabular}{l|l}                                        \\
			      \( +57_{10}+ \)  & \( 0111001_2\;+ \)        \\
			      \( +7_{10}\;= \) & \( \textbf{000}1001_2= \) \\ \\
			      \hline                                       \\
			      \( +64_{10} \)   & \( 1000010_2 \)
		      \end{tabular}
	      \end{center}
	\item Se un numero è \textbf{negativo} va esteso con gli \( \textbf{1} \)
	      \begin{center}
		      \begin{tabular}{l|l}                                        \\
			      \( +57_{10}+ \)  & \( 0111001_2\;+ \)        \\
			      \( -7_{10}\;= \) & \( \textbf{111}1001_2= \) \\ \\
			      \hline                                       \\
			      \( +50_{10} \)   & \( 10110010_2 \)
		      \end{tabular}
	      \end{center}
\end{itemize}

\section{Numeri razionali}
I numeri razionali sono composti da una parte intera e una parte frazionaria.
Si possono codificare in 2 modi:
\begin{itemize}
	\item \textbf{Virgola fissa}(fixed point): viene usata maggiormente nei
	      sistemi embedded quando si sa a priori il numero più grande e la
	      precisione che si vuole ottenere
	\item \textbf{Virgola mobile}(floating point): viene usata maggiormente
	      nei sistemi general purpose.
\end{itemize}

\subsection{Codifica in virgola fissa}
\begin{example}
	Si hanno a disposizione 8 bit: 4 per la parte intera e 4 per la parte frazionaria.
	Vogliamo decodificare il numero \( 0110.1011_2 \):
	\Large\[
		\underbrace{\stackrel{2^{3}}{0}\;\stackrel{2^{2}}{1}\;\stackrel{2^{1}}{1}\;\stackrel{2^{0}}{1}}_{+6} .
		\underbrace{\stackrel{2^{-1}}{1}\;\stackrel{2^{-2}}{0}\;\stackrel{2^{-3}}{1}\;\stackrel{2^{-4}}{1}}_{\frac{1}{2}+\frac{1}{8}+\frac{1}{16}}
	\]
	\normalsize\[
		+6 + \frac{1}{2}+\frac{1}{8}+\frac{1}{16}= 6+\frac{11}{16} = \frac{107}{16} = 6.6875
	\]
\end{example}
Se si vuole codificare un numero da decimale a binario bisogna tenere in considerazione
che non è certo che il numero sia razionale anche in base 2, quindi bisogna
approssimare per rappresentarlo.

\begin{example}
	\label{ex:virgolaFissaDecBin}
	Prendiamo in considerazione \( +4 +\frac{3}{5} \), in questo caso bisogna andare
	"a tentoni" e trovare la rappresentazione binaria che approssima con il minor
	errore possibile.
	\[
		4_{10} = 0100_2
	\]
	\[
		0.1001 = \frac{9}{10} \Delta \frac{3}{80}
	\]
	\[
		0.0111 = \frac{7}{16} \Delta -\frac{4}{80}
	\]
	\[
		0.0110 = \frac{3}{8} \Delta \frac{9}{40}
	\]
	\[
		\underline{0.1010 = \frac{5}{8} \Delta -\frac{1}{40}}
	\]
	\( \Delta \) rappresenta l'errore, quindi la rappresentazione più vicina è
	\( 0100.1010_2 \). Però non è stato rappresentato \( \frac{3}{5} \), ma
	\( \frac{1}{2}+\frac{1}{16}=\frac{9}{16} \).
\end{example}
Questo metodo è pesante perchè bisogna controllare più alternative.

\subsubsection{Errore percentuale}
Bisogna decidere se calcolarlo rispetto alla parte intera o a quella frazionaria.
Nel seguente esempio viene calcolato l'errore percentuale rispetto alla parte
frazionaria dell'esempio \ref{ex:virgolaFissaDecBin}.
\begin{example}
	\[
		\frac{1}{40} : \frac{3}{5} = \frac{1}{40} * \frac{5}{3} = \frac{1}{24} \approx 0.052\%
	\]
\end{example}
Il massimo errore che si può fare è l'overflow.

\subsection{Codifica in virgola mobile}
Gli standard della virgola mobile sono: IEEE 754. Questo standard
è stato rivisto molte volte e ora viene usato da tutte le codifiche per i numeri in
virgola mobile.\\
Il numero viene separato in 3 parti:
\begin{itemize}
	\item \textbf{M}: Mantissa
	\item \textbf{B}: Base 2
	\item \textbf{e}: Esponente
\end{itemize}
La struttura del numero è quindi:
\[
	N = \pm \cdot B^{\pm e}
\]
Questo permette di dividere il numero in modo da poter scegliere quanti bit dedicare
alla mantissa e quanti all'esponente. Si riscontrano però i seguenti problemi:
\begin{itemize}
	\item Bisogna scegliere la base in cui fare la codifica \(\to\)  base 2
	\item Bisogna scegliere la divisione di bit tra \emph{segno}, \emph{mantissa} e \emph{esponente} \( \to \)   \( 1\; S \), \( 23\; M \), \( 8\; e \)
	\item La rappresentazione deve essere univoca \( \to \)  \( 1.\; \ldots_2 \)
	\item Bisogna trovare un modo per rappresentare gli errori
\end{itemize}
Se la mantissa e la base sono in base 2 la moltiplicazione e la
divisione sono agevolate tramite l'utilizzo dello \emph{shift}.

\begin{itemize}
	\item \(0110 \cdot  2 = 1100\) è uno shift a sinistra in binario.
	      \begin{center}
		      \Large
		      \begin{tikzpicture}
			      \node[align=left] (Prima1) at (0,0) {0};
			      \node[align=left] (Prima2) at (0.2,0) {1};
			      \node[align=left] (Prima3) at (0.4,0) {1};
			      \node[align=left] (Prima4) at (0.6,0) {0};

			      \node[align=left] (Dopo1) at (0,-1) {1};
			      \node[align=left] (Dopo2) at (0.2,-1) {1};
			      \node[align=left] (Dopo3) at (0.4,-1) {0};
			      \node[align=left] (Dopo4) at (0.6,-1) {0};

			      \draw[->, draw] (Prima2) to (Dopo1);
			      \draw[->, draw] (Prima3) to (Dopo2);
			      \draw[->, draw] (Prima4) to (Dopo3);
		      \end{tikzpicture}
	      \end{center}

	\item \(1010/2 = 0101\) è uno shift a destra in binario.
	      \begin{center}
		      \Large
		      \begin{tikzpicture}
			      \node[align=left] (Prima1) at (0,0) {1};
			      \node[align=left] (Prima2) at (0.2,0) {0};
			      \node[align=left] (Prima3) at (0.4,0) {1};
			      \node[align=left] (Prima4) at (0.6,0) {0};

			      \node[align=left] (Dopo1) at (0,-1) {0};
			      \node[align=left] (Dopo2) at (0.2,-1) {1};
			      \node[align=left] (Dopo3) at (0.4,-1) {0};
			      \node[align=left] (Dopo4) at (0.6,-1) {1};

			      \draw[->, draw] (Prima1) to (Dopo2);
			      \draw[->, draw] (Prima2) to (Dopo3);
			      \draw[->, draw] (Prima3) to (Dopo4);
		      \end{tikzpicture}
	      \end{center}

\end{itemize}


\subsubsection{Divisione di bit tra segno, mantissa ed esponente}
Un numero è rappresentabile in 2 modi:
\begin{itemize}
	\item Singola precisione 32 bit \( \to  \) float
	\item Doppia precisione 64 bit \( \to  \) double
\end{itemize}

Prendiamo in considerazione 32 bit, ora dobbiamo decidere quanti bit dedicare
alla mantissa e all'esponente.
\[
	2^{\pm e}
\]
\begin{center}
	$|e| = 4 bit = 2^{+7}$\\
	$5 bit = 2^{+15}$\\
	$6 bit = 2^{+31}$\\
	$7 bit = 2^{+63}$\\
	$8 bit = 2^{+127}$
\end{center}
L'impatto dei bit sull'esponente è doppiamente esponenziale, quindi cresce tantissimo.

\begin{itemize}
	\item \textbf{8 bit} all'esponente, quindi l'esponente
	      può assumere valori da \( -127 \) a \( +127 \).
	\item \textbf{23 bit} alla mantissa, quindi la mantissa
	      può assumere valori da \( 0 \) a \( 2^{23}-1 \)
	\item \textbf{1 bit} al segno.
\end{itemize}

\begin{center}
	\begin{tikzpicture}
		\draw[draw] (0, 0) rectangle (1.6,1) node[pos=.5, align=center] {1 bit:\\
				segno \( \pm \) };
		\draw[draw] (1.6, 0) rectangle (5,1) node[pos=.5, align=center] {8 bit: esponente};
		\draw[draw] (5, 0) rectangle (10,1) node[pos=.5, align=center] {23 bit: mantissa};
	\end{tikzpicture}
\end{center}
Per la rappresentazione univoca la mantissa si codifica in virgola fissa.
Cioè si parte da una mantissa con un \textbf{punto fisso} e dividendo o moltiplicando (shift) si
può spostare la virgola per arrivare alla forma \textbf{1.00000...} e questa forma è la
rappresentazione univoca.

Questa operazioe si chiama \textbf{normalizzazione} e visto che la
rappresentazione è sempre la stessa l'\emph{1.} non viene rappresentato, quindi
viene inserito nella mantissa solo tutto ciò che viene dopo.
\begin{figure}[H]
	\begin{center}
		\( 11111111 \) \( \pm \infty \)\\
		\( 11111110 \) \( +127 \) \\
		\( \ldots \)\\
		\( 00000000 \) \( \pm 0 \)\\
		\( \ldots \)\\
		\( 00000001 \) \( -126 \) \\
		\( 00000000 \) \( -127 \)
	\end{center}
	\caption{Range dell'esponente}
\end{figure}
Si è deciso di codificare l'esponente in \textbf{Eccesso 127}. Quindi per
rappresentare lo zero si usa come esponente il minore numero possibile:
$1 \cdot 2^{-127} = 0$. Per codificare i numeri si somma 127 al numero desiderato
e visto che i numeri possibili ora vanno da -127 a +127 se codifichiamo
il risultato in modulo avremo dei numeri da 0 a 256.

\begin{figure}[H]
	\begin{example}
		Si vuole decodificare il seguente numero:
		\[1\:01110111\:0110...0\]
		\[M = -(1+\frac{1}{4}+\frac{1}{4})*2 = -(\frac{11}{8})*2^{e}\]
		\[E = (1+2+4+16+32+64)-127=119-127=-8\]
		\[N = -\frac{11}{8} * 2^{-8}\]
	\end{example}
\end{figure}

\begin{figure}[H]
	\begin{example}
		Codifica $+(4+\frac{1}{2}+\frac{1}{16})*2^{+34}$
		\begin{enumerate}
			\item Sappiamo già che il numero è positivo quindi:
			      \[
				      S=0
			      \]
			\item Calcoliamo la mantissa:
			      \[
				      4+\frac{1}{2}+\frac{1}{16}= \underbrace{100}_{4_{10}}.
				      \underbrace{10010 \ldots 0}_{\frac{1}{2}+\frac{1}{16}}
			      \]
			\item La mantissa va normalizzata moltiplicando per 4:
			      \[
				      100.10010 \ldots 0 * 2^{+2} = 1.0010010 \ldots 0
			      \]
			      \[
				      M = 0010010 \ldots 0
			      \]
			\item Calcoliamo l'esponente:
		\end{enumerate}
	\end{example}
\end{figure}

\begin{itemize}
	\item $0\:00000000\:0...0 = +0$
	\item $1\:00000000\:0...0 = -0$
\end{itemize}

Quando l'esponente è tutto 1 e la mantissa tutta 0 allora equivale a $infinito$
+ o - in base al primo bit. Se invece la mantissa è diversa da 0 con esponente tutti 1
allora rappresenta un errore NaN.

Somma:\\
\label{es2}


%Lezione 4
\section{Modelli}
Per un progetto bisogna creare un \textbf{modello} che rappresenti il sistema.
Boole ha cercato di rappresentare tutte le algebre. Lo ha fatto attraverso
una quintupla: \( <B^{n}, \cdot, + ,\{0,1\}> \)
\begin{figure}[H]
	\centering
	\begin{tikzpicture}
		\node[draw, align=center] (Sistema digitale) at (0,0) {Sistema\\
			digitale};

		\draw[->, draw] (Sistema digitale) to (2,0);
		\draw[<-, draw] (Sistema digitale) to (-2,0);

		\node (A) at (-2,0.3) {A};
		\node (B) at (-2,-0.3) {B};
		\node (O) at (2,0.3) {O};
	\end{tikzpicture}
\end{figure}

\begin{itemize}
	\item \( B^n \) è l'insieme di valori
	\item \( \{0,1\} \) è l'alfabeto (sistema binario)
	\item "\( \cdot  \)" e "\( + \)" sono 2 operatori
\end{itemize}
Bool garantisce che si può creare qualsiasi funzione utilizzando soltanto i
2 operatori:
\[
	f(B^n) \to B^m
\]
\begin{example}
	Si vuole creare un modello con 2 bit in entrata e 1 in uscita:
	\[
		n=2 \; m=1
	\]
	\( O=1 \leftrightarrow A=B \)\\
	\( f(B^2) \to B \)
	\begin{center}
		\begin{tikzpicture}
			\draw[thick] (0,0) circle [x radius=0.5cm, y radius=1.5cm]
			(2,0) circle [x radius=0.5cm, y radius=1.5cm];

			\node[align=center] (00) at (0,0.8) {00};
			\node[align=center] (11) at (0,0.3) {11};
			\node[align=center] (01) at (0,-0.2) {01};
			\node[align=center] (10) at (0,-0.7) {10};

			\node[align=center] (1) at (2,0.6) {1};
			\node[align=center] (0) at (2,-0.5) {0};

			\draw[->, draw] (00) to (1);
			\draw[->, draw] (11) to (1);
			\draw[->, draw] (01) to (0);
			\draw[->, draw] (10) to (0);
		\end{tikzpicture}
	\end{center}
	Per mappare i valori in ingresso con quelli di uscita si usa una
	\textbf{tabella di verità}:
	\begin{center}
		\begin{tabular}{c|c|c}
			\( A \) & \( B \) & \( O \) \\
			\hline
			0       & 0       & 1       \\
			0       & 1       & 0       \\
			1       & 0       & 0       \\
			1       & 1       & 1       \\
		\end{tabular}
	\end{center}
	Chiamiamo mintermine un punto dello spazio booleano in ingresso in cui la
	funzione vale 1. Il maxtermine è il contrario.
	L'insieme di mintermini \( \{m_0\footnote{\( m_n \): n è il valore in modulo
		del relativo numero binario, \( m \) sta per modulo. \( m_3 = 11_2 \) }, m_3\} \) si chiama \textbf{ON-SET}
	L'insieme dei maxtermini \( \{m_1, m_2\} \) si chiama \textbf{OFF-SET}. Basta
	uno dei due insiemi (ON-SET, OFF-SET) per definire la funzione.
	\[
		m_3 = A \cdot B
	\]
	Dire che \( m_3 \) è il prodotto delle due variabili è un modo corretto per
	rappresentarlo.
	\[
		m_0 = \bar{A} \cdot \bar{B}
	\]
	Per rappresentare il mintermine basta fare il prodotto delle variabili se
	valgono 1 o delle variabili negate se valgono 0.

	Per rappresentare la funzione si può usare la somma dei mintermini:
	\[
		O = m_0 + m_3 = \bar{A} \cdot \bar{B} + A \cdot B = 0
	\]
	Questa rappresentazione viene detta: \emph{Espressione in somma di prodotti}
	\begin{theorem}
		Dato un ON-SET c'è sempre una sola espressione in somma di prodotti che lo
		rappresenti.
	\end{theorem}
\end{example}

\subsection{Tabelle di verità}
\subsubsection{Operatore prodotto}
\begin{center}
	\begin{tabular}{c|c|c}
		\( A \) & \( B \) & \( O \) \\
		\hline
		0       & 0       & 0       \\
		0       & 1       & 0       \\
		1       & 0       & 0       \\
		1       & 1       & 1       \\
	\end{tabular}
\end{center}

\subsubsection{Operatore somma}
\begin{center}
	\begin{tabular}{c|c|c}
		\( A \) & \( B \) & \( O \) \\
		\hline
		0       & 0       & 0       \\
		0       & 1       & 1       \\
		1       & 0       & 1       \\
		1       & 1       & 1       \\
	\end{tabular}
\end{center}

\subsubsection{Operatore negazione}
\begin{center}
	\begin{tabular}{c|c}
		\( A \) & \( O \) \\
		\hline
		0       & 1       \\
		1       & 0       \\
	\end{tabular}
\end{center}

\section{Transistor}
È un "comando di accensione" che permette di accendere o spegnere un circuito.
\subsection{Transistor CMOS}
\subsubsection{Transistor N}
Mette in collegamento 2 punti:
\begin{itemize}
	\item Se la corrente è 0V allora non c'è collegamento
	\item Se la corrente è 3V allora c'è collegamento
\end{itemize}

\begin{figure}[H]
	\begin{center}
		\begin{circuitikz}[american,]
			\node (Vcc) at (0,0.3) {\( V_{cc} \) };
			\draw (0,0) -- (1,0) to[short,-*] ++(0,0) node[left] {}
			(2,0) -- (1,0)
			node[nmos,anchor=D] (nmos) {}
			(nmos.G) to[short] ++(0,0) node[left] {}
			(nmos.S) node[ground] {};
		\end{circuitikz}
	\end{center}
	\caption{Transistor N}
\end{figure}

\subsubsection{Transistor P}
Mette in collegamento 2 punti:
\begin{itemize}
	\item Se la corrente è 0V allora c'è collegamento
	\item Se la corrente è 3V allora non c'è collegamento
\end{itemize}

\begin{figure}[H]
	\begin{center}
		\begin{circuitikz}[american,]
			\node (Vcc) at (0,0.3) {\( V_{cc} \) };
			\draw (0,0) -- (1,0) to[short,-*] ++(0,0) node[left] {}
			(2,0) -- (1,0)
			node[pmos,anchor=S] (pmos) {}
			(pmos.G) to[short] ++(0,0) node[left] {}
			(pmos.D) node[ground] {};

		\end{circuitikz}
	\end{center}
	\caption{Transistor P}
\end{figure}
\subsubsection{Circuito di negazione (NOT)}
Si realizza con un transistor P e uno N in serie.
\begin{figure}[H]
	\begin{center}
		\begin{circuitikz}
			\node (Vcc) at (-1,0.3) {\( V_{cc} \) };
			\node (Vcc) at (1,0.3) {\( 3V \) };
			\draw (-1,0) -- (0,0) to[short,-*] ++(0,0) node[left] {}
			(1,0) -- (0,0);
			\draw (0,0) node[pmos, anchor=S] (pmos) {}
			(pmos.G) to[short] ++(0,0) node[left] {}
			(pmos.D) to[short] ++(0,0) node[left] {}
			(pmos.D) -- ++(0,0) to[short,-*] (0,-1.6) node[left] {}
			node[nmos,anchor=D] (nmos) {}
			(nmos.G) to[short] ++(0,0) node[left] {}
			(nmos.S) node[ground] {};
			\draw (-2, -1.6) node[above] {\( x \) } to[short,-*] (-0.99,-1.6) node[left] {}
			(pmos.G) -- ++(0,0) to[short,-*] (-0.99,-1.6) node[left] {}
			(0,-1.6) -- ++(0,0) to[short] (1.2,-1.6) node[above] {O}
			(nmos.G) -- ++(0,0) to[short] (-0.99,-1.6) node[left] {};
			\node (0V) at (0.6,-3.5) {\( 0V \) };
		\end{circuitikz}
	\end{center}
\end{figure}
La tabella della verità è:
\begin{center}
	\begin{tabular}{c|c}
		\( x \) & \( O \) \\
		\hline
		0V      & 3V      \\
		3V      & 0V      \\
	\end{tabular}
\end{center}
Se assegnamo ad ogni valore un numero binario:
\begin{center}
	\begin{tabular}{c|c}
		\( x \) & \( O \) \\
		\hline
		0       & 1       \\
		1       & 0       \\
	\end{tabular}
\end{center}
Si può notare che è la funzione di negazione rappresentata con la seguente
porta logica:
\begin{figure}[H]
	\begin{center}
		\begin{circuitikz}
			\draw (0,0) node[scale=0.7, not port] (not) {};
			\draw (not.in) node[left] {x};
			\draw (not.out) node[right] {O};
		\end{circuitikz}
	\end{center}
\end{figure}

\subsubsection{Circuito del prodotto (AND)}
\begin{center}
	\begin{circuitikz}
		\node (x) at (-2,-0.23) {x};
		\node (y) at (-2,-2.77) {y};
		\node (O) at (1.2,-1.3) {O};

		\node (Vcc) at (-1.5,1.8) {\( V_{cc}=3V \) };

		\filldraw[black] (1,0) circle (1.5pt) node[anchor=west]{};
		\filldraw[black] (-0.28,-0.23) circle (1.5pt) node[anchor=west]{};
		\filldraw[black] (-0.98,-2.77) circle (1.5pt) node[anchor=west]{};
		\filldraw[black] (2,1.55) circle (1.5pt) node[anchor=west]{};
		\filldraw[black] (0,1.55) circle (1.5pt) node[anchor=west]{};

		\draw
		(0,0) node[pmos, anchor=D] (pmos1) {} (0,0) -- (2,0)
		(2,0) node[pmos, anchor=D] (pmos2) {} (2,0)
		(1,0) node[nmos, anchor=D] (nmos1) {} (1,-1)
		(1,-1.54) -- (1,-2) node[nmos, anchor=D] (nmos2) {} (1,-2)
		(nmos2.S) node[ground] {}
		(pmos1.G) to ++(0,-3.542)
		(pmos2.G) to ++(-1.3,0) -- ++(0, -1) to[short] (x)
		(nmos1.G) to ++(-0.3,0) -- ++(0,1)
		(nmos2.G) to[short] (y)
		(-2,1.55) -- ++(5,0)
		(nmos1.S) -- ++(2,0) -- ++(0,1.497)
		;

		\begin{scope}[shift={(5,1.55)}]
			\draw (-2,0) -- (0,0) to[short,-*] ++(0,0) node[left] {}
			(1,0) -- (0,0);
			\draw (0,0) node[pmos, anchor=S] (pmos) {}
			(pmos.G) to[short] ++(0,0) node[left] {}
			(pmos.D) to[short] ++(0,0) node[left] {}
			(pmos.D) -- ++(0,0) to[short,-*] (0,-1.6) node[left] {}
			node[nmos,anchor=D] (nmos) {}
			(nmos.G) to[short] ++(0,0) node[left] {}
			(nmos.S) node[ground] {};
			\draw (-2, -1.6) node[above] {} to[short,-*] (-0.99,-1.6) node[left] {}
			(pmos.G) -- ++(0,0) to[short,-*] (-0.99,-1.6) node[left] {}
			(0,-1.6) -- ++(0,0) to[short] (1.2,-1.6) node[above] {O}
			(nmos.G) -- ++(0,0) to[short] (-0.99,-1.6) node[left] {};
			\node (0V) at (0.6,-3.5) {\( 0V \) };
		\end{scope}
        \draw (-3,-5) -- ++(5,0);
	\end{circuitikz}
\end{center}

\section{Espressione in somma di prodotti}
\label{D6}
I circuiti devono spesso tenere conto di alcune specifiche da ottimizzare:
\begin{itemize}
	\item \textbf{Area}: minor numero di porte logiche
	\item \textbf{Latency}: più porte logiche si attraversano più sarà il ritardo
	\item \textbf{Power}: più porte logiche si attraversano più sarà
	      il consumo
	\item \textbf{Safety}: più porte logiche si attraversano più sarà
	      la probabilità di errore
\end{itemize}
Prendiamo in considerazione la funzione \( f(B^3)\footnote{Il numero di funzioni booleane
	possibili è \( 2^{2^3} = 256 \) e il valore cresce esponenzialmente con
	l'aumento dei bit}\to B \):
\begin{center}
	\begin{tabular}{c|c}
		X Y Z   & O \\
		\hline
		0\;0\;0 & 0 \\
		0\;0\;1 & 1 \\
		0\;1\;0 & 0 \\
		0\;1\;1 & 1 \\
		1\;0\;0 & 0 \\
		1\;0\;1 & 1 \\
		1\;1\;0 & 0 \\
		1\;1\;1 & 1 \\
	\end{tabular}
\end{center}
ON-SET\(=\{ m_1,m_3,m_5,m_7 \} \)\\
La funzione rappresentata con un'espressione in somma di prodotti è:
\[ O=m_1+m_3+m_5+m_7 = \bar{X}\bar{Y}Z + \bar{X}YZ + X\bar{Y}Z + XYZ \]
Proviamo a stimare le dimensioni di questo circuito. Si utilizza il concetto
di \textbf{letterale} che è una coppia chiave-valore. La funzione \( O \)
è composta da 12 letterali e questo numero è in relazione con il numero di
transistor nel senso che se una funzione ha più letterali di un altra si può
già sapere che avrà bisogno di un minor numero di transistor.
\subsection{Riduzione}
La regola principale della riduzione è l'assorbimento:
Preso un prodottp \( P \)  moltiplicato ad un letterale \( a \) e la somma di
questo prodotto, ma con il letterale negato \( \bar{a} \) allora il risultato
è \( P \cdot  (a+\bar{a}) \) dove \( (a+\bar{a}) \) fa sempre 1, quindi rimane
\( P \).
\[
	aP+\bar{a}P=P \cdot (a+\bar{a}) = P
\]

\[
	2 \cdot (|P|+1) \Rightarrow |P|
\]
Quindi se prendiamo come riferimento la funzione \( O \) si può applicare la
regola dell'assorbimento per ridurre il numero di letterali:
\[ \bar{x}Z \cdot (\bar{Y}+Y) + XZ(\bar{Y}+Y) \]
E riapplicando la regola si arriva al minimo:
\[
	Z
\]
\label{D7}
\subsection{Terminologia}
Ogni mintermine è un prodotto (o implicante), ma dopo aver applicato la regola
di assorbimento non è più un mintermine, ma soltanto prodotto (o implicante).
\[
	\bar{Z}\bar{Y}Z \to \bar{X}Z
\]
La \( Y \) non c'è più nel risultato dell'assorbimento, ciò vuol dire che non
ci interessa il suo valore perchè non varia il risultato. Si può scrivere sia
\(
11
\)
che
\(
1-1
\)\\
Quindi ad esempio:\\
\( Z=--1=4\; \)mintermini: \( \{ 001, 011, 101, 111 \} \)
\begin{definition}
	\textbf{Implicante primo} è un implicante non contenuto in nessun altro
	implicante
\end{definition}

\section{Assorbimento}
Prendendo come riferimento la funzione O:
\label{D8}
L'assorbimento può essere fatto soltanto tra gli ON-SET con distanza di
Hamming = 1.
\begin{definition}
	La \textbf{distanza di Hamming} è il numero di bit che differenziano 2 codici.
	\begin{center}
		\( 0110 \to 0101\; \) distanza di Hamming = 2
		\( 010 \to 011\; \) distanza di Hamming = 1
	\end{center}
\end{definition}
Per effettuare l'assorbimento ci si posiziona nel punto di un mintermine e si
"guarda" in tutte le direzioni per eventuali altri mintermini con cui fare il
prodotto.
\label{D9}
Ora si può fare l'assorbimento anche tra i prodotti ottenuti dall'assorbimento:
\label{D10}
Si arriva quindi a dire che \( Z \) è un implicante primo perchè non c'è nessun
altro implicante che lo contiene.
\begin{define}
	Quando si parla di implicante si può anche dire \textbf{sottocubo} e
	l'implicante primo può essere chiamato anche \textbf{sottocubo di dimensione
		massima}.
	\begin{center}
		Implicante = Sottocubo\\
		Implicante primo = Sottocubo di dimensione massima
	\end{center}
\end{define}
Esistono condizioni favorevoli (come la funzione O) in cui un implicante primo
contiene tutti i mintermini della funzione.\\
Ci sono più tipi di implicanti primi:
\begin{itemize}
	\item \textbf{Essenziali}: includono almeno un mintermine che non è coperto da nessun
	      altro implicante primo (fanno parte della soluzione finale).
	\item \textbf{Non essenziali}:  Implicanti primi che coprono mintermini
	      coperti anche da altri implicanti.
	      Si identificano con l'\textbf{algoritmo di copertura}
\end{itemize}
Karnaugh ha creato una mappa che permette di rappresentare su un piano tutte
le variabili booleane (nel caso della funzione O si mettono i valori del cubo
nella tabella).
\label{D11}

\label{D12} %Esempio con funzione casuale

\end{document}
